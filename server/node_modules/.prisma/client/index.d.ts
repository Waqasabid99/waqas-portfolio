
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ContactForm
 * 
 */
export type ContactForm = $Result.DefaultSelection<Prisma.$ContactFormPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model WebDevelopmentDetail
 * 
 */
export type WebDevelopmentDetail = $Result.DefaultSelection<Prisma.$WebDevelopmentDetailPayload>
/**
 * Model WebDevelopmentFeature
 * 
 */
export type WebDevelopmentFeature = $Result.DefaultSelection<Prisma.$WebDevelopmentFeaturePayload>
/**
 * Model SeoDetail
 * 
 */
export type SeoDetail = $Result.DefaultSelection<Prisma.$SeoDetailPayload>
/**
 * Model SeoType
 * 
 */
export type SeoType = $Result.DefaultSelection<Prisma.$SeoTypePayload>
/**
 * Model DigitalMarketingDetail
 * 
 */
export type DigitalMarketingDetail = $Result.DefaultSelection<Prisma.$DigitalMarketingDetailPayload>
/**
 * Model DigitalMarketingService
 * 
 */
export type DigitalMarketingService = $Result.DefaultSelection<Prisma.$DigitalMarketingServicePayload>
/**
 * Model SocialPlatform
 * 
 */
export type SocialPlatform = $Result.DefaultSelection<Prisma.$SocialPlatformPayload>
/**
 * Model ContentGenerationDetail
 * 
 */
export type ContentGenerationDetail = $Result.DefaultSelection<Prisma.$ContentGenerationDetailPayload>
/**
 * Model ContentType
 * 
 */
export type ContentType = $Result.DefaultSelection<Prisma.$ContentTypePayload>
/**
 * Model ContentLanguage
 * 
 */
export type ContentLanguage = $Result.DefaultSelection<Prisma.$ContentLanguagePayload>
/**
 * Model AppDevelopmentDetail
 * 
 */
export type AppDevelopmentDetail = $Result.DefaultSelection<Prisma.$AppDevelopmentDetailPayload>
/**
 * Model AppFeature
 * 
 */
export type AppFeature = $Result.DefaultSelection<Prisma.$AppFeaturePayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model ProjectStatusHistory
 * 
 */
export type ProjectStatusHistory = $Result.DefaultSelection<Prisma.$ProjectStatusHistoryPayload>
/**
 * Model PortfolioProject
 * 
 */
export type PortfolioProject = $Result.DefaultSelection<Prisma.$PortfolioProjectPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactForm`: Exposes CRUD operations for the **ContactForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactForms
    * const contactForms = await prisma.contactForm.findMany()
    * ```
    */
  get contactForm(): Prisma.ContactFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webDevelopmentDetail`: Exposes CRUD operations for the **WebDevelopmentDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebDevelopmentDetails
    * const webDevelopmentDetails = await prisma.webDevelopmentDetail.findMany()
    * ```
    */
  get webDevelopmentDetail(): Prisma.WebDevelopmentDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webDevelopmentFeature`: Exposes CRUD operations for the **WebDevelopmentFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebDevelopmentFeatures
    * const webDevelopmentFeatures = await prisma.webDevelopmentFeature.findMany()
    * ```
    */
  get webDevelopmentFeature(): Prisma.WebDevelopmentFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seoDetail`: Exposes CRUD operations for the **SeoDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeoDetails
    * const seoDetails = await prisma.seoDetail.findMany()
    * ```
    */
  get seoDetail(): Prisma.SeoDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seoType`: Exposes CRUD operations for the **SeoType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeoTypes
    * const seoTypes = await prisma.seoType.findMany()
    * ```
    */
  get seoType(): Prisma.SeoTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.digitalMarketingDetail`: Exposes CRUD operations for the **DigitalMarketingDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DigitalMarketingDetails
    * const digitalMarketingDetails = await prisma.digitalMarketingDetail.findMany()
    * ```
    */
  get digitalMarketingDetail(): Prisma.DigitalMarketingDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.digitalMarketingService`: Exposes CRUD operations for the **DigitalMarketingService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DigitalMarketingServices
    * const digitalMarketingServices = await prisma.digitalMarketingService.findMany()
    * ```
    */
  get digitalMarketingService(): Prisma.DigitalMarketingServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialPlatform`: Exposes CRUD operations for the **SocialPlatform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialPlatforms
    * const socialPlatforms = await prisma.socialPlatform.findMany()
    * ```
    */
  get socialPlatform(): Prisma.SocialPlatformDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentGenerationDetail`: Exposes CRUD operations for the **ContentGenerationDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentGenerationDetails
    * const contentGenerationDetails = await prisma.contentGenerationDetail.findMany()
    * ```
    */
  get contentGenerationDetail(): Prisma.ContentGenerationDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentType`: Exposes CRUD operations for the **ContentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentTypes
    * const contentTypes = await prisma.contentType.findMany()
    * ```
    */
  get contentType(): Prisma.ContentTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentLanguage`: Exposes CRUD operations for the **ContentLanguage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentLanguages
    * const contentLanguages = await prisma.contentLanguage.findMany()
    * ```
    */
  get contentLanguage(): Prisma.ContentLanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appDevelopmentDetail`: Exposes CRUD operations for the **AppDevelopmentDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppDevelopmentDetails
    * const appDevelopmentDetails = await prisma.appDevelopmentDetail.findMany()
    * ```
    */
  get appDevelopmentDetail(): Prisma.AppDevelopmentDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appFeature`: Exposes CRUD operations for the **AppFeature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppFeatures
    * const appFeatures = await prisma.appFeature.findMany()
    * ```
    */
  get appFeature(): Prisma.AppFeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectStatusHistory`: Exposes CRUD operations for the **ProjectStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectStatusHistories
    * const projectStatusHistories = await prisma.projectStatusHistory.findMany()
    * ```
    */
  get projectStatusHistory(): Prisma.ProjectStatusHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolioProject`: Exposes CRUD operations for the **PortfolioProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioProjects
    * const portfolioProjects = await prisma.portfolioProject.findMany()
    * ```
    */
  get portfolioProject(): Prisma.PortfolioProjectDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ContactForm: 'ContactForm',
    Project: 'Project',
    WebDevelopmentDetail: 'WebDevelopmentDetail',
    WebDevelopmentFeature: 'WebDevelopmentFeature',
    SeoDetail: 'SeoDetail',
    SeoType: 'SeoType',
    DigitalMarketingDetail: 'DigitalMarketingDetail',
    DigitalMarketingService: 'DigitalMarketingService',
    SocialPlatform: 'SocialPlatform',
    ContentGenerationDetail: 'ContentGenerationDetail',
    ContentType: 'ContentType',
    ContentLanguage: 'ContentLanguage',
    AppDevelopmentDetail: 'AppDevelopmentDetail',
    AppFeature: 'AppFeature',
    Admin: 'Admin',
    ProjectStatusHistory: 'ProjectStatusHistory',
    PortfolioProject: 'PortfolioProject'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "contactForm" | "project" | "webDevelopmentDetail" | "webDevelopmentFeature" | "seoDetail" | "seoType" | "digitalMarketingDetail" | "digitalMarketingService" | "socialPlatform" | "contentGenerationDetail" | "contentType" | "contentLanguage" | "appDevelopmentDetail" | "appFeature" | "admin" | "projectStatusHistory" | "portfolioProject"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ContactForm: {
        payload: Prisma.$ContactFormPayload<ExtArgs>
        fields: Prisma.ContactFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          findFirst: {
            args: Prisma.ContactFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          findMany: {
            args: Prisma.ContactFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>[]
          }
          create: {
            args: Prisma.ContactFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          createMany: {
            args: Prisma.ContactFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          update: {
            args: Prisma.ContactFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          deleteMany: {
            args: Prisma.ContactFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFormPayload>
          }
          aggregate: {
            args: Prisma.ContactFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactForm>
          }
          groupBy: {
            args: Prisma.ContactFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactFormCountArgs<ExtArgs>
            result: $Utils.Optional<ContactFormCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      WebDevelopmentDetail: {
        payload: Prisma.$WebDevelopmentDetailPayload<ExtArgs>
        fields: Prisma.WebDevelopmentDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebDevelopmentDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebDevelopmentDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentDetailPayload>
          }
          findFirst: {
            args: Prisma.WebDevelopmentDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebDevelopmentDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentDetailPayload>
          }
          findMany: {
            args: Prisma.WebDevelopmentDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentDetailPayload>[]
          }
          create: {
            args: Prisma.WebDevelopmentDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentDetailPayload>
          }
          createMany: {
            args: Prisma.WebDevelopmentDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WebDevelopmentDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentDetailPayload>
          }
          update: {
            args: Prisma.WebDevelopmentDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentDetailPayload>
          }
          deleteMany: {
            args: Prisma.WebDevelopmentDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebDevelopmentDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebDevelopmentDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentDetailPayload>
          }
          aggregate: {
            args: Prisma.WebDevelopmentDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebDevelopmentDetail>
          }
          groupBy: {
            args: Prisma.WebDevelopmentDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebDevelopmentDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebDevelopmentDetailCountArgs<ExtArgs>
            result: $Utils.Optional<WebDevelopmentDetailCountAggregateOutputType> | number
          }
        }
      }
      WebDevelopmentFeature: {
        payload: Prisma.$WebDevelopmentFeaturePayload<ExtArgs>
        fields: Prisma.WebDevelopmentFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebDevelopmentFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebDevelopmentFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentFeaturePayload>
          }
          findFirst: {
            args: Prisma.WebDevelopmentFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebDevelopmentFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentFeaturePayload>
          }
          findMany: {
            args: Prisma.WebDevelopmentFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentFeaturePayload>[]
          }
          create: {
            args: Prisma.WebDevelopmentFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentFeaturePayload>
          }
          createMany: {
            args: Prisma.WebDevelopmentFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WebDevelopmentFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentFeaturePayload>
          }
          update: {
            args: Prisma.WebDevelopmentFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentFeaturePayload>
          }
          deleteMany: {
            args: Prisma.WebDevelopmentFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebDevelopmentFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebDevelopmentFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebDevelopmentFeaturePayload>
          }
          aggregate: {
            args: Prisma.WebDevelopmentFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebDevelopmentFeature>
          }
          groupBy: {
            args: Prisma.WebDevelopmentFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebDevelopmentFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebDevelopmentFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<WebDevelopmentFeatureCountAggregateOutputType> | number
          }
        }
      }
      SeoDetail: {
        payload: Prisma.$SeoDetailPayload<ExtArgs>
        fields: Prisma.SeoDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeoDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeoDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDetailPayload>
          }
          findFirst: {
            args: Prisma.SeoDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeoDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDetailPayload>
          }
          findMany: {
            args: Prisma.SeoDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDetailPayload>[]
          }
          create: {
            args: Prisma.SeoDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDetailPayload>
          }
          createMany: {
            args: Prisma.SeoDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeoDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDetailPayload>
          }
          update: {
            args: Prisma.SeoDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDetailPayload>
          }
          deleteMany: {
            args: Prisma.SeoDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeoDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeoDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDetailPayload>
          }
          aggregate: {
            args: Prisma.SeoDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeoDetail>
          }
          groupBy: {
            args: Prisma.SeoDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeoDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeoDetailCountArgs<ExtArgs>
            result: $Utils.Optional<SeoDetailCountAggregateOutputType> | number
          }
        }
      }
      SeoType: {
        payload: Prisma.$SeoTypePayload<ExtArgs>
        fields: Prisma.SeoTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeoTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeoTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoTypePayload>
          }
          findFirst: {
            args: Prisma.SeoTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeoTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoTypePayload>
          }
          findMany: {
            args: Prisma.SeoTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoTypePayload>[]
          }
          create: {
            args: Prisma.SeoTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoTypePayload>
          }
          createMany: {
            args: Prisma.SeoTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeoTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoTypePayload>
          }
          update: {
            args: Prisma.SeoTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoTypePayload>
          }
          deleteMany: {
            args: Prisma.SeoTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeoTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeoTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoTypePayload>
          }
          aggregate: {
            args: Prisma.SeoTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeoType>
          }
          groupBy: {
            args: Prisma.SeoTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeoTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeoTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SeoTypeCountAggregateOutputType> | number
          }
        }
      }
      DigitalMarketingDetail: {
        payload: Prisma.$DigitalMarketingDetailPayload<ExtArgs>
        fields: Prisma.DigitalMarketingDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DigitalMarketingDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DigitalMarketingDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingDetailPayload>
          }
          findFirst: {
            args: Prisma.DigitalMarketingDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DigitalMarketingDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingDetailPayload>
          }
          findMany: {
            args: Prisma.DigitalMarketingDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingDetailPayload>[]
          }
          create: {
            args: Prisma.DigitalMarketingDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingDetailPayload>
          }
          createMany: {
            args: Prisma.DigitalMarketingDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DigitalMarketingDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingDetailPayload>
          }
          update: {
            args: Prisma.DigitalMarketingDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingDetailPayload>
          }
          deleteMany: {
            args: Prisma.DigitalMarketingDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DigitalMarketingDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DigitalMarketingDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingDetailPayload>
          }
          aggregate: {
            args: Prisma.DigitalMarketingDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDigitalMarketingDetail>
          }
          groupBy: {
            args: Prisma.DigitalMarketingDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<DigitalMarketingDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.DigitalMarketingDetailCountArgs<ExtArgs>
            result: $Utils.Optional<DigitalMarketingDetailCountAggregateOutputType> | number
          }
        }
      }
      DigitalMarketingService: {
        payload: Prisma.$DigitalMarketingServicePayload<ExtArgs>
        fields: Prisma.DigitalMarketingServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DigitalMarketingServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DigitalMarketingServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingServicePayload>
          }
          findFirst: {
            args: Prisma.DigitalMarketingServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DigitalMarketingServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingServicePayload>
          }
          findMany: {
            args: Prisma.DigitalMarketingServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingServicePayload>[]
          }
          create: {
            args: Prisma.DigitalMarketingServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingServicePayload>
          }
          createMany: {
            args: Prisma.DigitalMarketingServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DigitalMarketingServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingServicePayload>
          }
          update: {
            args: Prisma.DigitalMarketingServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingServicePayload>
          }
          deleteMany: {
            args: Prisma.DigitalMarketingServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DigitalMarketingServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DigitalMarketingServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalMarketingServicePayload>
          }
          aggregate: {
            args: Prisma.DigitalMarketingServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDigitalMarketingService>
          }
          groupBy: {
            args: Prisma.DigitalMarketingServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DigitalMarketingServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DigitalMarketingServiceCountArgs<ExtArgs>
            result: $Utils.Optional<DigitalMarketingServiceCountAggregateOutputType> | number
          }
        }
      }
      SocialPlatform: {
        payload: Prisma.$SocialPlatformPayload<ExtArgs>
        fields: Prisma.SocialPlatformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialPlatformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPlatformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialPlatformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPlatformPayload>
          }
          findFirst: {
            args: Prisma.SocialPlatformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPlatformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialPlatformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPlatformPayload>
          }
          findMany: {
            args: Prisma.SocialPlatformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPlatformPayload>[]
          }
          create: {
            args: Prisma.SocialPlatformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPlatformPayload>
          }
          createMany: {
            args: Prisma.SocialPlatformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocialPlatformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPlatformPayload>
          }
          update: {
            args: Prisma.SocialPlatformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPlatformPayload>
          }
          deleteMany: {
            args: Prisma.SocialPlatformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialPlatformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialPlatformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialPlatformPayload>
          }
          aggregate: {
            args: Prisma.SocialPlatformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialPlatform>
          }
          groupBy: {
            args: Prisma.SocialPlatformGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialPlatformGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialPlatformCountArgs<ExtArgs>
            result: $Utils.Optional<SocialPlatformCountAggregateOutputType> | number
          }
        }
      }
      ContentGenerationDetail: {
        payload: Prisma.$ContentGenerationDetailPayload<ExtArgs>
        fields: Prisma.ContentGenerationDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentGenerationDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGenerationDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentGenerationDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGenerationDetailPayload>
          }
          findFirst: {
            args: Prisma.ContentGenerationDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGenerationDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentGenerationDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGenerationDetailPayload>
          }
          findMany: {
            args: Prisma.ContentGenerationDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGenerationDetailPayload>[]
          }
          create: {
            args: Prisma.ContentGenerationDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGenerationDetailPayload>
          }
          createMany: {
            args: Prisma.ContentGenerationDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContentGenerationDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGenerationDetailPayload>
          }
          update: {
            args: Prisma.ContentGenerationDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGenerationDetailPayload>
          }
          deleteMany: {
            args: Prisma.ContentGenerationDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentGenerationDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentGenerationDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentGenerationDetailPayload>
          }
          aggregate: {
            args: Prisma.ContentGenerationDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentGenerationDetail>
          }
          groupBy: {
            args: Prisma.ContentGenerationDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentGenerationDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentGenerationDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ContentGenerationDetailCountAggregateOutputType> | number
          }
        }
      }
      ContentType: {
        payload: Prisma.$ContentTypePayload<ExtArgs>
        fields: Prisma.ContentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          findFirst: {
            args: Prisma.ContentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          findMany: {
            args: Prisma.ContentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>[]
          }
          create: {
            args: Prisma.ContentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          createMany: {
            args: Prisma.ContentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          update: {
            args: Prisma.ContentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          deleteMany: {
            args: Prisma.ContentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentTypePayload>
          }
          aggregate: {
            args: Prisma.ContentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentType>
          }
          groupBy: {
            args: Prisma.ContentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ContentTypeCountAggregateOutputType> | number
          }
        }
      }
      ContentLanguage: {
        payload: Prisma.$ContentLanguagePayload<ExtArgs>
        fields: Prisma.ContentLanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentLanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentLanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLanguagePayload>
          }
          findFirst: {
            args: Prisma.ContentLanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentLanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLanguagePayload>
          }
          findMany: {
            args: Prisma.ContentLanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLanguagePayload>[]
          }
          create: {
            args: Prisma.ContentLanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLanguagePayload>
          }
          createMany: {
            args: Prisma.ContentLanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContentLanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLanguagePayload>
          }
          update: {
            args: Prisma.ContentLanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLanguagePayload>
          }
          deleteMany: {
            args: Prisma.ContentLanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentLanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentLanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentLanguagePayload>
          }
          aggregate: {
            args: Prisma.ContentLanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentLanguage>
          }
          groupBy: {
            args: Prisma.ContentLanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentLanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentLanguageCountArgs<ExtArgs>
            result: $Utils.Optional<ContentLanguageCountAggregateOutputType> | number
          }
        }
      }
      AppDevelopmentDetail: {
        payload: Prisma.$AppDevelopmentDetailPayload<ExtArgs>
        fields: Prisma.AppDevelopmentDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppDevelopmentDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDevelopmentDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppDevelopmentDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDevelopmentDetailPayload>
          }
          findFirst: {
            args: Prisma.AppDevelopmentDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDevelopmentDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppDevelopmentDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDevelopmentDetailPayload>
          }
          findMany: {
            args: Prisma.AppDevelopmentDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDevelopmentDetailPayload>[]
          }
          create: {
            args: Prisma.AppDevelopmentDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDevelopmentDetailPayload>
          }
          createMany: {
            args: Prisma.AppDevelopmentDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AppDevelopmentDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDevelopmentDetailPayload>
          }
          update: {
            args: Prisma.AppDevelopmentDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDevelopmentDetailPayload>
          }
          deleteMany: {
            args: Prisma.AppDevelopmentDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppDevelopmentDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppDevelopmentDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDevelopmentDetailPayload>
          }
          aggregate: {
            args: Prisma.AppDevelopmentDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppDevelopmentDetail>
          }
          groupBy: {
            args: Prisma.AppDevelopmentDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppDevelopmentDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppDevelopmentDetailCountArgs<ExtArgs>
            result: $Utils.Optional<AppDevelopmentDetailCountAggregateOutputType> | number
          }
        }
      }
      AppFeature: {
        payload: Prisma.$AppFeaturePayload<ExtArgs>
        fields: Prisma.AppFeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppFeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppFeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFeaturePayload>
          }
          findFirst: {
            args: Prisma.AppFeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppFeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFeaturePayload>
          }
          findMany: {
            args: Prisma.AppFeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFeaturePayload>[]
          }
          create: {
            args: Prisma.AppFeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFeaturePayload>
          }
          createMany: {
            args: Prisma.AppFeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AppFeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFeaturePayload>
          }
          update: {
            args: Prisma.AppFeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFeaturePayload>
          }
          deleteMany: {
            args: Prisma.AppFeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppFeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppFeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFeaturePayload>
          }
          aggregate: {
            args: Prisma.AppFeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppFeature>
          }
          groupBy: {
            args: Prisma.AppFeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppFeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppFeatureCountArgs<ExtArgs>
            result: $Utils.Optional<AppFeatureCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      ProjectStatusHistory: {
        payload: Prisma.$ProjectStatusHistoryPayload<ExtArgs>
        fields: Prisma.ProjectStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.ProjectStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.ProjectStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.ProjectStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.ProjectStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusHistoryPayload>
          }
          update: {
            args: Prisma.ProjectStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ProjectStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.ProjectStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectStatusHistory>
          }
          groupBy: {
            args: Prisma.ProjectStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      PortfolioProject: {
        payload: Prisma.$PortfolioProjectPayload<ExtArgs>
        fields: Prisma.PortfolioProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          findFirst: {
            args: Prisma.PortfolioProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          findMany: {
            args: Prisma.PortfolioProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>[]
          }
          create: {
            args: Prisma.PortfolioProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          createMany: {
            args: Prisma.PortfolioProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PortfolioProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          update: {
            args: Prisma.PortfolioProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PortfolioProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          aggregate: {
            args: Prisma.PortfolioProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioProject>
          }
          groupBy: {
            args: Prisma.PortfolioProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioProjectCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioProjectCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    contactForm?: ContactFormOmit
    project?: ProjectOmit
    webDevelopmentDetail?: WebDevelopmentDetailOmit
    webDevelopmentFeature?: WebDevelopmentFeatureOmit
    seoDetail?: SeoDetailOmit
    seoType?: SeoTypeOmit
    digitalMarketingDetail?: DigitalMarketingDetailOmit
    digitalMarketingService?: DigitalMarketingServiceOmit
    socialPlatform?: SocialPlatformOmit
    contentGenerationDetail?: ContentGenerationDetailOmit
    contentType?: ContentTypeOmit
    contentLanguage?: ContentLanguageOmit
    appDevelopmentDetail?: AppDevelopmentDetailOmit
    appFeature?: AppFeatureOmit
    admin?: AdminOmit
    projectStatusHistory?: ProjectStatusHistoryOmit
    portfolioProject?: PortfolioProjectOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    projects: number
    contactForms: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    contactForms?: boolean | UserCountOutputTypeCountContactFormsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactFormWhereInput
  }


  /**
   * Count Type WebDevelopmentDetailCountOutputType
   */

  export type WebDevelopmentDetailCountOutputType = {
    webFeatures: number
  }

  export type WebDevelopmentDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webFeatures?: boolean | WebDevelopmentDetailCountOutputTypeCountWebFeaturesArgs
  }

  // Custom InputTypes
  /**
   * WebDevelopmentDetailCountOutputType without action
   */
  export type WebDevelopmentDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetailCountOutputType
     */
    select?: WebDevelopmentDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebDevelopmentDetailCountOutputType without action
   */
  export type WebDevelopmentDetailCountOutputTypeCountWebFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebDevelopmentFeatureWhereInput
  }


  /**
   * Count Type SeoDetailCountOutputType
   */

  export type SeoDetailCountOutputType = {
    seoTypes: number
  }

  export type SeoDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seoTypes?: boolean | SeoDetailCountOutputTypeCountSeoTypesArgs
  }

  // Custom InputTypes
  /**
   * SeoDetailCountOutputType without action
   */
  export type SeoDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetailCountOutputType
     */
    select?: SeoDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeoDetailCountOutputType without action
   */
  export type SeoDetailCountOutputTypeCountSeoTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoTypeWhereInput
  }


  /**
   * Count Type DigitalMarketingDetailCountOutputType
   */

  export type DigitalMarketingDetailCountOutputType = {
    marketingServices: number
    socialPlatforms: number
  }

  export type DigitalMarketingDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marketingServices?: boolean | DigitalMarketingDetailCountOutputTypeCountMarketingServicesArgs
    socialPlatforms?: boolean | DigitalMarketingDetailCountOutputTypeCountSocialPlatformsArgs
  }

  // Custom InputTypes
  /**
   * DigitalMarketingDetailCountOutputType without action
   */
  export type DigitalMarketingDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetailCountOutputType
     */
    select?: DigitalMarketingDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DigitalMarketingDetailCountOutputType without action
   */
  export type DigitalMarketingDetailCountOutputTypeCountMarketingServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DigitalMarketingServiceWhereInput
  }

  /**
   * DigitalMarketingDetailCountOutputType without action
   */
  export type DigitalMarketingDetailCountOutputTypeCountSocialPlatformsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialPlatformWhereInput
  }


  /**
   * Count Type ContentGenerationDetailCountOutputType
   */

  export type ContentGenerationDetailCountOutputType = {
    contentTypes: number
    contentLanguages: number
  }

  export type ContentGenerationDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentTypes?: boolean | ContentGenerationDetailCountOutputTypeCountContentTypesArgs
    contentLanguages?: boolean | ContentGenerationDetailCountOutputTypeCountContentLanguagesArgs
  }

  // Custom InputTypes
  /**
   * ContentGenerationDetailCountOutputType without action
   */
  export type ContentGenerationDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetailCountOutputType
     */
    select?: ContentGenerationDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentGenerationDetailCountOutputType without action
   */
  export type ContentGenerationDetailCountOutputTypeCountContentTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTypeWhereInput
  }

  /**
   * ContentGenerationDetailCountOutputType without action
   */
  export type ContentGenerationDetailCountOutputTypeCountContentLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentLanguageWhereInput
  }


  /**
   * Count Type AppDevelopmentDetailCountOutputType
   */

  export type AppDevelopmentDetailCountOutputType = {
    appFeatures: number
  }

  export type AppDevelopmentDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appFeatures?: boolean | AppDevelopmentDetailCountOutputTypeCountAppFeaturesArgs
  }

  // Custom InputTypes
  /**
   * AppDevelopmentDetailCountOutputType without action
   */
  export type AppDevelopmentDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetailCountOutputType
     */
    select?: AppDevelopmentDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppDevelopmentDetailCountOutputType without action
   */
  export type AppDevelopmentDetailCountOutputTypeCountAppFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppFeatureWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    full_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    full_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    full_name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    full_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    full_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    full_name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    full_name: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    full_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | User$projectsArgs<ExtArgs>
    contactForms?: boolean | User$contactFormsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    full_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "full_name" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | User$projectsArgs<ExtArgs>
    contactForms?: boolean | User$contactFormsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      contactForms: Prisma.$ContactFormPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      full_name: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contactForms<T extends User$contactFormsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactFormsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.contactForms
   */
  export type User$contactFormsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    where?: ContactFormWhereInput
    orderBy?: ContactFormOrderByWithRelationInput | ContactFormOrderByWithRelationInput[]
    cursor?: ContactFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactFormScalarFieldEnum | ContactFormScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ContactForm
   */

  export type AggregateContactForm = {
    _count: ContactFormCountAggregateOutputType | null
    _avg: ContactFormAvgAggregateOutputType | null
    _sum: ContactFormSumAggregateOutputType | null
    _min: ContactFormMinAggregateOutputType | null
    _max: ContactFormMaxAggregateOutputType | null
  }

  export type ContactFormAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ContactFormSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ContactFormMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type ContactFormMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type ContactFormCountAggregateOutputType = {
    id: number
    name: number
    email: number
    subject: number
    message: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ContactFormAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ContactFormSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ContactFormMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ContactFormMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ContactFormCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ContactFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactForm to aggregate.
     */
    where?: ContactFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactForms to fetch.
     */
    orderBy?: ContactFormOrderByWithRelationInput | ContactFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactForms
    **/
    _count?: true | ContactFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactFormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactFormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactFormMaxAggregateInputType
  }

  export type GetContactFormAggregateType<T extends ContactFormAggregateArgs> = {
        [P in keyof T & keyof AggregateContactForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactForm[P]>
      : GetScalarType<T[P], AggregateContactForm[P]>
  }




  export type ContactFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactFormWhereInput
    orderBy?: ContactFormOrderByWithAggregationInput | ContactFormOrderByWithAggregationInput[]
    by: ContactFormScalarFieldEnum[] | ContactFormScalarFieldEnum
    having?: ContactFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactFormCountAggregateInputType | true
    _avg?: ContactFormAvgAggregateInputType
    _sum?: ContactFormSumAggregateInputType
    _min?: ContactFormMinAggregateInputType
    _max?: ContactFormMaxAggregateInputType
  }

  export type ContactFormGroupByOutputType = {
    id: number
    name: string
    email: string
    subject: string
    message: string
    createdAt: Date
    updatedAt: Date
    userId: number | null
    _count: ContactFormCountAggregateOutputType | null
    _avg: ContactFormAvgAggregateOutputType | null
    _sum: ContactFormSumAggregateOutputType | null
    _min: ContactFormMinAggregateOutputType | null
    _max: ContactFormMaxAggregateOutputType | null
  }

  type GetContactFormGroupByPayload<T extends ContactFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactFormGroupByOutputType[P]>
            : GetScalarType<T[P], ContactFormGroupByOutputType[P]>
        }
      >
    >


  export type ContactFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | ContactForm$userArgs<ExtArgs>
  }, ExtArgs["result"]["contactForm"]>



  export type ContactFormSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type ContactFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "subject" | "message" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["contactForm"]>
  export type ContactFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ContactForm$userArgs<ExtArgs>
  }

  export type $ContactFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactForm"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      subject: string
      message: string
      createdAt: Date
      updatedAt: Date
      userId: number | null
    }, ExtArgs["result"]["contactForm"]>
    composites: {}
  }

  type ContactFormGetPayload<S extends boolean | null | undefined | ContactFormDefaultArgs> = $Result.GetResult<Prisma.$ContactFormPayload, S>

  type ContactFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactFormCountAggregateInputType | true
    }

  export interface ContactFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactForm'], meta: { name: 'ContactForm' } }
    /**
     * Find zero or one ContactForm that matches the filter.
     * @param {ContactFormFindUniqueArgs} args - Arguments to find a ContactForm
     * @example
     * // Get one ContactForm
     * const contactForm = await prisma.contactForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFormFindUniqueArgs>(args: SelectSubset<T, ContactFormFindUniqueArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFormFindUniqueOrThrowArgs} args - Arguments to find a ContactForm
     * @example
     * // Get one ContactForm
     * const contactForm = await prisma.contactForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFormFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormFindFirstArgs} args - Arguments to find a ContactForm
     * @example
     * // Get one ContactForm
     * const contactForm = await prisma.contactForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFormFindFirstArgs>(args?: SelectSubset<T, ContactFormFindFirstArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormFindFirstOrThrowArgs} args - Arguments to find a ContactForm
     * @example
     * // Get one ContactForm
     * const contactForm = await prisma.contactForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFormFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactForms
     * const contactForms = await prisma.contactForm.findMany()
     * 
     * // Get first 10 ContactForms
     * const contactForms = await prisma.contactForm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactFormWithIdOnly = await prisma.contactForm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFormFindManyArgs>(args?: SelectSubset<T, ContactFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactForm.
     * @param {ContactFormCreateArgs} args - Arguments to create a ContactForm.
     * @example
     * // Create one ContactForm
     * const ContactForm = await prisma.contactForm.create({
     *   data: {
     *     // ... data to create a ContactForm
     *   }
     * })
     * 
     */
    create<T extends ContactFormCreateArgs>(args: SelectSubset<T, ContactFormCreateArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactForms.
     * @param {ContactFormCreateManyArgs} args - Arguments to create many ContactForms.
     * @example
     * // Create many ContactForms
     * const contactForm = await prisma.contactForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactFormCreateManyArgs>(args?: SelectSubset<T, ContactFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactForm.
     * @param {ContactFormDeleteArgs} args - Arguments to delete one ContactForm.
     * @example
     * // Delete one ContactForm
     * const ContactForm = await prisma.contactForm.delete({
     *   where: {
     *     // ... filter to delete one ContactForm
     *   }
     * })
     * 
     */
    delete<T extends ContactFormDeleteArgs>(args: SelectSubset<T, ContactFormDeleteArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactForm.
     * @param {ContactFormUpdateArgs} args - Arguments to update one ContactForm.
     * @example
     * // Update one ContactForm
     * const contactForm = await prisma.contactForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactFormUpdateArgs>(args: SelectSubset<T, ContactFormUpdateArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactForms.
     * @param {ContactFormDeleteManyArgs} args - Arguments to filter ContactForms to delete.
     * @example
     * // Delete a few ContactForms
     * const { count } = await prisma.contactForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactFormDeleteManyArgs>(args?: SelectSubset<T, ContactFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactForms
     * const contactForm = await prisma.contactForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactFormUpdateManyArgs>(args: SelectSubset<T, ContactFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactForm.
     * @param {ContactFormUpsertArgs} args - Arguments to update or create a ContactForm.
     * @example
     * // Update or create a ContactForm
     * const contactForm = await prisma.contactForm.upsert({
     *   create: {
     *     // ... data to create a ContactForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactForm we want to update
     *   }
     * })
     */
    upsert<T extends ContactFormUpsertArgs>(args: SelectSubset<T, ContactFormUpsertArgs<ExtArgs>>): Prisma__ContactFormClient<$Result.GetResult<Prisma.$ContactFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormCountArgs} args - Arguments to filter ContactForms to count.
     * @example
     * // Count the number of ContactForms
     * const count = await prisma.contactForm.count({
     *   where: {
     *     // ... the filter for the ContactForms we want to count
     *   }
     * })
    **/
    count<T extends ContactFormCountArgs>(
      args?: Subset<T, ContactFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactFormAggregateArgs>(args: Subset<T, ContactFormAggregateArgs>): Prisma.PrismaPromise<GetContactFormAggregateType<T>>

    /**
     * Group by ContactForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactFormGroupByArgs['orderBy'] }
        : { orderBy?: ContactFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactForm model
   */
  readonly fields: ContactFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ContactForm$userArgs<ExtArgs> = {}>(args?: Subset<T, ContactForm$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactForm model
   */
  interface ContactFormFieldRefs {
    readonly id: FieldRef<"ContactForm", 'Int'>
    readonly name: FieldRef<"ContactForm", 'String'>
    readonly email: FieldRef<"ContactForm", 'String'>
    readonly subject: FieldRef<"ContactForm", 'String'>
    readonly message: FieldRef<"ContactForm", 'String'>
    readonly createdAt: FieldRef<"ContactForm", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactForm", 'DateTime'>
    readonly userId: FieldRef<"ContactForm", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContactForm findUnique
   */
  export type ContactFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    /**
     * Filter, which ContactForm to fetch.
     */
    where: ContactFormWhereUniqueInput
  }

  /**
   * ContactForm findUniqueOrThrow
   */
  export type ContactFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    /**
     * Filter, which ContactForm to fetch.
     */
    where: ContactFormWhereUniqueInput
  }

  /**
   * ContactForm findFirst
   */
  export type ContactFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    /**
     * Filter, which ContactForm to fetch.
     */
    where?: ContactFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactForms to fetch.
     */
    orderBy?: ContactFormOrderByWithRelationInput | ContactFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactForms.
     */
    cursor?: ContactFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactForms.
     */
    distinct?: ContactFormScalarFieldEnum | ContactFormScalarFieldEnum[]
  }

  /**
   * ContactForm findFirstOrThrow
   */
  export type ContactFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    /**
     * Filter, which ContactForm to fetch.
     */
    where?: ContactFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactForms to fetch.
     */
    orderBy?: ContactFormOrderByWithRelationInput | ContactFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactForms.
     */
    cursor?: ContactFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactForms.
     */
    distinct?: ContactFormScalarFieldEnum | ContactFormScalarFieldEnum[]
  }

  /**
   * ContactForm findMany
   */
  export type ContactFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    /**
     * Filter, which ContactForms to fetch.
     */
    where?: ContactFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactForms to fetch.
     */
    orderBy?: ContactFormOrderByWithRelationInput | ContactFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactForms.
     */
    cursor?: ContactFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactForms.
     */
    skip?: number
    distinct?: ContactFormScalarFieldEnum | ContactFormScalarFieldEnum[]
  }

  /**
   * ContactForm create
   */
  export type ContactFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactForm.
     */
    data: XOR<ContactFormCreateInput, ContactFormUncheckedCreateInput>
  }

  /**
   * ContactForm createMany
   */
  export type ContactFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactForms.
     */
    data: ContactFormCreateManyInput | ContactFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactForm update
   */
  export type ContactFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactForm.
     */
    data: XOR<ContactFormUpdateInput, ContactFormUncheckedUpdateInput>
    /**
     * Choose, which ContactForm to update.
     */
    where: ContactFormWhereUniqueInput
  }

  /**
   * ContactForm updateMany
   */
  export type ContactFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactForms.
     */
    data: XOR<ContactFormUpdateManyMutationInput, ContactFormUncheckedUpdateManyInput>
    /**
     * Filter which ContactForms to update
     */
    where?: ContactFormWhereInput
    /**
     * Limit how many ContactForms to update.
     */
    limit?: number
  }

  /**
   * ContactForm upsert
   */
  export type ContactFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactForm to update in case it exists.
     */
    where: ContactFormWhereUniqueInput
    /**
     * In case the ContactForm found by the `where` argument doesn't exist, create a new ContactForm with this data.
     */
    create: XOR<ContactFormCreateInput, ContactFormUncheckedCreateInput>
    /**
     * In case the ContactForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactFormUpdateInput, ContactFormUncheckedUpdateInput>
  }

  /**
   * ContactForm delete
   */
  export type ContactFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
    /**
     * Filter which ContactForm to delete.
     */
    where: ContactFormWhereUniqueInput
  }

  /**
   * ContactForm deleteMany
   */
  export type ContactFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactForms to delete
     */
    where?: ContactFormWhereInput
    /**
     * Limit how many ContactForms to delete.
     */
    limit?: number
  }

  /**
   * ContactForm.user
   */
  export type ContactForm$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ContactForm without action
   */
  export type ContactFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactForm
     */
    select?: ContactFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactForm
     */
    omit?: ContactFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFormInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
    price: number | null
    userId: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
    price: number | null
    userId: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    projectName: string | null
    projectTitle: string | null
    category: string | null
    price: number | null
    deadline: string | null
    details: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    projectName: string | null
    projectTitle: string | null
    category: string | null
    price: number | null
    deadline: string | null
    details: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    projectName: number
    projectTitle: number
    category: number
    price: number
    deadline: number
    details: number
    status: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
    price?: true
    userId?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
    price?: true
    userId?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    projectName?: true
    projectTitle?: true
    category?: true
    price?: true
    deadline?: true
    details?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    projectName?: true
    projectTitle?: true
    category?: true
    price?: true
    deadline?: true
    details?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    projectName?: true
    projectTitle?: true
    category?: true
    price?: true
    deadline?: true
    details?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price: number
    deadline: string | null
    details: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    userId: number | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    projectName?: boolean
    projectTitle?: boolean
    category?: boolean
    price?: boolean
    deadline?: boolean
    details?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | Project$userArgs<ExtArgs>
    webDevelopmentDetails?: boolean | Project$webDevelopmentDetailsArgs<ExtArgs>
    seoDetails?: boolean | Project$seoDetailsArgs<ExtArgs>
    digitalMarketingDetails?: boolean | Project$digitalMarketingDetailsArgs<ExtArgs>
    contentGenerationDetails?: boolean | Project$contentGenerationDetailsArgs<ExtArgs>
    appDevelopmentDetails?: boolean | Project$appDevelopmentDetailsArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>



  export type ProjectSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    projectName?: boolean
    projectTitle?: boolean
    category?: boolean
    price?: boolean
    deadline?: boolean
    details?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "projectName" | "projectTitle" | "category" | "price" | "deadline" | "details" | "status" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Project$userArgs<ExtArgs>
    webDevelopmentDetails?: boolean | Project$webDevelopmentDetailsArgs<ExtArgs>
    seoDetails?: boolean | Project$seoDetailsArgs<ExtArgs>
    digitalMarketingDetails?: boolean | Project$digitalMarketingDetailsArgs<ExtArgs>
    contentGenerationDetails?: boolean | Project$contentGenerationDetailsArgs<ExtArgs>
    appDevelopmentDetails?: boolean | Project$appDevelopmentDetailsArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      webDevelopmentDetails: Prisma.$WebDevelopmentDetailPayload<ExtArgs> | null
      seoDetails: Prisma.$SeoDetailPayload<ExtArgs> | null
      digitalMarketingDetails: Prisma.$DigitalMarketingDetailPayload<ExtArgs> | null
      contentGenerationDetails: Prisma.$ContentGenerationDetailPayload<ExtArgs> | null
      appDevelopmentDetails: Prisma.$AppDevelopmentDetailPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password: string
      projectName: string
      projectTitle: string
      category: string
      price: number
      deadline: string | null
      details: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      userId: number | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Project$userArgs<ExtArgs> = {}>(args?: Subset<T, Project$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    webDevelopmentDetails<T extends Project$webDevelopmentDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Project$webDevelopmentDetailsArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    seoDetails<T extends Project$seoDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Project$seoDetailsArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    digitalMarketingDetails<T extends Project$digitalMarketingDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Project$digitalMarketingDetailsArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contentGenerationDetails<T extends Project$contentGenerationDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Project$contentGenerationDetailsArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    appDevelopmentDetails<T extends Project$appDevelopmentDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Project$appDevelopmentDetailsArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly username: FieldRef<"Project", 'String'>
    readonly email: FieldRef<"Project", 'String'>
    readonly password: FieldRef<"Project", 'String'>
    readonly projectName: FieldRef<"Project", 'String'>
    readonly projectTitle: FieldRef<"Project", 'String'>
    readonly category: FieldRef<"Project", 'String'>
    readonly price: FieldRef<"Project", 'Float'>
    readonly deadline: FieldRef<"Project", 'String'>
    readonly details: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly userId: FieldRef<"Project", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.user
   */
  export type Project$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.webDevelopmentDetails
   */
  export type Project$webDevelopmentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    where?: WebDevelopmentDetailWhereInput
  }

  /**
   * Project.seoDetails
   */
  export type Project$seoDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    where?: SeoDetailWhereInput
  }

  /**
   * Project.digitalMarketingDetails
   */
  export type Project$digitalMarketingDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    where?: DigitalMarketingDetailWhereInput
  }

  /**
   * Project.contentGenerationDetails
   */
  export type Project$contentGenerationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    where?: ContentGenerationDetailWhereInput
  }

  /**
   * Project.appDevelopmentDetails
   */
  export type Project$appDevelopmentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    where?: AppDevelopmentDetailWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model WebDevelopmentDetail
   */

  export type AggregateWebDevelopmentDetail = {
    _count: WebDevelopmentDetailCountAggregateOutputType | null
    _avg: WebDevelopmentDetailAvgAggregateOutputType | null
    _sum: WebDevelopmentDetailSumAggregateOutputType | null
    _min: WebDevelopmentDetailMinAggregateOutputType | null
    _max: WebDevelopmentDetailMaxAggregateOutputType | null
  }

  export type WebDevelopmentDetailAvgAggregateOutputType = {
    id: number | null
    webPages: number | null
    projectId: number | null
  }

  export type WebDevelopmentDetailSumAggregateOutputType = {
    id: number | null
    webPages: number | null
    projectId: number | null
  }

  export type WebDevelopmentDetailMinAggregateOutputType = {
    id: number | null
    tech: string | null
    webPages: number | null
    projectId: number | null
  }

  export type WebDevelopmentDetailMaxAggregateOutputType = {
    id: number | null
    tech: string | null
    webPages: number | null
    projectId: number | null
  }

  export type WebDevelopmentDetailCountAggregateOutputType = {
    id: number
    tech: number
    webPages: number
    projectId: number
    _all: number
  }


  export type WebDevelopmentDetailAvgAggregateInputType = {
    id?: true
    webPages?: true
    projectId?: true
  }

  export type WebDevelopmentDetailSumAggregateInputType = {
    id?: true
    webPages?: true
    projectId?: true
  }

  export type WebDevelopmentDetailMinAggregateInputType = {
    id?: true
    tech?: true
    webPages?: true
    projectId?: true
  }

  export type WebDevelopmentDetailMaxAggregateInputType = {
    id?: true
    tech?: true
    webPages?: true
    projectId?: true
  }

  export type WebDevelopmentDetailCountAggregateInputType = {
    id?: true
    tech?: true
    webPages?: true
    projectId?: true
    _all?: true
  }

  export type WebDevelopmentDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebDevelopmentDetail to aggregate.
     */
    where?: WebDevelopmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebDevelopmentDetails to fetch.
     */
    orderBy?: WebDevelopmentDetailOrderByWithRelationInput | WebDevelopmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebDevelopmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebDevelopmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebDevelopmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebDevelopmentDetails
    **/
    _count?: true | WebDevelopmentDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebDevelopmentDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebDevelopmentDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebDevelopmentDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebDevelopmentDetailMaxAggregateInputType
  }

  export type GetWebDevelopmentDetailAggregateType<T extends WebDevelopmentDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateWebDevelopmentDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebDevelopmentDetail[P]>
      : GetScalarType<T[P], AggregateWebDevelopmentDetail[P]>
  }




  export type WebDevelopmentDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebDevelopmentDetailWhereInput
    orderBy?: WebDevelopmentDetailOrderByWithAggregationInput | WebDevelopmentDetailOrderByWithAggregationInput[]
    by: WebDevelopmentDetailScalarFieldEnum[] | WebDevelopmentDetailScalarFieldEnum
    having?: WebDevelopmentDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebDevelopmentDetailCountAggregateInputType | true
    _avg?: WebDevelopmentDetailAvgAggregateInputType
    _sum?: WebDevelopmentDetailSumAggregateInputType
    _min?: WebDevelopmentDetailMinAggregateInputType
    _max?: WebDevelopmentDetailMaxAggregateInputType
  }

  export type WebDevelopmentDetailGroupByOutputType = {
    id: number
    tech: string
    webPages: number | null
    projectId: number
    _count: WebDevelopmentDetailCountAggregateOutputType | null
    _avg: WebDevelopmentDetailAvgAggregateOutputType | null
    _sum: WebDevelopmentDetailSumAggregateOutputType | null
    _min: WebDevelopmentDetailMinAggregateOutputType | null
    _max: WebDevelopmentDetailMaxAggregateOutputType | null
  }

  type GetWebDevelopmentDetailGroupByPayload<T extends WebDevelopmentDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebDevelopmentDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebDevelopmentDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebDevelopmentDetailGroupByOutputType[P]>
            : GetScalarType<T[P], WebDevelopmentDetailGroupByOutputType[P]>
        }
      >
    >


  export type WebDevelopmentDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tech?: boolean
    webPages?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    webFeatures?: boolean | WebDevelopmentDetail$webFeaturesArgs<ExtArgs>
    _count?: boolean | WebDevelopmentDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webDevelopmentDetail"]>



  export type WebDevelopmentDetailSelectScalar = {
    id?: boolean
    tech?: boolean
    webPages?: boolean
    projectId?: boolean
  }

  export type WebDevelopmentDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tech" | "webPages" | "projectId", ExtArgs["result"]["webDevelopmentDetail"]>
  export type WebDevelopmentDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    webFeatures?: boolean | WebDevelopmentDetail$webFeaturesArgs<ExtArgs>
    _count?: boolean | WebDevelopmentDetailCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WebDevelopmentDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebDevelopmentDetail"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      webFeatures: Prisma.$WebDevelopmentFeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tech: string
      webPages: number | null
      projectId: number
    }, ExtArgs["result"]["webDevelopmentDetail"]>
    composites: {}
  }

  type WebDevelopmentDetailGetPayload<S extends boolean | null | undefined | WebDevelopmentDetailDefaultArgs> = $Result.GetResult<Prisma.$WebDevelopmentDetailPayload, S>

  type WebDevelopmentDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebDevelopmentDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebDevelopmentDetailCountAggregateInputType | true
    }

  export interface WebDevelopmentDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebDevelopmentDetail'], meta: { name: 'WebDevelopmentDetail' } }
    /**
     * Find zero or one WebDevelopmentDetail that matches the filter.
     * @param {WebDevelopmentDetailFindUniqueArgs} args - Arguments to find a WebDevelopmentDetail
     * @example
     * // Get one WebDevelopmentDetail
     * const webDevelopmentDetail = await prisma.webDevelopmentDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebDevelopmentDetailFindUniqueArgs>(args: SelectSubset<T, WebDevelopmentDetailFindUniqueArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebDevelopmentDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebDevelopmentDetailFindUniqueOrThrowArgs} args - Arguments to find a WebDevelopmentDetail
     * @example
     * // Get one WebDevelopmentDetail
     * const webDevelopmentDetail = await prisma.webDevelopmentDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebDevelopmentDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, WebDevelopmentDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebDevelopmentDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentDetailFindFirstArgs} args - Arguments to find a WebDevelopmentDetail
     * @example
     * // Get one WebDevelopmentDetail
     * const webDevelopmentDetail = await prisma.webDevelopmentDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebDevelopmentDetailFindFirstArgs>(args?: SelectSubset<T, WebDevelopmentDetailFindFirstArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebDevelopmentDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentDetailFindFirstOrThrowArgs} args - Arguments to find a WebDevelopmentDetail
     * @example
     * // Get one WebDevelopmentDetail
     * const webDevelopmentDetail = await prisma.webDevelopmentDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebDevelopmentDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, WebDevelopmentDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebDevelopmentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebDevelopmentDetails
     * const webDevelopmentDetails = await prisma.webDevelopmentDetail.findMany()
     * 
     * // Get first 10 WebDevelopmentDetails
     * const webDevelopmentDetails = await prisma.webDevelopmentDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webDevelopmentDetailWithIdOnly = await prisma.webDevelopmentDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebDevelopmentDetailFindManyArgs>(args?: SelectSubset<T, WebDevelopmentDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebDevelopmentDetail.
     * @param {WebDevelopmentDetailCreateArgs} args - Arguments to create a WebDevelopmentDetail.
     * @example
     * // Create one WebDevelopmentDetail
     * const WebDevelopmentDetail = await prisma.webDevelopmentDetail.create({
     *   data: {
     *     // ... data to create a WebDevelopmentDetail
     *   }
     * })
     * 
     */
    create<T extends WebDevelopmentDetailCreateArgs>(args: SelectSubset<T, WebDevelopmentDetailCreateArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebDevelopmentDetails.
     * @param {WebDevelopmentDetailCreateManyArgs} args - Arguments to create many WebDevelopmentDetails.
     * @example
     * // Create many WebDevelopmentDetails
     * const webDevelopmentDetail = await prisma.webDevelopmentDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebDevelopmentDetailCreateManyArgs>(args?: SelectSubset<T, WebDevelopmentDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WebDevelopmentDetail.
     * @param {WebDevelopmentDetailDeleteArgs} args - Arguments to delete one WebDevelopmentDetail.
     * @example
     * // Delete one WebDevelopmentDetail
     * const WebDevelopmentDetail = await prisma.webDevelopmentDetail.delete({
     *   where: {
     *     // ... filter to delete one WebDevelopmentDetail
     *   }
     * })
     * 
     */
    delete<T extends WebDevelopmentDetailDeleteArgs>(args: SelectSubset<T, WebDevelopmentDetailDeleteArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebDevelopmentDetail.
     * @param {WebDevelopmentDetailUpdateArgs} args - Arguments to update one WebDevelopmentDetail.
     * @example
     * // Update one WebDevelopmentDetail
     * const webDevelopmentDetail = await prisma.webDevelopmentDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebDevelopmentDetailUpdateArgs>(args: SelectSubset<T, WebDevelopmentDetailUpdateArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebDevelopmentDetails.
     * @param {WebDevelopmentDetailDeleteManyArgs} args - Arguments to filter WebDevelopmentDetails to delete.
     * @example
     * // Delete a few WebDevelopmentDetails
     * const { count } = await prisma.webDevelopmentDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebDevelopmentDetailDeleteManyArgs>(args?: SelectSubset<T, WebDevelopmentDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebDevelopmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebDevelopmentDetails
     * const webDevelopmentDetail = await prisma.webDevelopmentDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebDevelopmentDetailUpdateManyArgs>(args: SelectSubset<T, WebDevelopmentDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebDevelopmentDetail.
     * @param {WebDevelopmentDetailUpsertArgs} args - Arguments to update or create a WebDevelopmentDetail.
     * @example
     * // Update or create a WebDevelopmentDetail
     * const webDevelopmentDetail = await prisma.webDevelopmentDetail.upsert({
     *   create: {
     *     // ... data to create a WebDevelopmentDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebDevelopmentDetail we want to update
     *   }
     * })
     */
    upsert<T extends WebDevelopmentDetailUpsertArgs>(args: SelectSubset<T, WebDevelopmentDetailUpsertArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebDevelopmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentDetailCountArgs} args - Arguments to filter WebDevelopmentDetails to count.
     * @example
     * // Count the number of WebDevelopmentDetails
     * const count = await prisma.webDevelopmentDetail.count({
     *   where: {
     *     // ... the filter for the WebDevelopmentDetails we want to count
     *   }
     * })
    **/
    count<T extends WebDevelopmentDetailCountArgs>(
      args?: Subset<T, WebDevelopmentDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebDevelopmentDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebDevelopmentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebDevelopmentDetailAggregateArgs>(args: Subset<T, WebDevelopmentDetailAggregateArgs>): Prisma.PrismaPromise<GetWebDevelopmentDetailAggregateType<T>>

    /**
     * Group by WebDevelopmentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebDevelopmentDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebDevelopmentDetailGroupByArgs['orderBy'] }
        : { orderBy?: WebDevelopmentDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebDevelopmentDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebDevelopmentDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebDevelopmentDetail model
   */
  readonly fields: WebDevelopmentDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebDevelopmentDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebDevelopmentDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    webFeatures<T extends WebDevelopmentDetail$webFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, WebDevelopmentDetail$webFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebDevelopmentDetail model
   */
  interface WebDevelopmentDetailFieldRefs {
    readonly id: FieldRef<"WebDevelopmentDetail", 'Int'>
    readonly tech: FieldRef<"WebDevelopmentDetail", 'String'>
    readonly webPages: FieldRef<"WebDevelopmentDetail", 'Int'>
    readonly projectId: FieldRef<"WebDevelopmentDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WebDevelopmentDetail findUnique
   */
  export type WebDevelopmentDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentDetail to fetch.
     */
    where: WebDevelopmentDetailWhereUniqueInput
  }

  /**
   * WebDevelopmentDetail findUniqueOrThrow
   */
  export type WebDevelopmentDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentDetail to fetch.
     */
    where: WebDevelopmentDetailWhereUniqueInput
  }

  /**
   * WebDevelopmentDetail findFirst
   */
  export type WebDevelopmentDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentDetail to fetch.
     */
    where?: WebDevelopmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebDevelopmentDetails to fetch.
     */
    orderBy?: WebDevelopmentDetailOrderByWithRelationInput | WebDevelopmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebDevelopmentDetails.
     */
    cursor?: WebDevelopmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebDevelopmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebDevelopmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebDevelopmentDetails.
     */
    distinct?: WebDevelopmentDetailScalarFieldEnum | WebDevelopmentDetailScalarFieldEnum[]
  }

  /**
   * WebDevelopmentDetail findFirstOrThrow
   */
  export type WebDevelopmentDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentDetail to fetch.
     */
    where?: WebDevelopmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebDevelopmentDetails to fetch.
     */
    orderBy?: WebDevelopmentDetailOrderByWithRelationInput | WebDevelopmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebDevelopmentDetails.
     */
    cursor?: WebDevelopmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebDevelopmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebDevelopmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebDevelopmentDetails.
     */
    distinct?: WebDevelopmentDetailScalarFieldEnum | WebDevelopmentDetailScalarFieldEnum[]
  }

  /**
   * WebDevelopmentDetail findMany
   */
  export type WebDevelopmentDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentDetails to fetch.
     */
    where?: WebDevelopmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebDevelopmentDetails to fetch.
     */
    orderBy?: WebDevelopmentDetailOrderByWithRelationInput | WebDevelopmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebDevelopmentDetails.
     */
    cursor?: WebDevelopmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebDevelopmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebDevelopmentDetails.
     */
    skip?: number
    distinct?: WebDevelopmentDetailScalarFieldEnum | WebDevelopmentDetailScalarFieldEnum[]
  }

  /**
   * WebDevelopmentDetail create
   */
  export type WebDevelopmentDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a WebDevelopmentDetail.
     */
    data: XOR<WebDevelopmentDetailCreateInput, WebDevelopmentDetailUncheckedCreateInput>
  }

  /**
   * WebDevelopmentDetail createMany
   */
  export type WebDevelopmentDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebDevelopmentDetails.
     */
    data: WebDevelopmentDetailCreateManyInput | WebDevelopmentDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebDevelopmentDetail update
   */
  export type WebDevelopmentDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a WebDevelopmentDetail.
     */
    data: XOR<WebDevelopmentDetailUpdateInput, WebDevelopmentDetailUncheckedUpdateInput>
    /**
     * Choose, which WebDevelopmentDetail to update.
     */
    where: WebDevelopmentDetailWhereUniqueInput
  }

  /**
   * WebDevelopmentDetail updateMany
   */
  export type WebDevelopmentDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebDevelopmentDetails.
     */
    data: XOR<WebDevelopmentDetailUpdateManyMutationInput, WebDevelopmentDetailUncheckedUpdateManyInput>
    /**
     * Filter which WebDevelopmentDetails to update
     */
    where?: WebDevelopmentDetailWhereInput
    /**
     * Limit how many WebDevelopmentDetails to update.
     */
    limit?: number
  }

  /**
   * WebDevelopmentDetail upsert
   */
  export type WebDevelopmentDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the WebDevelopmentDetail to update in case it exists.
     */
    where: WebDevelopmentDetailWhereUniqueInput
    /**
     * In case the WebDevelopmentDetail found by the `where` argument doesn't exist, create a new WebDevelopmentDetail with this data.
     */
    create: XOR<WebDevelopmentDetailCreateInput, WebDevelopmentDetailUncheckedCreateInput>
    /**
     * In case the WebDevelopmentDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebDevelopmentDetailUpdateInput, WebDevelopmentDetailUncheckedUpdateInput>
  }

  /**
   * WebDevelopmentDetail delete
   */
  export type WebDevelopmentDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter which WebDevelopmentDetail to delete.
     */
    where: WebDevelopmentDetailWhereUniqueInput
  }

  /**
   * WebDevelopmentDetail deleteMany
   */
  export type WebDevelopmentDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebDevelopmentDetails to delete
     */
    where?: WebDevelopmentDetailWhereInput
    /**
     * Limit how many WebDevelopmentDetails to delete.
     */
    limit?: number
  }

  /**
   * WebDevelopmentDetail.webFeatures
   */
  export type WebDevelopmentDetail$webFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    where?: WebDevelopmentFeatureWhereInput
    orderBy?: WebDevelopmentFeatureOrderByWithRelationInput | WebDevelopmentFeatureOrderByWithRelationInput[]
    cursor?: WebDevelopmentFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebDevelopmentFeatureScalarFieldEnum | WebDevelopmentFeatureScalarFieldEnum[]
  }

  /**
   * WebDevelopmentDetail without action
   */
  export type WebDevelopmentDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentDetail
     */
    select?: WebDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentDetail
     */
    omit?: WebDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentDetailInclude<ExtArgs> | null
  }


  /**
   * Model WebDevelopmentFeature
   */

  export type AggregateWebDevelopmentFeature = {
    _count: WebDevelopmentFeatureCountAggregateOutputType | null
    _avg: WebDevelopmentFeatureAvgAggregateOutputType | null
    _sum: WebDevelopmentFeatureSumAggregateOutputType | null
    _min: WebDevelopmentFeatureMinAggregateOutputType | null
    _max: WebDevelopmentFeatureMaxAggregateOutputType | null
  }

  export type WebDevelopmentFeatureAvgAggregateOutputType = {
    id: number | null
    price: number | null
    webDevDetailId: number | null
  }

  export type WebDevelopmentFeatureSumAggregateOutputType = {
    id: number | null
    price: number | null
    webDevDetailId: number | null
  }

  export type WebDevelopmentFeatureMinAggregateOutputType = {
    id: number | null
    feature: string | null
    price: number | null
    webDevDetailId: number | null
  }

  export type WebDevelopmentFeatureMaxAggregateOutputType = {
    id: number | null
    feature: string | null
    price: number | null
    webDevDetailId: number | null
  }

  export type WebDevelopmentFeatureCountAggregateOutputType = {
    id: number
    feature: number
    price: number
    webDevDetailId: number
    _all: number
  }


  export type WebDevelopmentFeatureAvgAggregateInputType = {
    id?: true
    price?: true
    webDevDetailId?: true
  }

  export type WebDevelopmentFeatureSumAggregateInputType = {
    id?: true
    price?: true
    webDevDetailId?: true
  }

  export type WebDevelopmentFeatureMinAggregateInputType = {
    id?: true
    feature?: true
    price?: true
    webDevDetailId?: true
  }

  export type WebDevelopmentFeatureMaxAggregateInputType = {
    id?: true
    feature?: true
    price?: true
    webDevDetailId?: true
  }

  export type WebDevelopmentFeatureCountAggregateInputType = {
    id?: true
    feature?: true
    price?: true
    webDevDetailId?: true
    _all?: true
  }

  export type WebDevelopmentFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebDevelopmentFeature to aggregate.
     */
    where?: WebDevelopmentFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebDevelopmentFeatures to fetch.
     */
    orderBy?: WebDevelopmentFeatureOrderByWithRelationInput | WebDevelopmentFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebDevelopmentFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebDevelopmentFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebDevelopmentFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebDevelopmentFeatures
    **/
    _count?: true | WebDevelopmentFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebDevelopmentFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebDevelopmentFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebDevelopmentFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebDevelopmentFeatureMaxAggregateInputType
  }

  export type GetWebDevelopmentFeatureAggregateType<T extends WebDevelopmentFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateWebDevelopmentFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebDevelopmentFeature[P]>
      : GetScalarType<T[P], AggregateWebDevelopmentFeature[P]>
  }




  export type WebDevelopmentFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebDevelopmentFeatureWhereInput
    orderBy?: WebDevelopmentFeatureOrderByWithAggregationInput | WebDevelopmentFeatureOrderByWithAggregationInput[]
    by: WebDevelopmentFeatureScalarFieldEnum[] | WebDevelopmentFeatureScalarFieldEnum
    having?: WebDevelopmentFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebDevelopmentFeatureCountAggregateInputType | true
    _avg?: WebDevelopmentFeatureAvgAggregateInputType
    _sum?: WebDevelopmentFeatureSumAggregateInputType
    _min?: WebDevelopmentFeatureMinAggregateInputType
    _max?: WebDevelopmentFeatureMaxAggregateInputType
  }

  export type WebDevelopmentFeatureGroupByOutputType = {
    id: number
    feature: string
    price: number
    webDevDetailId: number
    _count: WebDevelopmentFeatureCountAggregateOutputType | null
    _avg: WebDevelopmentFeatureAvgAggregateOutputType | null
    _sum: WebDevelopmentFeatureSumAggregateOutputType | null
    _min: WebDevelopmentFeatureMinAggregateOutputType | null
    _max: WebDevelopmentFeatureMaxAggregateOutputType | null
  }

  type GetWebDevelopmentFeatureGroupByPayload<T extends WebDevelopmentFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebDevelopmentFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebDevelopmentFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebDevelopmentFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], WebDevelopmentFeatureGroupByOutputType[P]>
        }
      >
    >


  export type WebDevelopmentFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feature?: boolean
    price?: boolean
    webDevDetailId?: boolean
    webDevDetail?: boolean | WebDevelopmentDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webDevelopmentFeature"]>



  export type WebDevelopmentFeatureSelectScalar = {
    id?: boolean
    feature?: boolean
    price?: boolean
    webDevDetailId?: boolean
  }

  export type WebDevelopmentFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feature" | "price" | "webDevDetailId", ExtArgs["result"]["webDevelopmentFeature"]>
  export type WebDevelopmentFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webDevDetail?: boolean | WebDevelopmentDetailDefaultArgs<ExtArgs>
  }

  export type $WebDevelopmentFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebDevelopmentFeature"
    objects: {
      webDevDetail: Prisma.$WebDevelopmentDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      feature: string
      price: number
      webDevDetailId: number
    }, ExtArgs["result"]["webDevelopmentFeature"]>
    composites: {}
  }

  type WebDevelopmentFeatureGetPayload<S extends boolean | null | undefined | WebDevelopmentFeatureDefaultArgs> = $Result.GetResult<Prisma.$WebDevelopmentFeaturePayload, S>

  type WebDevelopmentFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebDevelopmentFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebDevelopmentFeatureCountAggregateInputType | true
    }

  export interface WebDevelopmentFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebDevelopmentFeature'], meta: { name: 'WebDevelopmentFeature' } }
    /**
     * Find zero or one WebDevelopmentFeature that matches the filter.
     * @param {WebDevelopmentFeatureFindUniqueArgs} args - Arguments to find a WebDevelopmentFeature
     * @example
     * // Get one WebDevelopmentFeature
     * const webDevelopmentFeature = await prisma.webDevelopmentFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebDevelopmentFeatureFindUniqueArgs>(args: SelectSubset<T, WebDevelopmentFeatureFindUniqueArgs<ExtArgs>>): Prisma__WebDevelopmentFeatureClient<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebDevelopmentFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebDevelopmentFeatureFindUniqueOrThrowArgs} args - Arguments to find a WebDevelopmentFeature
     * @example
     * // Get one WebDevelopmentFeature
     * const webDevelopmentFeature = await prisma.webDevelopmentFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebDevelopmentFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, WebDevelopmentFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebDevelopmentFeatureClient<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebDevelopmentFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentFeatureFindFirstArgs} args - Arguments to find a WebDevelopmentFeature
     * @example
     * // Get one WebDevelopmentFeature
     * const webDevelopmentFeature = await prisma.webDevelopmentFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebDevelopmentFeatureFindFirstArgs>(args?: SelectSubset<T, WebDevelopmentFeatureFindFirstArgs<ExtArgs>>): Prisma__WebDevelopmentFeatureClient<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebDevelopmentFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentFeatureFindFirstOrThrowArgs} args - Arguments to find a WebDevelopmentFeature
     * @example
     * // Get one WebDevelopmentFeature
     * const webDevelopmentFeature = await prisma.webDevelopmentFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebDevelopmentFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, WebDevelopmentFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebDevelopmentFeatureClient<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebDevelopmentFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebDevelopmentFeatures
     * const webDevelopmentFeatures = await prisma.webDevelopmentFeature.findMany()
     * 
     * // Get first 10 WebDevelopmentFeatures
     * const webDevelopmentFeatures = await prisma.webDevelopmentFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webDevelopmentFeatureWithIdOnly = await prisma.webDevelopmentFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebDevelopmentFeatureFindManyArgs>(args?: SelectSubset<T, WebDevelopmentFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebDevelopmentFeature.
     * @param {WebDevelopmentFeatureCreateArgs} args - Arguments to create a WebDevelopmentFeature.
     * @example
     * // Create one WebDevelopmentFeature
     * const WebDevelopmentFeature = await prisma.webDevelopmentFeature.create({
     *   data: {
     *     // ... data to create a WebDevelopmentFeature
     *   }
     * })
     * 
     */
    create<T extends WebDevelopmentFeatureCreateArgs>(args: SelectSubset<T, WebDevelopmentFeatureCreateArgs<ExtArgs>>): Prisma__WebDevelopmentFeatureClient<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebDevelopmentFeatures.
     * @param {WebDevelopmentFeatureCreateManyArgs} args - Arguments to create many WebDevelopmentFeatures.
     * @example
     * // Create many WebDevelopmentFeatures
     * const webDevelopmentFeature = await prisma.webDevelopmentFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebDevelopmentFeatureCreateManyArgs>(args?: SelectSubset<T, WebDevelopmentFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WebDevelopmentFeature.
     * @param {WebDevelopmentFeatureDeleteArgs} args - Arguments to delete one WebDevelopmentFeature.
     * @example
     * // Delete one WebDevelopmentFeature
     * const WebDevelopmentFeature = await prisma.webDevelopmentFeature.delete({
     *   where: {
     *     // ... filter to delete one WebDevelopmentFeature
     *   }
     * })
     * 
     */
    delete<T extends WebDevelopmentFeatureDeleteArgs>(args: SelectSubset<T, WebDevelopmentFeatureDeleteArgs<ExtArgs>>): Prisma__WebDevelopmentFeatureClient<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebDevelopmentFeature.
     * @param {WebDevelopmentFeatureUpdateArgs} args - Arguments to update one WebDevelopmentFeature.
     * @example
     * // Update one WebDevelopmentFeature
     * const webDevelopmentFeature = await prisma.webDevelopmentFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebDevelopmentFeatureUpdateArgs>(args: SelectSubset<T, WebDevelopmentFeatureUpdateArgs<ExtArgs>>): Prisma__WebDevelopmentFeatureClient<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebDevelopmentFeatures.
     * @param {WebDevelopmentFeatureDeleteManyArgs} args - Arguments to filter WebDevelopmentFeatures to delete.
     * @example
     * // Delete a few WebDevelopmentFeatures
     * const { count } = await prisma.webDevelopmentFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebDevelopmentFeatureDeleteManyArgs>(args?: SelectSubset<T, WebDevelopmentFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebDevelopmentFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebDevelopmentFeatures
     * const webDevelopmentFeature = await prisma.webDevelopmentFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebDevelopmentFeatureUpdateManyArgs>(args: SelectSubset<T, WebDevelopmentFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebDevelopmentFeature.
     * @param {WebDevelopmentFeatureUpsertArgs} args - Arguments to update or create a WebDevelopmentFeature.
     * @example
     * // Update or create a WebDevelopmentFeature
     * const webDevelopmentFeature = await prisma.webDevelopmentFeature.upsert({
     *   create: {
     *     // ... data to create a WebDevelopmentFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebDevelopmentFeature we want to update
     *   }
     * })
     */
    upsert<T extends WebDevelopmentFeatureUpsertArgs>(args: SelectSubset<T, WebDevelopmentFeatureUpsertArgs<ExtArgs>>): Prisma__WebDevelopmentFeatureClient<$Result.GetResult<Prisma.$WebDevelopmentFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebDevelopmentFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentFeatureCountArgs} args - Arguments to filter WebDevelopmentFeatures to count.
     * @example
     * // Count the number of WebDevelopmentFeatures
     * const count = await prisma.webDevelopmentFeature.count({
     *   where: {
     *     // ... the filter for the WebDevelopmentFeatures we want to count
     *   }
     * })
    **/
    count<T extends WebDevelopmentFeatureCountArgs>(
      args?: Subset<T, WebDevelopmentFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebDevelopmentFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebDevelopmentFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebDevelopmentFeatureAggregateArgs>(args: Subset<T, WebDevelopmentFeatureAggregateArgs>): Prisma.PrismaPromise<GetWebDevelopmentFeatureAggregateType<T>>

    /**
     * Group by WebDevelopmentFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebDevelopmentFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebDevelopmentFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebDevelopmentFeatureGroupByArgs['orderBy'] }
        : { orderBy?: WebDevelopmentFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebDevelopmentFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebDevelopmentFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebDevelopmentFeature model
   */
  readonly fields: WebDevelopmentFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebDevelopmentFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebDevelopmentFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    webDevDetail<T extends WebDevelopmentDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebDevelopmentDetailDefaultArgs<ExtArgs>>): Prisma__WebDevelopmentDetailClient<$Result.GetResult<Prisma.$WebDevelopmentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebDevelopmentFeature model
   */
  interface WebDevelopmentFeatureFieldRefs {
    readonly id: FieldRef<"WebDevelopmentFeature", 'Int'>
    readonly feature: FieldRef<"WebDevelopmentFeature", 'String'>
    readonly price: FieldRef<"WebDevelopmentFeature", 'Float'>
    readonly webDevDetailId: FieldRef<"WebDevelopmentFeature", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WebDevelopmentFeature findUnique
   */
  export type WebDevelopmentFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentFeature to fetch.
     */
    where: WebDevelopmentFeatureWhereUniqueInput
  }

  /**
   * WebDevelopmentFeature findUniqueOrThrow
   */
  export type WebDevelopmentFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentFeature to fetch.
     */
    where: WebDevelopmentFeatureWhereUniqueInput
  }

  /**
   * WebDevelopmentFeature findFirst
   */
  export type WebDevelopmentFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentFeature to fetch.
     */
    where?: WebDevelopmentFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebDevelopmentFeatures to fetch.
     */
    orderBy?: WebDevelopmentFeatureOrderByWithRelationInput | WebDevelopmentFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebDevelopmentFeatures.
     */
    cursor?: WebDevelopmentFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebDevelopmentFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebDevelopmentFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebDevelopmentFeatures.
     */
    distinct?: WebDevelopmentFeatureScalarFieldEnum | WebDevelopmentFeatureScalarFieldEnum[]
  }

  /**
   * WebDevelopmentFeature findFirstOrThrow
   */
  export type WebDevelopmentFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentFeature to fetch.
     */
    where?: WebDevelopmentFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebDevelopmentFeatures to fetch.
     */
    orderBy?: WebDevelopmentFeatureOrderByWithRelationInput | WebDevelopmentFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebDevelopmentFeatures.
     */
    cursor?: WebDevelopmentFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebDevelopmentFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebDevelopmentFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebDevelopmentFeatures.
     */
    distinct?: WebDevelopmentFeatureScalarFieldEnum | WebDevelopmentFeatureScalarFieldEnum[]
  }

  /**
   * WebDevelopmentFeature findMany
   */
  export type WebDevelopmentFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    /**
     * Filter, which WebDevelopmentFeatures to fetch.
     */
    where?: WebDevelopmentFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebDevelopmentFeatures to fetch.
     */
    orderBy?: WebDevelopmentFeatureOrderByWithRelationInput | WebDevelopmentFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebDevelopmentFeatures.
     */
    cursor?: WebDevelopmentFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebDevelopmentFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebDevelopmentFeatures.
     */
    skip?: number
    distinct?: WebDevelopmentFeatureScalarFieldEnum | WebDevelopmentFeatureScalarFieldEnum[]
  }

  /**
   * WebDevelopmentFeature create
   */
  export type WebDevelopmentFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a WebDevelopmentFeature.
     */
    data: XOR<WebDevelopmentFeatureCreateInput, WebDevelopmentFeatureUncheckedCreateInput>
  }

  /**
   * WebDevelopmentFeature createMany
   */
  export type WebDevelopmentFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebDevelopmentFeatures.
     */
    data: WebDevelopmentFeatureCreateManyInput | WebDevelopmentFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebDevelopmentFeature update
   */
  export type WebDevelopmentFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a WebDevelopmentFeature.
     */
    data: XOR<WebDevelopmentFeatureUpdateInput, WebDevelopmentFeatureUncheckedUpdateInput>
    /**
     * Choose, which WebDevelopmentFeature to update.
     */
    where: WebDevelopmentFeatureWhereUniqueInput
  }

  /**
   * WebDevelopmentFeature updateMany
   */
  export type WebDevelopmentFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebDevelopmentFeatures.
     */
    data: XOR<WebDevelopmentFeatureUpdateManyMutationInput, WebDevelopmentFeatureUncheckedUpdateManyInput>
    /**
     * Filter which WebDevelopmentFeatures to update
     */
    where?: WebDevelopmentFeatureWhereInput
    /**
     * Limit how many WebDevelopmentFeatures to update.
     */
    limit?: number
  }

  /**
   * WebDevelopmentFeature upsert
   */
  export type WebDevelopmentFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the WebDevelopmentFeature to update in case it exists.
     */
    where: WebDevelopmentFeatureWhereUniqueInput
    /**
     * In case the WebDevelopmentFeature found by the `where` argument doesn't exist, create a new WebDevelopmentFeature with this data.
     */
    create: XOR<WebDevelopmentFeatureCreateInput, WebDevelopmentFeatureUncheckedCreateInput>
    /**
     * In case the WebDevelopmentFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebDevelopmentFeatureUpdateInput, WebDevelopmentFeatureUncheckedUpdateInput>
  }

  /**
   * WebDevelopmentFeature delete
   */
  export type WebDevelopmentFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
    /**
     * Filter which WebDevelopmentFeature to delete.
     */
    where: WebDevelopmentFeatureWhereUniqueInput
  }

  /**
   * WebDevelopmentFeature deleteMany
   */
  export type WebDevelopmentFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebDevelopmentFeatures to delete
     */
    where?: WebDevelopmentFeatureWhereInput
    /**
     * Limit how many WebDevelopmentFeatures to delete.
     */
    limit?: number
  }

  /**
   * WebDevelopmentFeature without action
   */
  export type WebDevelopmentFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebDevelopmentFeature
     */
    select?: WebDevelopmentFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebDevelopmentFeature
     */
    omit?: WebDevelopmentFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebDevelopmentFeatureInclude<ExtArgs> | null
  }


  /**
   * Model SeoDetail
   */

  export type AggregateSeoDetail = {
    _count: SeoDetailCountAggregateOutputType | null
    _avg: SeoDetailAvgAggregateOutputType | null
    _sum: SeoDetailSumAggregateOutputType | null
    _min: SeoDetailMinAggregateOutputType | null
    _max: SeoDetailMaxAggregateOutputType | null
  }

  export type SeoDetailAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type SeoDetailSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type SeoDetailMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type SeoDetailMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type SeoDetailCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type SeoDetailAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type SeoDetailSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type SeoDetailMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SeoDetailMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SeoDetailCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type SeoDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoDetail to aggregate.
     */
    where?: SeoDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoDetails to fetch.
     */
    orderBy?: SeoDetailOrderByWithRelationInput | SeoDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeoDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeoDetails
    **/
    _count?: true | SeoDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeoDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeoDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeoDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeoDetailMaxAggregateInputType
  }

  export type GetSeoDetailAggregateType<T extends SeoDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateSeoDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeoDetail[P]>
      : GetScalarType<T[P], AggregateSeoDetail[P]>
  }




  export type SeoDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoDetailWhereInput
    orderBy?: SeoDetailOrderByWithAggregationInput | SeoDetailOrderByWithAggregationInput[]
    by: SeoDetailScalarFieldEnum[] | SeoDetailScalarFieldEnum
    having?: SeoDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeoDetailCountAggregateInputType | true
    _avg?: SeoDetailAvgAggregateInputType
    _sum?: SeoDetailSumAggregateInputType
    _min?: SeoDetailMinAggregateInputType
    _max?: SeoDetailMaxAggregateInputType
  }

  export type SeoDetailGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: SeoDetailCountAggregateOutputType | null
    _avg: SeoDetailAvgAggregateOutputType | null
    _sum: SeoDetailSumAggregateOutputType | null
    _min: SeoDetailMinAggregateOutputType | null
    _max: SeoDetailMaxAggregateOutputType | null
  }

  type GetSeoDetailGroupByPayload<T extends SeoDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeoDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeoDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeoDetailGroupByOutputType[P]>
            : GetScalarType<T[P], SeoDetailGroupByOutputType[P]>
        }
      >
    >


  export type SeoDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    seoTypes?: boolean | SeoDetail$seoTypesArgs<ExtArgs>
    _count?: boolean | SeoDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seoDetail"]>



  export type SeoDetailSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type SeoDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["seoDetail"]>
  export type SeoDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    seoTypes?: boolean | SeoDetail$seoTypesArgs<ExtArgs>
    _count?: boolean | SeoDetailCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SeoDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeoDetail"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      seoTypes: Prisma.$SeoTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["seoDetail"]>
    composites: {}
  }

  type SeoDetailGetPayload<S extends boolean | null | undefined | SeoDetailDefaultArgs> = $Result.GetResult<Prisma.$SeoDetailPayload, S>

  type SeoDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeoDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeoDetailCountAggregateInputType | true
    }

  export interface SeoDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeoDetail'], meta: { name: 'SeoDetail' } }
    /**
     * Find zero or one SeoDetail that matches the filter.
     * @param {SeoDetailFindUniqueArgs} args - Arguments to find a SeoDetail
     * @example
     * // Get one SeoDetail
     * const seoDetail = await prisma.seoDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeoDetailFindUniqueArgs>(args: SelectSubset<T, SeoDetailFindUniqueArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeoDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeoDetailFindUniqueOrThrowArgs} args - Arguments to find a SeoDetail
     * @example
     * // Get one SeoDetail
     * const seoDetail = await prisma.seoDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeoDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, SeoDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDetailFindFirstArgs} args - Arguments to find a SeoDetail
     * @example
     * // Get one SeoDetail
     * const seoDetail = await prisma.seoDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeoDetailFindFirstArgs>(args?: SelectSubset<T, SeoDetailFindFirstArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDetailFindFirstOrThrowArgs} args - Arguments to find a SeoDetail
     * @example
     * // Get one SeoDetail
     * const seoDetail = await prisma.seoDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeoDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, SeoDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeoDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeoDetails
     * const seoDetails = await prisma.seoDetail.findMany()
     * 
     * // Get first 10 SeoDetails
     * const seoDetails = await prisma.seoDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seoDetailWithIdOnly = await prisma.seoDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeoDetailFindManyArgs>(args?: SelectSubset<T, SeoDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeoDetail.
     * @param {SeoDetailCreateArgs} args - Arguments to create a SeoDetail.
     * @example
     * // Create one SeoDetail
     * const SeoDetail = await prisma.seoDetail.create({
     *   data: {
     *     // ... data to create a SeoDetail
     *   }
     * })
     * 
     */
    create<T extends SeoDetailCreateArgs>(args: SelectSubset<T, SeoDetailCreateArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeoDetails.
     * @param {SeoDetailCreateManyArgs} args - Arguments to create many SeoDetails.
     * @example
     * // Create many SeoDetails
     * const seoDetail = await prisma.seoDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeoDetailCreateManyArgs>(args?: SelectSubset<T, SeoDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeoDetail.
     * @param {SeoDetailDeleteArgs} args - Arguments to delete one SeoDetail.
     * @example
     * // Delete one SeoDetail
     * const SeoDetail = await prisma.seoDetail.delete({
     *   where: {
     *     // ... filter to delete one SeoDetail
     *   }
     * })
     * 
     */
    delete<T extends SeoDetailDeleteArgs>(args: SelectSubset<T, SeoDetailDeleteArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeoDetail.
     * @param {SeoDetailUpdateArgs} args - Arguments to update one SeoDetail.
     * @example
     * // Update one SeoDetail
     * const seoDetail = await prisma.seoDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeoDetailUpdateArgs>(args: SelectSubset<T, SeoDetailUpdateArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeoDetails.
     * @param {SeoDetailDeleteManyArgs} args - Arguments to filter SeoDetails to delete.
     * @example
     * // Delete a few SeoDetails
     * const { count } = await prisma.seoDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeoDetailDeleteManyArgs>(args?: SelectSubset<T, SeoDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeoDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeoDetails
     * const seoDetail = await prisma.seoDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeoDetailUpdateManyArgs>(args: SelectSubset<T, SeoDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeoDetail.
     * @param {SeoDetailUpsertArgs} args - Arguments to update or create a SeoDetail.
     * @example
     * // Update or create a SeoDetail
     * const seoDetail = await prisma.seoDetail.upsert({
     *   create: {
     *     // ... data to create a SeoDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeoDetail we want to update
     *   }
     * })
     */
    upsert<T extends SeoDetailUpsertArgs>(args: SelectSubset<T, SeoDetailUpsertArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeoDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDetailCountArgs} args - Arguments to filter SeoDetails to count.
     * @example
     * // Count the number of SeoDetails
     * const count = await prisma.seoDetail.count({
     *   where: {
     *     // ... the filter for the SeoDetails we want to count
     *   }
     * })
    **/
    count<T extends SeoDetailCountArgs>(
      args?: Subset<T, SeoDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeoDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeoDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeoDetailAggregateArgs>(args: Subset<T, SeoDetailAggregateArgs>): Prisma.PrismaPromise<GetSeoDetailAggregateType<T>>

    /**
     * Group by SeoDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeoDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeoDetailGroupByArgs['orderBy'] }
        : { orderBy?: SeoDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeoDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeoDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeoDetail model
   */
  readonly fields: SeoDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeoDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeoDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seoTypes<T extends SeoDetail$seoTypesArgs<ExtArgs> = {}>(args?: Subset<T, SeoDetail$seoTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeoDetail model
   */
  interface SeoDetailFieldRefs {
    readonly id: FieldRef<"SeoDetail", 'Int'>
    readonly createdAt: FieldRef<"SeoDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"SeoDetail", 'DateTime'>
    readonly projectId: FieldRef<"SeoDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SeoDetail findUnique
   */
  export type SeoDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    /**
     * Filter, which SeoDetail to fetch.
     */
    where: SeoDetailWhereUniqueInput
  }

  /**
   * SeoDetail findUniqueOrThrow
   */
  export type SeoDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    /**
     * Filter, which SeoDetail to fetch.
     */
    where: SeoDetailWhereUniqueInput
  }

  /**
   * SeoDetail findFirst
   */
  export type SeoDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    /**
     * Filter, which SeoDetail to fetch.
     */
    where?: SeoDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoDetails to fetch.
     */
    orderBy?: SeoDetailOrderByWithRelationInput | SeoDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoDetails.
     */
    cursor?: SeoDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoDetails.
     */
    distinct?: SeoDetailScalarFieldEnum | SeoDetailScalarFieldEnum[]
  }

  /**
   * SeoDetail findFirstOrThrow
   */
  export type SeoDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    /**
     * Filter, which SeoDetail to fetch.
     */
    where?: SeoDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoDetails to fetch.
     */
    orderBy?: SeoDetailOrderByWithRelationInput | SeoDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoDetails.
     */
    cursor?: SeoDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoDetails.
     */
    distinct?: SeoDetailScalarFieldEnum | SeoDetailScalarFieldEnum[]
  }

  /**
   * SeoDetail findMany
   */
  export type SeoDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    /**
     * Filter, which SeoDetails to fetch.
     */
    where?: SeoDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoDetails to fetch.
     */
    orderBy?: SeoDetailOrderByWithRelationInput | SeoDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeoDetails.
     */
    cursor?: SeoDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoDetails.
     */
    skip?: number
    distinct?: SeoDetailScalarFieldEnum | SeoDetailScalarFieldEnum[]
  }

  /**
   * SeoDetail create
   */
  export type SeoDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a SeoDetail.
     */
    data: XOR<SeoDetailCreateInput, SeoDetailUncheckedCreateInput>
  }

  /**
   * SeoDetail createMany
   */
  export type SeoDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeoDetails.
     */
    data: SeoDetailCreateManyInput | SeoDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeoDetail update
   */
  export type SeoDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a SeoDetail.
     */
    data: XOR<SeoDetailUpdateInput, SeoDetailUncheckedUpdateInput>
    /**
     * Choose, which SeoDetail to update.
     */
    where: SeoDetailWhereUniqueInput
  }

  /**
   * SeoDetail updateMany
   */
  export type SeoDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeoDetails.
     */
    data: XOR<SeoDetailUpdateManyMutationInput, SeoDetailUncheckedUpdateManyInput>
    /**
     * Filter which SeoDetails to update
     */
    where?: SeoDetailWhereInput
    /**
     * Limit how many SeoDetails to update.
     */
    limit?: number
  }

  /**
   * SeoDetail upsert
   */
  export type SeoDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the SeoDetail to update in case it exists.
     */
    where: SeoDetailWhereUniqueInput
    /**
     * In case the SeoDetail found by the `where` argument doesn't exist, create a new SeoDetail with this data.
     */
    create: XOR<SeoDetailCreateInput, SeoDetailUncheckedCreateInput>
    /**
     * In case the SeoDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeoDetailUpdateInput, SeoDetailUncheckedUpdateInput>
  }

  /**
   * SeoDetail delete
   */
  export type SeoDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
    /**
     * Filter which SeoDetail to delete.
     */
    where: SeoDetailWhereUniqueInput
  }

  /**
   * SeoDetail deleteMany
   */
  export type SeoDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoDetails to delete
     */
    where?: SeoDetailWhereInput
    /**
     * Limit how many SeoDetails to delete.
     */
    limit?: number
  }

  /**
   * SeoDetail.seoTypes
   */
  export type SeoDetail$seoTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    where?: SeoTypeWhereInput
    orderBy?: SeoTypeOrderByWithRelationInput | SeoTypeOrderByWithRelationInput[]
    cursor?: SeoTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeoTypeScalarFieldEnum | SeoTypeScalarFieldEnum[]
  }

  /**
   * SeoDetail without action
   */
  export type SeoDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoDetail
     */
    select?: SeoDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoDetail
     */
    omit?: SeoDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoDetailInclude<ExtArgs> | null
  }


  /**
   * Model SeoType
   */

  export type AggregateSeoType = {
    _count: SeoTypeCountAggregateOutputType | null
    _avg: SeoTypeAvgAggregateOutputType | null
    _sum: SeoTypeSumAggregateOutputType | null
    _min: SeoTypeMinAggregateOutputType | null
    _max: SeoTypeMaxAggregateOutputType | null
  }

  export type SeoTypeAvgAggregateOutputType = {
    id: number | null
    price: number | null
    seoDetailId: number | null
  }

  export type SeoTypeSumAggregateOutputType = {
    id: number | null
    price: number | null
    seoDetailId: number | null
  }

  export type SeoTypeMinAggregateOutputType = {
    id: number | null
    seoType: string | null
    price: number | null
    seoDetailId: number | null
  }

  export type SeoTypeMaxAggregateOutputType = {
    id: number | null
    seoType: string | null
    price: number | null
    seoDetailId: number | null
  }

  export type SeoTypeCountAggregateOutputType = {
    id: number
    seoType: number
    price: number
    seoDetailId: number
    _all: number
  }


  export type SeoTypeAvgAggregateInputType = {
    id?: true
    price?: true
    seoDetailId?: true
  }

  export type SeoTypeSumAggregateInputType = {
    id?: true
    price?: true
    seoDetailId?: true
  }

  export type SeoTypeMinAggregateInputType = {
    id?: true
    seoType?: true
    price?: true
    seoDetailId?: true
  }

  export type SeoTypeMaxAggregateInputType = {
    id?: true
    seoType?: true
    price?: true
    seoDetailId?: true
  }

  export type SeoTypeCountAggregateInputType = {
    id?: true
    seoType?: true
    price?: true
    seoDetailId?: true
    _all?: true
  }

  export type SeoTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoType to aggregate.
     */
    where?: SeoTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoTypes to fetch.
     */
    orderBy?: SeoTypeOrderByWithRelationInput | SeoTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeoTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeoTypes
    **/
    _count?: true | SeoTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeoTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeoTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeoTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeoTypeMaxAggregateInputType
  }

  export type GetSeoTypeAggregateType<T extends SeoTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSeoType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeoType[P]>
      : GetScalarType<T[P], AggregateSeoType[P]>
  }




  export type SeoTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoTypeWhereInput
    orderBy?: SeoTypeOrderByWithAggregationInput | SeoTypeOrderByWithAggregationInput[]
    by: SeoTypeScalarFieldEnum[] | SeoTypeScalarFieldEnum
    having?: SeoTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeoTypeCountAggregateInputType | true
    _avg?: SeoTypeAvgAggregateInputType
    _sum?: SeoTypeSumAggregateInputType
    _min?: SeoTypeMinAggregateInputType
    _max?: SeoTypeMaxAggregateInputType
  }

  export type SeoTypeGroupByOutputType = {
    id: number
    seoType: string
    price: number
    seoDetailId: number
    _count: SeoTypeCountAggregateOutputType | null
    _avg: SeoTypeAvgAggregateOutputType | null
    _sum: SeoTypeSumAggregateOutputType | null
    _min: SeoTypeMinAggregateOutputType | null
    _max: SeoTypeMaxAggregateOutputType | null
  }

  type GetSeoTypeGroupByPayload<T extends SeoTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeoTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeoTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeoTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SeoTypeGroupByOutputType[P]>
        }
      >
    >


  export type SeoTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seoType?: boolean
    price?: boolean
    seoDetailId?: boolean
    seoDetail?: boolean | SeoDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seoType"]>



  export type SeoTypeSelectScalar = {
    id?: boolean
    seoType?: boolean
    price?: boolean
    seoDetailId?: boolean
  }

  export type SeoTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seoType" | "price" | "seoDetailId", ExtArgs["result"]["seoType"]>
  export type SeoTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seoDetail?: boolean | SeoDetailDefaultArgs<ExtArgs>
  }

  export type $SeoTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeoType"
    objects: {
      seoDetail: Prisma.$SeoDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      seoType: string
      price: number
      seoDetailId: number
    }, ExtArgs["result"]["seoType"]>
    composites: {}
  }

  type SeoTypeGetPayload<S extends boolean | null | undefined | SeoTypeDefaultArgs> = $Result.GetResult<Prisma.$SeoTypePayload, S>

  type SeoTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeoTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeoTypeCountAggregateInputType | true
    }

  export interface SeoTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeoType'], meta: { name: 'SeoType' } }
    /**
     * Find zero or one SeoType that matches the filter.
     * @param {SeoTypeFindUniqueArgs} args - Arguments to find a SeoType
     * @example
     * // Get one SeoType
     * const seoType = await prisma.seoType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeoTypeFindUniqueArgs>(args: SelectSubset<T, SeoTypeFindUniqueArgs<ExtArgs>>): Prisma__SeoTypeClient<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeoType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeoTypeFindUniqueOrThrowArgs} args - Arguments to find a SeoType
     * @example
     * // Get one SeoType
     * const seoType = await prisma.seoType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeoTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SeoTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeoTypeClient<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoTypeFindFirstArgs} args - Arguments to find a SeoType
     * @example
     * // Get one SeoType
     * const seoType = await prisma.seoType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeoTypeFindFirstArgs>(args?: SelectSubset<T, SeoTypeFindFirstArgs<ExtArgs>>): Prisma__SeoTypeClient<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoTypeFindFirstOrThrowArgs} args - Arguments to find a SeoType
     * @example
     * // Get one SeoType
     * const seoType = await prisma.seoType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeoTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SeoTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeoTypeClient<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeoTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeoTypes
     * const seoTypes = await prisma.seoType.findMany()
     * 
     * // Get first 10 SeoTypes
     * const seoTypes = await prisma.seoType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seoTypeWithIdOnly = await prisma.seoType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeoTypeFindManyArgs>(args?: SelectSubset<T, SeoTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeoType.
     * @param {SeoTypeCreateArgs} args - Arguments to create a SeoType.
     * @example
     * // Create one SeoType
     * const SeoType = await prisma.seoType.create({
     *   data: {
     *     // ... data to create a SeoType
     *   }
     * })
     * 
     */
    create<T extends SeoTypeCreateArgs>(args: SelectSubset<T, SeoTypeCreateArgs<ExtArgs>>): Prisma__SeoTypeClient<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeoTypes.
     * @param {SeoTypeCreateManyArgs} args - Arguments to create many SeoTypes.
     * @example
     * // Create many SeoTypes
     * const seoType = await prisma.seoType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeoTypeCreateManyArgs>(args?: SelectSubset<T, SeoTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeoType.
     * @param {SeoTypeDeleteArgs} args - Arguments to delete one SeoType.
     * @example
     * // Delete one SeoType
     * const SeoType = await prisma.seoType.delete({
     *   where: {
     *     // ... filter to delete one SeoType
     *   }
     * })
     * 
     */
    delete<T extends SeoTypeDeleteArgs>(args: SelectSubset<T, SeoTypeDeleteArgs<ExtArgs>>): Prisma__SeoTypeClient<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeoType.
     * @param {SeoTypeUpdateArgs} args - Arguments to update one SeoType.
     * @example
     * // Update one SeoType
     * const seoType = await prisma.seoType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeoTypeUpdateArgs>(args: SelectSubset<T, SeoTypeUpdateArgs<ExtArgs>>): Prisma__SeoTypeClient<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeoTypes.
     * @param {SeoTypeDeleteManyArgs} args - Arguments to filter SeoTypes to delete.
     * @example
     * // Delete a few SeoTypes
     * const { count } = await prisma.seoType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeoTypeDeleteManyArgs>(args?: SelectSubset<T, SeoTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeoTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeoTypes
     * const seoType = await prisma.seoType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeoTypeUpdateManyArgs>(args: SelectSubset<T, SeoTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeoType.
     * @param {SeoTypeUpsertArgs} args - Arguments to update or create a SeoType.
     * @example
     * // Update or create a SeoType
     * const seoType = await prisma.seoType.upsert({
     *   create: {
     *     // ... data to create a SeoType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeoType we want to update
     *   }
     * })
     */
    upsert<T extends SeoTypeUpsertArgs>(args: SelectSubset<T, SeoTypeUpsertArgs<ExtArgs>>): Prisma__SeoTypeClient<$Result.GetResult<Prisma.$SeoTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeoTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoTypeCountArgs} args - Arguments to filter SeoTypes to count.
     * @example
     * // Count the number of SeoTypes
     * const count = await prisma.seoType.count({
     *   where: {
     *     // ... the filter for the SeoTypes we want to count
     *   }
     * })
    **/
    count<T extends SeoTypeCountArgs>(
      args?: Subset<T, SeoTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeoTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeoType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeoTypeAggregateArgs>(args: Subset<T, SeoTypeAggregateArgs>): Prisma.PrismaPromise<GetSeoTypeAggregateType<T>>

    /**
     * Group by SeoType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeoTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeoTypeGroupByArgs['orderBy'] }
        : { orderBy?: SeoTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeoTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeoTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeoType model
   */
  readonly fields: SeoTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeoType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeoTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seoDetail<T extends SeoDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeoDetailDefaultArgs<ExtArgs>>): Prisma__SeoDetailClient<$Result.GetResult<Prisma.$SeoDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeoType model
   */
  interface SeoTypeFieldRefs {
    readonly id: FieldRef<"SeoType", 'Int'>
    readonly seoType: FieldRef<"SeoType", 'String'>
    readonly price: FieldRef<"SeoType", 'Float'>
    readonly seoDetailId: FieldRef<"SeoType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SeoType findUnique
   */
  export type SeoTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    /**
     * Filter, which SeoType to fetch.
     */
    where: SeoTypeWhereUniqueInput
  }

  /**
   * SeoType findUniqueOrThrow
   */
  export type SeoTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    /**
     * Filter, which SeoType to fetch.
     */
    where: SeoTypeWhereUniqueInput
  }

  /**
   * SeoType findFirst
   */
  export type SeoTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    /**
     * Filter, which SeoType to fetch.
     */
    where?: SeoTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoTypes to fetch.
     */
    orderBy?: SeoTypeOrderByWithRelationInput | SeoTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoTypes.
     */
    cursor?: SeoTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoTypes.
     */
    distinct?: SeoTypeScalarFieldEnum | SeoTypeScalarFieldEnum[]
  }

  /**
   * SeoType findFirstOrThrow
   */
  export type SeoTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    /**
     * Filter, which SeoType to fetch.
     */
    where?: SeoTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoTypes to fetch.
     */
    orderBy?: SeoTypeOrderByWithRelationInput | SeoTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoTypes.
     */
    cursor?: SeoTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoTypes.
     */
    distinct?: SeoTypeScalarFieldEnum | SeoTypeScalarFieldEnum[]
  }

  /**
   * SeoType findMany
   */
  export type SeoTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    /**
     * Filter, which SeoTypes to fetch.
     */
    where?: SeoTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoTypes to fetch.
     */
    orderBy?: SeoTypeOrderByWithRelationInput | SeoTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeoTypes.
     */
    cursor?: SeoTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoTypes.
     */
    skip?: number
    distinct?: SeoTypeScalarFieldEnum | SeoTypeScalarFieldEnum[]
  }

  /**
   * SeoType create
   */
  export type SeoTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a SeoType.
     */
    data: XOR<SeoTypeCreateInput, SeoTypeUncheckedCreateInput>
  }

  /**
   * SeoType createMany
   */
  export type SeoTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeoTypes.
     */
    data: SeoTypeCreateManyInput | SeoTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeoType update
   */
  export type SeoTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a SeoType.
     */
    data: XOR<SeoTypeUpdateInput, SeoTypeUncheckedUpdateInput>
    /**
     * Choose, which SeoType to update.
     */
    where: SeoTypeWhereUniqueInput
  }

  /**
   * SeoType updateMany
   */
  export type SeoTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeoTypes.
     */
    data: XOR<SeoTypeUpdateManyMutationInput, SeoTypeUncheckedUpdateManyInput>
    /**
     * Filter which SeoTypes to update
     */
    where?: SeoTypeWhereInput
    /**
     * Limit how many SeoTypes to update.
     */
    limit?: number
  }

  /**
   * SeoType upsert
   */
  export type SeoTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the SeoType to update in case it exists.
     */
    where: SeoTypeWhereUniqueInput
    /**
     * In case the SeoType found by the `where` argument doesn't exist, create a new SeoType with this data.
     */
    create: XOR<SeoTypeCreateInput, SeoTypeUncheckedCreateInput>
    /**
     * In case the SeoType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeoTypeUpdateInput, SeoTypeUncheckedUpdateInput>
  }

  /**
   * SeoType delete
   */
  export type SeoTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
    /**
     * Filter which SeoType to delete.
     */
    where: SeoTypeWhereUniqueInput
  }

  /**
   * SeoType deleteMany
   */
  export type SeoTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoTypes to delete
     */
    where?: SeoTypeWhereInput
    /**
     * Limit how many SeoTypes to delete.
     */
    limit?: number
  }

  /**
   * SeoType without action
   */
  export type SeoTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoType
     */
    select?: SeoTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoType
     */
    omit?: SeoTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeoTypeInclude<ExtArgs> | null
  }


  /**
   * Model DigitalMarketingDetail
   */

  export type AggregateDigitalMarketingDetail = {
    _count: DigitalMarketingDetailCountAggregateOutputType | null
    _avg: DigitalMarketingDetailAvgAggregateOutputType | null
    _sum: DigitalMarketingDetailSumAggregateOutputType | null
    _min: DigitalMarketingDetailMinAggregateOutputType | null
    _max: DigitalMarketingDetailMaxAggregateOutputType | null
  }

  export type DigitalMarketingDetailAvgAggregateOutputType = {
    id: number | null
    marketingBudget: number | null
    projectId: number | null
  }

  export type DigitalMarketingDetailSumAggregateOutputType = {
    id: number | null
    marketingBudget: number | null
    projectId: number | null
  }

  export type DigitalMarketingDetailMinAggregateOutputType = {
    id: number | null
    targetAudience: string | null
    marketingBudget: number | null
    duration: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type DigitalMarketingDetailMaxAggregateOutputType = {
    id: number | null
    targetAudience: string | null
    marketingBudget: number | null
    duration: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type DigitalMarketingDetailCountAggregateOutputType = {
    id: number
    targetAudience: number
    marketingBudget: number
    duration: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type DigitalMarketingDetailAvgAggregateInputType = {
    id?: true
    marketingBudget?: true
    projectId?: true
  }

  export type DigitalMarketingDetailSumAggregateInputType = {
    id?: true
    marketingBudget?: true
    projectId?: true
  }

  export type DigitalMarketingDetailMinAggregateInputType = {
    id?: true
    targetAudience?: true
    marketingBudget?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type DigitalMarketingDetailMaxAggregateInputType = {
    id?: true
    targetAudience?: true
    marketingBudget?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type DigitalMarketingDetailCountAggregateInputType = {
    id?: true
    targetAudience?: true
    marketingBudget?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type DigitalMarketingDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalMarketingDetail to aggregate.
     */
    where?: DigitalMarketingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalMarketingDetails to fetch.
     */
    orderBy?: DigitalMarketingDetailOrderByWithRelationInput | DigitalMarketingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DigitalMarketingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalMarketingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalMarketingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DigitalMarketingDetails
    **/
    _count?: true | DigitalMarketingDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DigitalMarketingDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DigitalMarketingDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DigitalMarketingDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DigitalMarketingDetailMaxAggregateInputType
  }

  export type GetDigitalMarketingDetailAggregateType<T extends DigitalMarketingDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateDigitalMarketingDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDigitalMarketingDetail[P]>
      : GetScalarType<T[P], AggregateDigitalMarketingDetail[P]>
  }




  export type DigitalMarketingDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DigitalMarketingDetailWhereInput
    orderBy?: DigitalMarketingDetailOrderByWithAggregationInput | DigitalMarketingDetailOrderByWithAggregationInput[]
    by: DigitalMarketingDetailScalarFieldEnum[] | DigitalMarketingDetailScalarFieldEnum
    having?: DigitalMarketingDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DigitalMarketingDetailCountAggregateInputType | true
    _avg?: DigitalMarketingDetailAvgAggregateInputType
    _sum?: DigitalMarketingDetailSumAggregateInputType
    _min?: DigitalMarketingDetailMinAggregateInputType
    _max?: DigitalMarketingDetailMaxAggregateInputType
  }

  export type DigitalMarketingDetailGroupByOutputType = {
    id: number
    targetAudience: string | null
    marketingBudget: number | null
    duration: string | null
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: DigitalMarketingDetailCountAggregateOutputType | null
    _avg: DigitalMarketingDetailAvgAggregateOutputType | null
    _sum: DigitalMarketingDetailSumAggregateOutputType | null
    _min: DigitalMarketingDetailMinAggregateOutputType | null
    _max: DigitalMarketingDetailMaxAggregateOutputType | null
  }

  type GetDigitalMarketingDetailGroupByPayload<T extends DigitalMarketingDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DigitalMarketingDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DigitalMarketingDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DigitalMarketingDetailGroupByOutputType[P]>
            : GetScalarType<T[P], DigitalMarketingDetailGroupByOutputType[P]>
        }
      >
    >


  export type DigitalMarketingDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetAudience?: boolean
    marketingBudget?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    marketingServices?: boolean | DigitalMarketingDetail$marketingServicesArgs<ExtArgs>
    socialPlatforms?: boolean | DigitalMarketingDetail$socialPlatformsArgs<ExtArgs>
    _count?: boolean | DigitalMarketingDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["digitalMarketingDetail"]>



  export type DigitalMarketingDetailSelectScalar = {
    id?: boolean
    targetAudience?: boolean
    marketingBudget?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type DigitalMarketingDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "targetAudience" | "marketingBudget" | "duration" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["digitalMarketingDetail"]>
  export type DigitalMarketingDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    marketingServices?: boolean | DigitalMarketingDetail$marketingServicesArgs<ExtArgs>
    socialPlatforms?: boolean | DigitalMarketingDetail$socialPlatformsArgs<ExtArgs>
    _count?: boolean | DigitalMarketingDetailCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DigitalMarketingDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DigitalMarketingDetail"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      marketingServices: Prisma.$DigitalMarketingServicePayload<ExtArgs>[]
      socialPlatforms: Prisma.$SocialPlatformPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      targetAudience: string | null
      marketingBudget: number | null
      duration: string | null
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["digitalMarketingDetail"]>
    composites: {}
  }

  type DigitalMarketingDetailGetPayload<S extends boolean | null | undefined | DigitalMarketingDetailDefaultArgs> = $Result.GetResult<Prisma.$DigitalMarketingDetailPayload, S>

  type DigitalMarketingDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DigitalMarketingDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DigitalMarketingDetailCountAggregateInputType | true
    }

  export interface DigitalMarketingDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DigitalMarketingDetail'], meta: { name: 'DigitalMarketingDetail' } }
    /**
     * Find zero or one DigitalMarketingDetail that matches the filter.
     * @param {DigitalMarketingDetailFindUniqueArgs} args - Arguments to find a DigitalMarketingDetail
     * @example
     * // Get one DigitalMarketingDetail
     * const digitalMarketingDetail = await prisma.digitalMarketingDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DigitalMarketingDetailFindUniqueArgs>(args: SelectSubset<T, DigitalMarketingDetailFindUniqueArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DigitalMarketingDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DigitalMarketingDetailFindUniqueOrThrowArgs} args - Arguments to find a DigitalMarketingDetail
     * @example
     * // Get one DigitalMarketingDetail
     * const digitalMarketingDetail = await prisma.digitalMarketingDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DigitalMarketingDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, DigitalMarketingDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DigitalMarketingDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingDetailFindFirstArgs} args - Arguments to find a DigitalMarketingDetail
     * @example
     * // Get one DigitalMarketingDetail
     * const digitalMarketingDetail = await prisma.digitalMarketingDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DigitalMarketingDetailFindFirstArgs>(args?: SelectSubset<T, DigitalMarketingDetailFindFirstArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DigitalMarketingDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingDetailFindFirstOrThrowArgs} args - Arguments to find a DigitalMarketingDetail
     * @example
     * // Get one DigitalMarketingDetail
     * const digitalMarketingDetail = await prisma.digitalMarketingDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DigitalMarketingDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, DigitalMarketingDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DigitalMarketingDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DigitalMarketingDetails
     * const digitalMarketingDetails = await prisma.digitalMarketingDetail.findMany()
     * 
     * // Get first 10 DigitalMarketingDetails
     * const digitalMarketingDetails = await prisma.digitalMarketingDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const digitalMarketingDetailWithIdOnly = await prisma.digitalMarketingDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DigitalMarketingDetailFindManyArgs>(args?: SelectSubset<T, DigitalMarketingDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DigitalMarketingDetail.
     * @param {DigitalMarketingDetailCreateArgs} args - Arguments to create a DigitalMarketingDetail.
     * @example
     * // Create one DigitalMarketingDetail
     * const DigitalMarketingDetail = await prisma.digitalMarketingDetail.create({
     *   data: {
     *     // ... data to create a DigitalMarketingDetail
     *   }
     * })
     * 
     */
    create<T extends DigitalMarketingDetailCreateArgs>(args: SelectSubset<T, DigitalMarketingDetailCreateArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DigitalMarketingDetails.
     * @param {DigitalMarketingDetailCreateManyArgs} args - Arguments to create many DigitalMarketingDetails.
     * @example
     * // Create many DigitalMarketingDetails
     * const digitalMarketingDetail = await prisma.digitalMarketingDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DigitalMarketingDetailCreateManyArgs>(args?: SelectSubset<T, DigitalMarketingDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DigitalMarketingDetail.
     * @param {DigitalMarketingDetailDeleteArgs} args - Arguments to delete one DigitalMarketingDetail.
     * @example
     * // Delete one DigitalMarketingDetail
     * const DigitalMarketingDetail = await prisma.digitalMarketingDetail.delete({
     *   where: {
     *     // ... filter to delete one DigitalMarketingDetail
     *   }
     * })
     * 
     */
    delete<T extends DigitalMarketingDetailDeleteArgs>(args: SelectSubset<T, DigitalMarketingDetailDeleteArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DigitalMarketingDetail.
     * @param {DigitalMarketingDetailUpdateArgs} args - Arguments to update one DigitalMarketingDetail.
     * @example
     * // Update one DigitalMarketingDetail
     * const digitalMarketingDetail = await prisma.digitalMarketingDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DigitalMarketingDetailUpdateArgs>(args: SelectSubset<T, DigitalMarketingDetailUpdateArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DigitalMarketingDetails.
     * @param {DigitalMarketingDetailDeleteManyArgs} args - Arguments to filter DigitalMarketingDetails to delete.
     * @example
     * // Delete a few DigitalMarketingDetails
     * const { count } = await prisma.digitalMarketingDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DigitalMarketingDetailDeleteManyArgs>(args?: SelectSubset<T, DigitalMarketingDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DigitalMarketingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DigitalMarketingDetails
     * const digitalMarketingDetail = await prisma.digitalMarketingDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DigitalMarketingDetailUpdateManyArgs>(args: SelectSubset<T, DigitalMarketingDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DigitalMarketingDetail.
     * @param {DigitalMarketingDetailUpsertArgs} args - Arguments to update or create a DigitalMarketingDetail.
     * @example
     * // Update or create a DigitalMarketingDetail
     * const digitalMarketingDetail = await prisma.digitalMarketingDetail.upsert({
     *   create: {
     *     // ... data to create a DigitalMarketingDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DigitalMarketingDetail we want to update
     *   }
     * })
     */
    upsert<T extends DigitalMarketingDetailUpsertArgs>(args: SelectSubset<T, DigitalMarketingDetailUpsertArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DigitalMarketingDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingDetailCountArgs} args - Arguments to filter DigitalMarketingDetails to count.
     * @example
     * // Count the number of DigitalMarketingDetails
     * const count = await prisma.digitalMarketingDetail.count({
     *   where: {
     *     // ... the filter for the DigitalMarketingDetails we want to count
     *   }
     * })
    **/
    count<T extends DigitalMarketingDetailCountArgs>(
      args?: Subset<T, DigitalMarketingDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DigitalMarketingDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DigitalMarketingDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DigitalMarketingDetailAggregateArgs>(args: Subset<T, DigitalMarketingDetailAggregateArgs>): Prisma.PrismaPromise<GetDigitalMarketingDetailAggregateType<T>>

    /**
     * Group by DigitalMarketingDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DigitalMarketingDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DigitalMarketingDetailGroupByArgs['orderBy'] }
        : { orderBy?: DigitalMarketingDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DigitalMarketingDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDigitalMarketingDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DigitalMarketingDetail model
   */
  readonly fields: DigitalMarketingDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DigitalMarketingDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DigitalMarketingDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marketingServices<T extends DigitalMarketingDetail$marketingServicesArgs<ExtArgs> = {}>(args?: Subset<T, DigitalMarketingDetail$marketingServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socialPlatforms<T extends DigitalMarketingDetail$socialPlatformsArgs<ExtArgs> = {}>(args?: Subset<T, DigitalMarketingDetail$socialPlatformsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DigitalMarketingDetail model
   */
  interface DigitalMarketingDetailFieldRefs {
    readonly id: FieldRef<"DigitalMarketingDetail", 'Int'>
    readonly targetAudience: FieldRef<"DigitalMarketingDetail", 'String'>
    readonly marketingBudget: FieldRef<"DigitalMarketingDetail", 'Float'>
    readonly duration: FieldRef<"DigitalMarketingDetail", 'String'>
    readonly createdAt: FieldRef<"DigitalMarketingDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"DigitalMarketingDetail", 'DateTime'>
    readonly projectId: FieldRef<"DigitalMarketingDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DigitalMarketingDetail findUnique
   */
  export type DigitalMarketingDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingDetail to fetch.
     */
    where: DigitalMarketingDetailWhereUniqueInput
  }

  /**
   * DigitalMarketingDetail findUniqueOrThrow
   */
  export type DigitalMarketingDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingDetail to fetch.
     */
    where: DigitalMarketingDetailWhereUniqueInput
  }

  /**
   * DigitalMarketingDetail findFirst
   */
  export type DigitalMarketingDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingDetail to fetch.
     */
    where?: DigitalMarketingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalMarketingDetails to fetch.
     */
    orderBy?: DigitalMarketingDetailOrderByWithRelationInput | DigitalMarketingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalMarketingDetails.
     */
    cursor?: DigitalMarketingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalMarketingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalMarketingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalMarketingDetails.
     */
    distinct?: DigitalMarketingDetailScalarFieldEnum | DigitalMarketingDetailScalarFieldEnum[]
  }

  /**
   * DigitalMarketingDetail findFirstOrThrow
   */
  export type DigitalMarketingDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingDetail to fetch.
     */
    where?: DigitalMarketingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalMarketingDetails to fetch.
     */
    orderBy?: DigitalMarketingDetailOrderByWithRelationInput | DigitalMarketingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalMarketingDetails.
     */
    cursor?: DigitalMarketingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalMarketingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalMarketingDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalMarketingDetails.
     */
    distinct?: DigitalMarketingDetailScalarFieldEnum | DigitalMarketingDetailScalarFieldEnum[]
  }

  /**
   * DigitalMarketingDetail findMany
   */
  export type DigitalMarketingDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingDetails to fetch.
     */
    where?: DigitalMarketingDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalMarketingDetails to fetch.
     */
    orderBy?: DigitalMarketingDetailOrderByWithRelationInput | DigitalMarketingDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DigitalMarketingDetails.
     */
    cursor?: DigitalMarketingDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalMarketingDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalMarketingDetails.
     */
    skip?: number
    distinct?: DigitalMarketingDetailScalarFieldEnum | DigitalMarketingDetailScalarFieldEnum[]
  }

  /**
   * DigitalMarketingDetail create
   */
  export type DigitalMarketingDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a DigitalMarketingDetail.
     */
    data: XOR<DigitalMarketingDetailCreateInput, DigitalMarketingDetailUncheckedCreateInput>
  }

  /**
   * DigitalMarketingDetail createMany
   */
  export type DigitalMarketingDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DigitalMarketingDetails.
     */
    data: DigitalMarketingDetailCreateManyInput | DigitalMarketingDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DigitalMarketingDetail update
   */
  export type DigitalMarketingDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a DigitalMarketingDetail.
     */
    data: XOR<DigitalMarketingDetailUpdateInput, DigitalMarketingDetailUncheckedUpdateInput>
    /**
     * Choose, which DigitalMarketingDetail to update.
     */
    where: DigitalMarketingDetailWhereUniqueInput
  }

  /**
   * DigitalMarketingDetail updateMany
   */
  export type DigitalMarketingDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DigitalMarketingDetails.
     */
    data: XOR<DigitalMarketingDetailUpdateManyMutationInput, DigitalMarketingDetailUncheckedUpdateManyInput>
    /**
     * Filter which DigitalMarketingDetails to update
     */
    where?: DigitalMarketingDetailWhereInput
    /**
     * Limit how many DigitalMarketingDetails to update.
     */
    limit?: number
  }

  /**
   * DigitalMarketingDetail upsert
   */
  export type DigitalMarketingDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the DigitalMarketingDetail to update in case it exists.
     */
    where: DigitalMarketingDetailWhereUniqueInput
    /**
     * In case the DigitalMarketingDetail found by the `where` argument doesn't exist, create a new DigitalMarketingDetail with this data.
     */
    create: XOR<DigitalMarketingDetailCreateInput, DigitalMarketingDetailUncheckedCreateInput>
    /**
     * In case the DigitalMarketingDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DigitalMarketingDetailUpdateInput, DigitalMarketingDetailUncheckedUpdateInput>
  }

  /**
   * DigitalMarketingDetail delete
   */
  export type DigitalMarketingDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
    /**
     * Filter which DigitalMarketingDetail to delete.
     */
    where: DigitalMarketingDetailWhereUniqueInput
  }

  /**
   * DigitalMarketingDetail deleteMany
   */
  export type DigitalMarketingDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalMarketingDetails to delete
     */
    where?: DigitalMarketingDetailWhereInput
    /**
     * Limit how many DigitalMarketingDetails to delete.
     */
    limit?: number
  }

  /**
   * DigitalMarketingDetail.marketingServices
   */
  export type DigitalMarketingDetail$marketingServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    where?: DigitalMarketingServiceWhereInput
    orderBy?: DigitalMarketingServiceOrderByWithRelationInput | DigitalMarketingServiceOrderByWithRelationInput[]
    cursor?: DigitalMarketingServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DigitalMarketingServiceScalarFieldEnum | DigitalMarketingServiceScalarFieldEnum[]
  }

  /**
   * DigitalMarketingDetail.socialPlatforms
   */
  export type DigitalMarketingDetail$socialPlatformsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    where?: SocialPlatformWhereInput
    orderBy?: SocialPlatformOrderByWithRelationInput | SocialPlatformOrderByWithRelationInput[]
    cursor?: SocialPlatformWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialPlatformScalarFieldEnum | SocialPlatformScalarFieldEnum[]
  }

  /**
   * DigitalMarketingDetail without action
   */
  export type DigitalMarketingDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingDetail
     */
    select?: DigitalMarketingDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingDetail
     */
    omit?: DigitalMarketingDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingDetailInclude<ExtArgs> | null
  }


  /**
   * Model DigitalMarketingService
   */

  export type AggregateDigitalMarketingService = {
    _count: DigitalMarketingServiceCountAggregateOutputType | null
    _avg: DigitalMarketingServiceAvgAggregateOutputType | null
    _sum: DigitalMarketingServiceSumAggregateOutputType | null
    _min: DigitalMarketingServiceMinAggregateOutputType | null
    _max: DigitalMarketingServiceMaxAggregateOutputType | null
  }

  export type DigitalMarketingServiceAvgAggregateOutputType = {
    id: number | null
    price: number | null
    digitalMarketingDetailId: number | null
  }

  export type DigitalMarketingServiceSumAggregateOutputType = {
    id: number | null
    price: number | null
    digitalMarketingDetailId: number | null
  }

  export type DigitalMarketingServiceMinAggregateOutputType = {
    id: number | null
    service: string | null
    price: number | null
    digitalMarketingDetailId: number | null
  }

  export type DigitalMarketingServiceMaxAggregateOutputType = {
    id: number | null
    service: string | null
    price: number | null
    digitalMarketingDetailId: number | null
  }

  export type DigitalMarketingServiceCountAggregateOutputType = {
    id: number
    service: number
    price: number
    digitalMarketingDetailId: number
    _all: number
  }


  export type DigitalMarketingServiceAvgAggregateInputType = {
    id?: true
    price?: true
    digitalMarketingDetailId?: true
  }

  export type DigitalMarketingServiceSumAggregateInputType = {
    id?: true
    price?: true
    digitalMarketingDetailId?: true
  }

  export type DigitalMarketingServiceMinAggregateInputType = {
    id?: true
    service?: true
    price?: true
    digitalMarketingDetailId?: true
  }

  export type DigitalMarketingServiceMaxAggregateInputType = {
    id?: true
    service?: true
    price?: true
    digitalMarketingDetailId?: true
  }

  export type DigitalMarketingServiceCountAggregateInputType = {
    id?: true
    service?: true
    price?: true
    digitalMarketingDetailId?: true
    _all?: true
  }

  export type DigitalMarketingServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalMarketingService to aggregate.
     */
    where?: DigitalMarketingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalMarketingServices to fetch.
     */
    orderBy?: DigitalMarketingServiceOrderByWithRelationInput | DigitalMarketingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DigitalMarketingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalMarketingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalMarketingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DigitalMarketingServices
    **/
    _count?: true | DigitalMarketingServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DigitalMarketingServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DigitalMarketingServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DigitalMarketingServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DigitalMarketingServiceMaxAggregateInputType
  }

  export type GetDigitalMarketingServiceAggregateType<T extends DigitalMarketingServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateDigitalMarketingService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDigitalMarketingService[P]>
      : GetScalarType<T[P], AggregateDigitalMarketingService[P]>
  }




  export type DigitalMarketingServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DigitalMarketingServiceWhereInput
    orderBy?: DigitalMarketingServiceOrderByWithAggregationInput | DigitalMarketingServiceOrderByWithAggregationInput[]
    by: DigitalMarketingServiceScalarFieldEnum[] | DigitalMarketingServiceScalarFieldEnum
    having?: DigitalMarketingServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DigitalMarketingServiceCountAggregateInputType | true
    _avg?: DigitalMarketingServiceAvgAggregateInputType
    _sum?: DigitalMarketingServiceSumAggregateInputType
    _min?: DigitalMarketingServiceMinAggregateInputType
    _max?: DigitalMarketingServiceMaxAggregateInputType
  }

  export type DigitalMarketingServiceGroupByOutputType = {
    id: number
    service: string
    price: number
    digitalMarketingDetailId: number
    _count: DigitalMarketingServiceCountAggregateOutputType | null
    _avg: DigitalMarketingServiceAvgAggregateOutputType | null
    _sum: DigitalMarketingServiceSumAggregateOutputType | null
    _min: DigitalMarketingServiceMinAggregateOutputType | null
    _max: DigitalMarketingServiceMaxAggregateOutputType | null
  }

  type GetDigitalMarketingServiceGroupByPayload<T extends DigitalMarketingServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DigitalMarketingServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DigitalMarketingServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DigitalMarketingServiceGroupByOutputType[P]>
            : GetScalarType<T[P], DigitalMarketingServiceGroupByOutputType[P]>
        }
      >
    >


  export type DigitalMarketingServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    service?: boolean
    price?: boolean
    digitalMarketingDetailId?: boolean
    digitalMarketingDetail?: boolean | DigitalMarketingDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["digitalMarketingService"]>



  export type DigitalMarketingServiceSelectScalar = {
    id?: boolean
    service?: boolean
    price?: boolean
    digitalMarketingDetailId?: boolean
  }

  export type DigitalMarketingServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "service" | "price" | "digitalMarketingDetailId", ExtArgs["result"]["digitalMarketingService"]>
  export type DigitalMarketingServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    digitalMarketingDetail?: boolean | DigitalMarketingDetailDefaultArgs<ExtArgs>
  }

  export type $DigitalMarketingServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DigitalMarketingService"
    objects: {
      digitalMarketingDetail: Prisma.$DigitalMarketingDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      service: string
      price: number
      digitalMarketingDetailId: number
    }, ExtArgs["result"]["digitalMarketingService"]>
    composites: {}
  }

  type DigitalMarketingServiceGetPayload<S extends boolean | null | undefined | DigitalMarketingServiceDefaultArgs> = $Result.GetResult<Prisma.$DigitalMarketingServicePayload, S>

  type DigitalMarketingServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DigitalMarketingServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DigitalMarketingServiceCountAggregateInputType | true
    }

  export interface DigitalMarketingServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DigitalMarketingService'], meta: { name: 'DigitalMarketingService' } }
    /**
     * Find zero or one DigitalMarketingService that matches the filter.
     * @param {DigitalMarketingServiceFindUniqueArgs} args - Arguments to find a DigitalMarketingService
     * @example
     * // Get one DigitalMarketingService
     * const digitalMarketingService = await prisma.digitalMarketingService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DigitalMarketingServiceFindUniqueArgs>(args: SelectSubset<T, DigitalMarketingServiceFindUniqueArgs<ExtArgs>>): Prisma__DigitalMarketingServiceClient<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DigitalMarketingService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DigitalMarketingServiceFindUniqueOrThrowArgs} args - Arguments to find a DigitalMarketingService
     * @example
     * // Get one DigitalMarketingService
     * const digitalMarketingService = await prisma.digitalMarketingService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DigitalMarketingServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, DigitalMarketingServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DigitalMarketingServiceClient<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DigitalMarketingService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingServiceFindFirstArgs} args - Arguments to find a DigitalMarketingService
     * @example
     * // Get one DigitalMarketingService
     * const digitalMarketingService = await prisma.digitalMarketingService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DigitalMarketingServiceFindFirstArgs>(args?: SelectSubset<T, DigitalMarketingServiceFindFirstArgs<ExtArgs>>): Prisma__DigitalMarketingServiceClient<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DigitalMarketingService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingServiceFindFirstOrThrowArgs} args - Arguments to find a DigitalMarketingService
     * @example
     * // Get one DigitalMarketingService
     * const digitalMarketingService = await prisma.digitalMarketingService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DigitalMarketingServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, DigitalMarketingServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DigitalMarketingServiceClient<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DigitalMarketingServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DigitalMarketingServices
     * const digitalMarketingServices = await prisma.digitalMarketingService.findMany()
     * 
     * // Get first 10 DigitalMarketingServices
     * const digitalMarketingServices = await prisma.digitalMarketingService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const digitalMarketingServiceWithIdOnly = await prisma.digitalMarketingService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DigitalMarketingServiceFindManyArgs>(args?: SelectSubset<T, DigitalMarketingServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DigitalMarketingService.
     * @param {DigitalMarketingServiceCreateArgs} args - Arguments to create a DigitalMarketingService.
     * @example
     * // Create one DigitalMarketingService
     * const DigitalMarketingService = await prisma.digitalMarketingService.create({
     *   data: {
     *     // ... data to create a DigitalMarketingService
     *   }
     * })
     * 
     */
    create<T extends DigitalMarketingServiceCreateArgs>(args: SelectSubset<T, DigitalMarketingServiceCreateArgs<ExtArgs>>): Prisma__DigitalMarketingServiceClient<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DigitalMarketingServices.
     * @param {DigitalMarketingServiceCreateManyArgs} args - Arguments to create many DigitalMarketingServices.
     * @example
     * // Create many DigitalMarketingServices
     * const digitalMarketingService = await prisma.digitalMarketingService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DigitalMarketingServiceCreateManyArgs>(args?: SelectSubset<T, DigitalMarketingServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DigitalMarketingService.
     * @param {DigitalMarketingServiceDeleteArgs} args - Arguments to delete one DigitalMarketingService.
     * @example
     * // Delete one DigitalMarketingService
     * const DigitalMarketingService = await prisma.digitalMarketingService.delete({
     *   where: {
     *     // ... filter to delete one DigitalMarketingService
     *   }
     * })
     * 
     */
    delete<T extends DigitalMarketingServiceDeleteArgs>(args: SelectSubset<T, DigitalMarketingServiceDeleteArgs<ExtArgs>>): Prisma__DigitalMarketingServiceClient<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DigitalMarketingService.
     * @param {DigitalMarketingServiceUpdateArgs} args - Arguments to update one DigitalMarketingService.
     * @example
     * // Update one DigitalMarketingService
     * const digitalMarketingService = await prisma.digitalMarketingService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DigitalMarketingServiceUpdateArgs>(args: SelectSubset<T, DigitalMarketingServiceUpdateArgs<ExtArgs>>): Prisma__DigitalMarketingServiceClient<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DigitalMarketingServices.
     * @param {DigitalMarketingServiceDeleteManyArgs} args - Arguments to filter DigitalMarketingServices to delete.
     * @example
     * // Delete a few DigitalMarketingServices
     * const { count } = await prisma.digitalMarketingService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DigitalMarketingServiceDeleteManyArgs>(args?: SelectSubset<T, DigitalMarketingServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DigitalMarketingServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DigitalMarketingServices
     * const digitalMarketingService = await prisma.digitalMarketingService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DigitalMarketingServiceUpdateManyArgs>(args: SelectSubset<T, DigitalMarketingServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DigitalMarketingService.
     * @param {DigitalMarketingServiceUpsertArgs} args - Arguments to update or create a DigitalMarketingService.
     * @example
     * // Update or create a DigitalMarketingService
     * const digitalMarketingService = await prisma.digitalMarketingService.upsert({
     *   create: {
     *     // ... data to create a DigitalMarketingService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DigitalMarketingService we want to update
     *   }
     * })
     */
    upsert<T extends DigitalMarketingServiceUpsertArgs>(args: SelectSubset<T, DigitalMarketingServiceUpsertArgs<ExtArgs>>): Prisma__DigitalMarketingServiceClient<$Result.GetResult<Prisma.$DigitalMarketingServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DigitalMarketingServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingServiceCountArgs} args - Arguments to filter DigitalMarketingServices to count.
     * @example
     * // Count the number of DigitalMarketingServices
     * const count = await prisma.digitalMarketingService.count({
     *   where: {
     *     // ... the filter for the DigitalMarketingServices we want to count
     *   }
     * })
    **/
    count<T extends DigitalMarketingServiceCountArgs>(
      args?: Subset<T, DigitalMarketingServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DigitalMarketingServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DigitalMarketingService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DigitalMarketingServiceAggregateArgs>(args: Subset<T, DigitalMarketingServiceAggregateArgs>): Prisma.PrismaPromise<GetDigitalMarketingServiceAggregateType<T>>

    /**
     * Group by DigitalMarketingService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalMarketingServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DigitalMarketingServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DigitalMarketingServiceGroupByArgs['orderBy'] }
        : { orderBy?: DigitalMarketingServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DigitalMarketingServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDigitalMarketingServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DigitalMarketingService model
   */
  readonly fields: DigitalMarketingServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DigitalMarketingService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DigitalMarketingServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    digitalMarketingDetail<T extends DigitalMarketingDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DigitalMarketingDetailDefaultArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DigitalMarketingService model
   */
  interface DigitalMarketingServiceFieldRefs {
    readonly id: FieldRef<"DigitalMarketingService", 'Int'>
    readonly service: FieldRef<"DigitalMarketingService", 'String'>
    readonly price: FieldRef<"DigitalMarketingService", 'Float'>
    readonly digitalMarketingDetailId: FieldRef<"DigitalMarketingService", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DigitalMarketingService findUnique
   */
  export type DigitalMarketingServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingService to fetch.
     */
    where: DigitalMarketingServiceWhereUniqueInput
  }

  /**
   * DigitalMarketingService findUniqueOrThrow
   */
  export type DigitalMarketingServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingService to fetch.
     */
    where: DigitalMarketingServiceWhereUniqueInput
  }

  /**
   * DigitalMarketingService findFirst
   */
  export type DigitalMarketingServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingService to fetch.
     */
    where?: DigitalMarketingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalMarketingServices to fetch.
     */
    orderBy?: DigitalMarketingServiceOrderByWithRelationInput | DigitalMarketingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalMarketingServices.
     */
    cursor?: DigitalMarketingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalMarketingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalMarketingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalMarketingServices.
     */
    distinct?: DigitalMarketingServiceScalarFieldEnum | DigitalMarketingServiceScalarFieldEnum[]
  }

  /**
   * DigitalMarketingService findFirstOrThrow
   */
  export type DigitalMarketingServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingService to fetch.
     */
    where?: DigitalMarketingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalMarketingServices to fetch.
     */
    orderBy?: DigitalMarketingServiceOrderByWithRelationInput | DigitalMarketingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalMarketingServices.
     */
    cursor?: DigitalMarketingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalMarketingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalMarketingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalMarketingServices.
     */
    distinct?: DigitalMarketingServiceScalarFieldEnum | DigitalMarketingServiceScalarFieldEnum[]
  }

  /**
   * DigitalMarketingService findMany
   */
  export type DigitalMarketingServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    /**
     * Filter, which DigitalMarketingServices to fetch.
     */
    where?: DigitalMarketingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalMarketingServices to fetch.
     */
    orderBy?: DigitalMarketingServiceOrderByWithRelationInput | DigitalMarketingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DigitalMarketingServices.
     */
    cursor?: DigitalMarketingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalMarketingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalMarketingServices.
     */
    skip?: number
    distinct?: DigitalMarketingServiceScalarFieldEnum | DigitalMarketingServiceScalarFieldEnum[]
  }

  /**
   * DigitalMarketingService create
   */
  export type DigitalMarketingServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a DigitalMarketingService.
     */
    data: XOR<DigitalMarketingServiceCreateInput, DigitalMarketingServiceUncheckedCreateInput>
  }

  /**
   * DigitalMarketingService createMany
   */
  export type DigitalMarketingServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DigitalMarketingServices.
     */
    data: DigitalMarketingServiceCreateManyInput | DigitalMarketingServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DigitalMarketingService update
   */
  export type DigitalMarketingServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a DigitalMarketingService.
     */
    data: XOR<DigitalMarketingServiceUpdateInput, DigitalMarketingServiceUncheckedUpdateInput>
    /**
     * Choose, which DigitalMarketingService to update.
     */
    where: DigitalMarketingServiceWhereUniqueInput
  }

  /**
   * DigitalMarketingService updateMany
   */
  export type DigitalMarketingServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DigitalMarketingServices.
     */
    data: XOR<DigitalMarketingServiceUpdateManyMutationInput, DigitalMarketingServiceUncheckedUpdateManyInput>
    /**
     * Filter which DigitalMarketingServices to update
     */
    where?: DigitalMarketingServiceWhereInput
    /**
     * Limit how many DigitalMarketingServices to update.
     */
    limit?: number
  }

  /**
   * DigitalMarketingService upsert
   */
  export type DigitalMarketingServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the DigitalMarketingService to update in case it exists.
     */
    where: DigitalMarketingServiceWhereUniqueInput
    /**
     * In case the DigitalMarketingService found by the `where` argument doesn't exist, create a new DigitalMarketingService with this data.
     */
    create: XOR<DigitalMarketingServiceCreateInput, DigitalMarketingServiceUncheckedCreateInput>
    /**
     * In case the DigitalMarketingService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DigitalMarketingServiceUpdateInput, DigitalMarketingServiceUncheckedUpdateInput>
  }

  /**
   * DigitalMarketingService delete
   */
  export type DigitalMarketingServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
    /**
     * Filter which DigitalMarketingService to delete.
     */
    where: DigitalMarketingServiceWhereUniqueInput
  }

  /**
   * DigitalMarketingService deleteMany
   */
  export type DigitalMarketingServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalMarketingServices to delete
     */
    where?: DigitalMarketingServiceWhereInput
    /**
     * Limit how many DigitalMarketingServices to delete.
     */
    limit?: number
  }

  /**
   * DigitalMarketingService without action
   */
  export type DigitalMarketingServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalMarketingService
     */
    select?: DigitalMarketingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DigitalMarketingService
     */
    omit?: DigitalMarketingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DigitalMarketingServiceInclude<ExtArgs> | null
  }


  /**
   * Model SocialPlatform
   */

  export type AggregateSocialPlatform = {
    _count: SocialPlatformCountAggregateOutputType | null
    _avg: SocialPlatformAvgAggregateOutputType | null
    _sum: SocialPlatformSumAggregateOutputType | null
    _min: SocialPlatformMinAggregateOutputType | null
    _max: SocialPlatformMaxAggregateOutputType | null
  }

  export type SocialPlatformAvgAggregateOutputType = {
    id: number | null
    price: number | null
    digitalMarketingDetailId: number | null
  }

  export type SocialPlatformSumAggregateOutputType = {
    id: number | null
    price: number | null
    digitalMarketingDetailId: number | null
  }

  export type SocialPlatformMinAggregateOutputType = {
    id: number | null
    platform: string | null
    price: number | null
    digitalMarketingDetailId: number | null
  }

  export type SocialPlatformMaxAggregateOutputType = {
    id: number | null
    platform: string | null
    price: number | null
    digitalMarketingDetailId: number | null
  }

  export type SocialPlatformCountAggregateOutputType = {
    id: number
    platform: number
    price: number
    digitalMarketingDetailId: number
    _all: number
  }


  export type SocialPlatformAvgAggregateInputType = {
    id?: true
    price?: true
    digitalMarketingDetailId?: true
  }

  export type SocialPlatformSumAggregateInputType = {
    id?: true
    price?: true
    digitalMarketingDetailId?: true
  }

  export type SocialPlatformMinAggregateInputType = {
    id?: true
    platform?: true
    price?: true
    digitalMarketingDetailId?: true
  }

  export type SocialPlatformMaxAggregateInputType = {
    id?: true
    platform?: true
    price?: true
    digitalMarketingDetailId?: true
  }

  export type SocialPlatformCountAggregateInputType = {
    id?: true
    platform?: true
    price?: true
    digitalMarketingDetailId?: true
    _all?: true
  }

  export type SocialPlatformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialPlatform to aggregate.
     */
    where?: SocialPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPlatforms to fetch.
     */
    orderBy?: SocialPlatformOrderByWithRelationInput | SocialPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPlatforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialPlatforms
    **/
    _count?: true | SocialPlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialPlatformAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialPlatformSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialPlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialPlatformMaxAggregateInputType
  }

  export type GetSocialPlatformAggregateType<T extends SocialPlatformAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialPlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialPlatform[P]>
      : GetScalarType<T[P], AggregateSocialPlatform[P]>
  }




  export type SocialPlatformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialPlatformWhereInput
    orderBy?: SocialPlatformOrderByWithAggregationInput | SocialPlatformOrderByWithAggregationInput[]
    by: SocialPlatformScalarFieldEnum[] | SocialPlatformScalarFieldEnum
    having?: SocialPlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialPlatformCountAggregateInputType | true
    _avg?: SocialPlatformAvgAggregateInputType
    _sum?: SocialPlatformSumAggregateInputType
    _min?: SocialPlatformMinAggregateInputType
    _max?: SocialPlatformMaxAggregateInputType
  }

  export type SocialPlatformGroupByOutputType = {
    id: number
    platform: string
    price: number
    digitalMarketingDetailId: number
    _count: SocialPlatformCountAggregateOutputType | null
    _avg: SocialPlatformAvgAggregateOutputType | null
    _sum: SocialPlatformSumAggregateOutputType | null
    _min: SocialPlatformMinAggregateOutputType | null
    _max: SocialPlatformMaxAggregateOutputType | null
  }

  type GetSocialPlatformGroupByPayload<T extends SocialPlatformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialPlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialPlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialPlatformGroupByOutputType[P]>
            : GetScalarType<T[P], SocialPlatformGroupByOutputType[P]>
        }
      >
    >


  export type SocialPlatformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    price?: boolean
    digitalMarketingDetailId?: boolean
    digitalMarketingDetail?: boolean | DigitalMarketingDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialPlatform"]>



  export type SocialPlatformSelectScalar = {
    id?: boolean
    platform?: boolean
    price?: boolean
    digitalMarketingDetailId?: boolean
  }

  export type SocialPlatformOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "price" | "digitalMarketingDetailId", ExtArgs["result"]["socialPlatform"]>
  export type SocialPlatformInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    digitalMarketingDetail?: boolean | DigitalMarketingDetailDefaultArgs<ExtArgs>
  }

  export type $SocialPlatformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialPlatform"
    objects: {
      digitalMarketingDetail: Prisma.$DigitalMarketingDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      platform: string
      price: number
      digitalMarketingDetailId: number
    }, ExtArgs["result"]["socialPlatform"]>
    composites: {}
  }

  type SocialPlatformGetPayload<S extends boolean | null | undefined | SocialPlatformDefaultArgs> = $Result.GetResult<Prisma.$SocialPlatformPayload, S>

  type SocialPlatformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialPlatformFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialPlatformCountAggregateInputType | true
    }

  export interface SocialPlatformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialPlatform'], meta: { name: 'SocialPlatform' } }
    /**
     * Find zero or one SocialPlatform that matches the filter.
     * @param {SocialPlatformFindUniqueArgs} args - Arguments to find a SocialPlatform
     * @example
     * // Get one SocialPlatform
     * const socialPlatform = await prisma.socialPlatform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialPlatformFindUniqueArgs>(args: SelectSubset<T, SocialPlatformFindUniqueArgs<ExtArgs>>): Prisma__SocialPlatformClient<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialPlatform that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialPlatformFindUniqueOrThrowArgs} args - Arguments to find a SocialPlatform
     * @example
     * // Get one SocialPlatform
     * const socialPlatform = await prisma.socialPlatform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialPlatformFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialPlatformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialPlatformClient<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialPlatform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPlatformFindFirstArgs} args - Arguments to find a SocialPlatform
     * @example
     * // Get one SocialPlatform
     * const socialPlatform = await prisma.socialPlatform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialPlatformFindFirstArgs>(args?: SelectSubset<T, SocialPlatformFindFirstArgs<ExtArgs>>): Prisma__SocialPlatformClient<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialPlatform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPlatformFindFirstOrThrowArgs} args - Arguments to find a SocialPlatform
     * @example
     * // Get one SocialPlatform
     * const socialPlatform = await prisma.socialPlatform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialPlatformFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialPlatformFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialPlatformClient<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialPlatforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPlatformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialPlatforms
     * const socialPlatforms = await prisma.socialPlatform.findMany()
     * 
     * // Get first 10 SocialPlatforms
     * const socialPlatforms = await prisma.socialPlatform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialPlatformWithIdOnly = await prisma.socialPlatform.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialPlatformFindManyArgs>(args?: SelectSubset<T, SocialPlatformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialPlatform.
     * @param {SocialPlatformCreateArgs} args - Arguments to create a SocialPlatform.
     * @example
     * // Create one SocialPlatform
     * const SocialPlatform = await prisma.socialPlatform.create({
     *   data: {
     *     // ... data to create a SocialPlatform
     *   }
     * })
     * 
     */
    create<T extends SocialPlatformCreateArgs>(args: SelectSubset<T, SocialPlatformCreateArgs<ExtArgs>>): Prisma__SocialPlatformClient<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialPlatforms.
     * @param {SocialPlatformCreateManyArgs} args - Arguments to create many SocialPlatforms.
     * @example
     * // Create many SocialPlatforms
     * const socialPlatform = await prisma.socialPlatform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialPlatformCreateManyArgs>(args?: SelectSubset<T, SocialPlatformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialPlatform.
     * @param {SocialPlatformDeleteArgs} args - Arguments to delete one SocialPlatform.
     * @example
     * // Delete one SocialPlatform
     * const SocialPlatform = await prisma.socialPlatform.delete({
     *   where: {
     *     // ... filter to delete one SocialPlatform
     *   }
     * })
     * 
     */
    delete<T extends SocialPlatformDeleteArgs>(args: SelectSubset<T, SocialPlatformDeleteArgs<ExtArgs>>): Prisma__SocialPlatformClient<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialPlatform.
     * @param {SocialPlatformUpdateArgs} args - Arguments to update one SocialPlatform.
     * @example
     * // Update one SocialPlatform
     * const socialPlatform = await prisma.socialPlatform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialPlatformUpdateArgs>(args: SelectSubset<T, SocialPlatformUpdateArgs<ExtArgs>>): Prisma__SocialPlatformClient<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialPlatforms.
     * @param {SocialPlatformDeleteManyArgs} args - Arguments to filter SocialPlatforms to delete.
     * @example
     * // Delete a few SocialPlatforms
     * const { count } = await prisma.socialPlatform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialPlatformDeleteManyArgs>(args?: SelectSubset<T, SocialPlatformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialPlatforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialPlatforms
     * const socialPlatform = await prisma.socialPlatform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialPlatformUpdateManyArgs>(args: SelectSubset<T, SocialPlatformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialPlatform.
     * @param {SocialPlatformUpsertArgs} args - Arguments to update or create a SocialPlatform.
     * @example
     * // Update or create a SocialPlatform
     * const socialPlatform = await prisma.socialPlatform.upsert({
     *   create: {
     *     // ... data to create a SocialPlatform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialPlatform we want to update
     *   }
     * })
     */
    upsert<T extends SocialPlatformUpsertArgs>(args: SelectSubset<T, SocialPlatformUpsertArgs<ExtArgs>>): Prisma__SocialPlatformClient<$Result.GetResult<Prisma.$SocialPlatformPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialPlatforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPlatformCountArgs} args - Arguments to filter SocialPlatforms to count.
     * @example
     * // Count the number of SocialPlatforms
     * const count = await prisma.socialPlatform.count({
     *   where: {
     *     // ... the filter for the SocialPlatforms we want to count
     *   }
     * })
    **/
    count<T extends SocialPlatformCountArgs>(
      args?: Subset<T, SocialPlatformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialPlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialPlatform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialPlatformAggregateArgs>(args: Subset<T, SocialPlatformAggregateArgs>): Prisma.PrismaPromise<GetSocialPlatformAggregateType<T>>

    /**
     * Group by SocialPlatform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialPlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialPlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialPlatformGroupByArgs['orderBy'] }
        : { orderBy?: SocialPlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialPlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialPlatformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialPlatform model
   */
  readonly fields: SocialPlatformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialPlatform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialPlatformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    digitalMarketingDetail<T extends DigitalMarketingDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DigitalMarketingDetailDefaultArgs<ExtArgs>>): Prisma__DigitalMarketingDetailClient<$Result.GetResult<Prisma.$DigitalMarketingDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialPlatform model
   */
  interface SocialPlatformFieldRefs {
    readonly id: FieldRef<"SocialPlatform", 'Int'>
    readonly platform: FieldRef<"SocialPlatform", 'String'>
    readonly price: FieldRef<"SocialPlatform", 'Float'>
    readonly digitalMarketingDetailId: FieldRef<"SocialPlatform", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SocialPlatform findUnique
   */
  export type SocialPlatformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    /**
     * Filter, which SocialPlatform to fetch.
     */
    where: SocialPlatformWhereUniqueInput
  }

  /**
   * SocialPlatform findUniqueOrThrow
   */
  export type SocialPlatformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    /**
     * Filter, which SocialPlatform to fetch.
     */
    where: SocialPlatformWhereUniqueInput
  }

  /**
   * SocialPlatform findFirst
   */
  export type SocialPlatformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    /**
     * Filter, which SocialPlatform to fetch.
     */
    where?: SocialPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPlatforms to fetch.
     */
    orderBy?: SocialPlatformOrderByWithRelationInput | SocialPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialPlatforms.
     */
    cursor?: SocialPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPlatforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialPlatforms.
     */
    distinct?: SocialPlatformScalarFieldEnum | SocialPlatformScalarFieldEnum[]
  }

  /**
   * SocialPlatform findFirstOrThrow
   */
  export type SocialPlatformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    /**
     * Filter, which SocialPlatform to fetch.
     */
    where?: SocialPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPlatforms to fetch.
     */
    orderBy?: SocialPlatformOrderByWithRelationInput | SocialPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialPlatforms.
     */
    cursor?: SocialPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPlatforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialPlatforms.
     */
    distinct?: SocialPlatformScalarFieldEnum | SocialPlatformScalarFieldEnum[]
  }

  /**
   * SocialPlatform findMany
   */
  export type SocialPlatformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    /**
     * Filter, which SocialPlatforms to fetch.
     */
    where?: SocialPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialPlatforms to fetch.
     */
    orderBy?: SocialPlatformOrderByWithRelationInput | SocialPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialPlatforms.
     */
    cursor?: SocialPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialPlatforms.
     */
    skip?: number
    distinct?: SocialPlatformScalarFieldEnum | SocialPlatformScalarFieldEnum[]
  }

  /**
   * SocialPlatform create
   */
  export type SocialPlatformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialPlatform.
     */
    data: XOR<SocialPlatformCreateInput, SocialPlatformUncheckedCreateInput>
  }

  /**
   * SocialPlatform createMany
   */
  export type SocialPlatformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialPlatforms.
     */
    data: SocialPlatformCreateManyInput | SocialPlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialPlatform update
   */
  export type SocialPlatformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialPlatform.
     */
    data: XOR<SocialPlatformUpdateInput, SocialPlatformUncheckedUpdateInput>
    /**
     * Choose, which SocialPlatform to update.
     */
    where: SocialPlatformWhereUniqueInput
  }

  /**
   * SocialPlatform updateMany
   */
  export type SocialPlatformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialPlatforms.
     */
    data: XOR<SocialPlatformUpdateManyMutationInput, SocialPlatformUncheckedUpdateManyInput>
    /**
     * Filter which SocialPlatforms to update
     */
    where?: SocialPlatformWhereInput
    /**
     * Limit how many SocialPlatforms to update.
     */
    limit?: number
  }

  /**
   * SocialPlatform upsert
   */
  export type SocialPlatformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialPlatform to update in case it exists.
     */
    where: SocialPlatformWhereUniqueInput
    /**
     * In case the SocialPlatform found by the `where` argument doesn't exist, create a new SocialPlatform with this data.
     */
    create: XOR<SocialPlatformCreateInput, SocialPlatformUncheckedCreateInput>
    /**
     * In case the SocialPlatform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialPlatformUpdateInput, SocialPlatformUncheckedUpdateInput>
  }

  /**
   * SocialPlatform delete
   */
  export type SocialPlatformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
    /**
     * Filter which SocialPlatform to delete.
     */
    where: SocialPlatformWhereUniqueInput
  }

  /**
   * SocialPlatform deleteMany
   */
  export type SocialPlatformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialPlatforms to delete
     */
    where?: SocialPlatformWhereInput
    /**
     * Limit how many SocialPlatforms to delete.
     */
    limit?: number
  }

  /**
   * SocialPlatform without action
   */
  export type SocialPlatformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialPlatform
     */
    select?: SocialPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialPlatform
     */
    omit?: SocialPlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialPlatformInclude<ExtArgs> | null
  }


  /**
   * Model ContentGenerationDetail
   */

  export type AggregateContentGenerationDetail = {
    _count: ContentGenerationDetailCountAggregateOutputType | null
    _avg: ContentGenerationDetailAvgAggregateOutputType | null
    _sum: ContentGenerationDetailSumAggregateOutputType | null
    _min: ContentGenerationDetailMinAggregateOutputType | null
    _max: ContentGenerationDetailMaxAggregateOutputType | null
  }

  export type ContentGenerationDetailAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ContentGenerationDetailSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ContentGenerationDetailMinAggregateOutputType = {
    id: number | null
    volume: string | null
    contentTone: string | null
    targetKeywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ContentGenerationDetailMaxAggregateOutputType = {
    id: number | null
    volume: string | null
    contentTone: string | null
    targetKeywords: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ContentGenerationDetailCountAggregateOutputType = {
    id: number
    volume: number
    contentTone: number
    targetKeywords: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type ContentGenerationDetailAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ContentGenerationDetailSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ContentGenerationDetailMinAggregateInputType = {
    id?: true
    volume?: true
    contentTone?: true
    targetKeywords?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ContentGenerationDetailMaxAggregateInputType = {
    id?: true
    volume?: true
    contentTone?: true
    targetKeywords?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ContentGenerationDetailCountAggregateInputType = {
    id?: true
    volume?: true
    contentTone?: true
    targetKeywords?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type ContentGenerationDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentGenerationDetail to aggregate.
     */
    where?: ContentGenerationDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGenerationDetails to fetch.
     */
    orderBy?: ContentGenerationDetailOrderByWithRelationInput | ContentGenerationDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentGenerationDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGenerationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGenerationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentGenerationDetails
    **/
    _count?: true | ContentGenerationDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentGenerationDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentGenerationDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentGenerationDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentGenerationDetailMaxAggregateInputType
  }

  export type GetContentGenerationDetailAggregateType<T extends ContentGenerationDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateContentGenerationDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentGenerationDetail[P]>
      : GetScalarType<T[P], AggregateContentGenerationDetail[P]>
  }




  export type ContentGenerationDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentGenerationDetailWhereInput
    orderBy?: ContentGenerationDetailOrderByWithAggregationInput | ContentGenerationDetailOrderByWithAggregationInput[]
    by: ContentGenerationDetailScalarFieldEnum[] | ContentGenerationDetailScalarFieldEnum
    having?: ContentGenerationDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentGenerationDetailCountAggregateInputType | true
    _avg?: ContentGenerationDetailAvgAggregateInputType
    _sum?: ContentGenerationDetailSumAggregateInputType
    _min?: ContentGenerationDetailMinAggregateInputType
    _max?: ContentGenerationDetailMaxAggregateInputType
  }

  export type ContentGenerationDetailGroupByOutputType = {
    id: number
    volume: string | null
    contentTone: string | null
    targetKeywords: string | null
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: ContentGenerationDetailCountAggregateOutputType | null
    _avg: ContentGenerationDetailAvgAggregateOutputType | null
    _sum: ContentGenerationDetailSumAggregateOutputType | null
    _min: ContentGenerationDetailMinAggregateOutputType | null
    _max: ContentGenerationDetailMaxAggregateOutputType | null
  }

  type GetContentGenerationDetailGroupByPayload<T extends ContentGenerationDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGenerationDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGenerationDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGenerationDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGenerationDetailGroupByOutputType[P]>
        }
      >
    >


  export type ContentGenerationDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volume?: boolean
    contentTone?: boolean
    targetKeywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    contentTypes?: boolean | ContentGenerationDetail$contentTypesArgs<ExtArgs>
    contentLanguages?: boolean | ContentGenerationDetail$contentLanguagesArgs<ExtArgs>
    _count?: boolean | ContentGenerationDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentGenerationDetail"]>



  export type ContentGenerationDetailSelectScalar = {
    id?: boolean
    volume?: boolean
    contentTone?: boolean
    targetKeywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type ContentGenerationDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "volume" | "contentTone" | "targetKeywords" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["contentGenerationDetail"]>
  export type ContentGenerationDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    contentTypes?: boolean | ContentGenerationDetail$contentTypesArgs<ExtArgs>
    contentLanguages?: boolean | ContentGenerationDetail$contentLanguagesArgs<ExtArgs>
    _count?: boolean | ContentGenerationDetailCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContentGenerationDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentGenerationDetail"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      contentTypes: Prisma.$ContentTypePayload<ExtArgs>[]
      contentLanguages: Prisma.$ContentLanguagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      volume: string | null
      contentTone: string | null
      targetKeywords: string | null
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["contentGenerationDetail"]>
    composites: {}
  }

  type ContentGenerationDetailGetPayload<S extends boolean | null | undefined | ContentGenerationDetailDefaultArgs> = $Result.GetResult<Prisma.$ContentGenerationDetailPayload, S>

  type ContentGenerationDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentGenerationDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentGenerationDetailCountAggregateInputType | true
    }

  export interface ContentGenerationDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentGenerationDetail'], meta: { name: 'ContentGenerationDetail' } }
    /**
     * Find zero or one ContentGenerationDetail that matches the filter.
     * @param {ContentGenerationDetailFindUniqueArgs} args - Arguments to find a ContentGenerationDetail
     * @example
     * // Get one ContentGenerationDetail
     * const contentGenerationDetail = await prisma.contentGenerationDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentGenerationDetailFindUniqueArgs>(args: SelectSubset<T, ContentGenerationDetailFindUniqueArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentGenerationDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentGenerationDetailFindUniqueOrThrowArgs} args - Arguments to find a ContentGenerationDetail
     * @example
     * // Get one ContentGenerationDetail
     * const contentGenerationDetail = await prisma.contentGenerationDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentGenerationDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentGenerationDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentGenerationDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGenerationDetailFindFirstArgs} args - Arguments to find a ContentGenerationDetail
     * @example
     * // Get one ContentGenerationDetail
     * const contentGenerationDetail = await prisma.contentGenerationDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentGenerationDetailFindFirstArgs>(args?: SelectSubset<T, ContentGenerationDetailFindFirstArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentGenerationDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGenerationDetailFindFirstOrThrowArgs} args - Arguments to find a ContentGenerationDetail
     * @example
     * // Get one ContentGenerationDetail
     * const contentGenerationDetail = await prisma.contentGenerationDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentGenerationDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentGenerationDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentGenerationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGenerationDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentGenerationDetails
     * const contentGenerationDetails = await prisma.contentGenerationDetail.findMany()
     * 
     * // Get first 10 ContentGenerationDetails
     * const contentGenerationDetails = await prisma.contentGenerationDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentGenerationDetailWithIdOnly = await prisma.contentGenerationDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentGenerationDetailFindManyArgs>(args?: SelectSubset<T, ContentGenerationDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentGenerationDetail.
     * @param {ContentGenerationDetailCreateArgs} args - Arguments to create a ContentGenerationDetail.
     * @example
     * // Create one ContentGenerationDetail
     * const ContentGenerationDetail = await prisma.contentGenerationDetail.create({
     *   data: {
     *     // ... data to create a ContentGenerationDetail
     *   }
     * })
     * 
     */
    create<T extends ContentGenerationDetailCreateArgs>(args: SelectSubset<T, ContentGenerationDetailCreateArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentGenerationDetails.
     * @param {ContentGenerationDetailCreateManyArgs} args - Arguments to create many ContentGenerationDetails.
     * @example
     * // Create many ContentGenerationDetails
     * const contentGenerationDetail = await prisma.contentGenerationDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentGenerationDetailCreateManyArgs>(args?: SelectSubset<T, ContentGenerationDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContentGenerationDetail.
     * @param {ContentGenerationDetailDeleteArgs} args - Arguments to delete one ContentGenerationDetail.
     * @example
     * // Delete one ContentGenerationDetail
     * const ContentGenerationDetail = await prisma.contentGenerationDetail.delete({
     *   where: {
     *     // ... filter to delete one ContentGenerationDetail
     *   }
     * })
     * 
     */
    delete<T extends ContentGenerationDetailDeleteArgs>(args: SelectSubset<T, ContentGenerationDetailDeleteArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentGenerationDetail.
     * @param {ContentGenerationDetailUpdateArgs} args - Arguments to update one ContentGenerationDetail.
     * @example
     * // Update one ContentGenerationDetail
     * const contentGenerationDetail = await prisma.contentGenerationDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentGenerationDetailUpdateArgs>(args: SelectSubset<T, ContentGenerationDetailUpdateArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentGenerationDetails.
     * @param {ContentGenerationDetailDeleteManyArgs} args - Arguments to filter ContentGenerationDetails to delete.
     * @example
     * // Delete a few ContentGenerationDetails
     * const { count } = await prisma.contentGenerationDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentGenerationDetailDeleteManyArgs>(args?: SelectSubset<T, ContentGenerationDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentGenerationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGenerationDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentGenerationDetails
     * const contentGenerationDetail = await prisma.contentGenerationDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentGenerationDetailUpdateManyArgs>(args: SelectSubset<T, ContentGenerationDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentGenerationDetail.
     * @param {ContentGenerationDetailUpsertArgs} args - Arguments to update or create a ContentGenerationDetail.
     * @example
     * // Update or create a ContentGenerationDetail
     * const contentGenerationDetail = await prisma.contentGenerationDetail.upsert({
     *   create: {
     *     // ... data to create a ContentGenerationDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentGenerationDetail we want to update
     *   }
     * })
     */
    upsert<T extends ContentGenerationDetailUpsertArgs>(args: SelectSubset<T, ContentGenerationDetailUpsertArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentGenerationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGenerationDetailCountArgs} args - Arguments to filter ContentGenerationDetails to count.
     * @example
     * // Count the number of ContentGenerationDetails
     * const count = await prisma.contentGenerationDetail.count({
     *   where: {
     *     // ... the filter for the ContentGenerationDetails we want to count
     *   }
     * })
    **/
    count<T extends ContentGenerationDetailCountArgs>(
      args?: Subset<T, ContentGenerationDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentGenerationDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentGenerationDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGenerationDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentGenerationDetailAggregateArgs>(args: Subset<T, ContentGenerationDetailAggregateArgs>): Prisma.PrismaPromise<GetContentGenerationDetailAggregateType<T>>

    /**
     * Group by ContentGenerationDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGenerationDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGenerationDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGenerationDetailGroupByArgs['orderBy'] }
        : { orderBy?: ContentGenerationDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGenerationDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGenerationDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentGenerationDetail model
   */
  readonly fields: ContentGenerationDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentGenerationDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentGenerationDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contentTypes<T extends ContentGenerationDetail$contentTypesArgs<ExtArgs> = {}>(args?: Subset<T, ContentGenerationDetail$contentTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contentLanguages<T extends ContentGenerationDetail$contentLanguagesArgs<ExtArgs> = {}>(args?: Subset<T, ContentGenerationDetail$contentLanguagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentGenerationDetail model
   */
  interface ContentGenerationDetailFieldRefs {
    readonly id: FieldRef<"ContentGenerationDetail", 'Int'>
    readonly volume: FieldRef<"ContentGenerationDetail", 'String'>
    readonly contentTone: FieldRef<"ContentGenerationDetail", 'String'>
    readonly targetKeywords: FieldRef<"ContentGenerationDetail", 'String'>
    readonly createdAt: FieldRef<"ContentGenerationDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentGenerationDetail", 'DateTime'>
    readonly projectId: FieldRef<"ContentGenerationDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentGenerationDetail findUnique
   */
  export type ContentGenerationDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContentGenerationDetail to fetch.
     */
    where: ContentGenerationDetailWhereUniqueInput
  }

  /**
   * ContentGenerationDetail findUniqueOrThrow
   */
  export type ContentGenerationDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContentGenerationDetail to fetch.
     */
    where: ContentGenerationDetailWhereUniqueInput
  }

  /**
   * ContentGenerationDetail findFirst
   */
  export type ContentGenerationDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContentGenerationDetail to fetch.
     */
    where?: ContentGenerationDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGenerationDetails to fetch.
     */
    orderBy?: ContentGenerationDetailOrderByWithRelationInput | ContentGenerationDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentGenerationDetails.
     */
    cursor?: ContentGenerationDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGenerationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGenerationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentGenerationDetails.
     */
    distinct?: ContentGenerationDetailScalarFieldEnum | ContentGenerationDetailScalarFieldEnum[]
  }

  /**
   * ContentGenerationDetail findFirstOrThrow
   */
  export type ContentGenerationDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContentGenerationDetail to fetch.
     */
    where?: ContentGenerationDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGenerationDetails to fetch.
     */
    orderBy?: ContentGenerationDetailOrderByWithRelationInput | ContentGenerationDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentGenerationDetails.
     */
    cursor?: ContentGenerationDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGenerationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGenerationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentGenerationDetails.
     */
    distinct?: ContentGenerationDetailScalarFieldEnum | ContentGenerationDetailScalarFieldEnum[]
  }

  /**
   * ContentGenerationDetail findMany
   */
  export type ContentGenerationDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    /**
     * Filter, which ContentGenerationDetails to fetch.
     */
    where?: ContentGenerationDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentGenerationDetails to fetch.
     */
    orderBy?: ContentGenerationDetailOrderByWithRelationInput | ContentGenerationDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentGenerationDetails.
     */
    cursor?: ContentGenerationDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentGenerationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentGenerationDetails.
     */
    skip?: number
    distinct?: ContentGenerationDetailScalarFieldEnum | ContentGenerationDetailScalarFieldEnum[]
  }

  /**
   * ContentGenerationDetail create
   */
  export type ContentGenerationDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentGenerationDetail.
     */
    data: XOR<ContentGenerationDetailCreateInput, ContentGenerationDetailUncheckedCreateInput>
  }

  /**
   * ContentGenerationDetail createMany
   */
  export type ContentGenerationDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentGenerationDetails.
     */
    data: ContentGenerationDetailCreateManyInput | ContentGenerationDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentGenerationDetail update
   */
  export type ContentGenerationDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentGenerationDetail.
     */
    data: XOR<ContentGenerationDetailUpdateInput, ContentGenerationDetailUncheckedUpdateInput>
    /**
     * Choose, which ContentGenerationDetail to update.
     */
    where: ContentGenerationDetailWhereUniqueInput
  }

  /**
   * ContentGenerationDetail updateMany
   */
  export type ContentGenerationDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentGenerationDetails.
     */
    data: XOR<ContentGenerationDetailUpdateManyMutationInput, ContentGenerationDetailUncheckedUpdateManyInput>
    /**
     * Filter which ContentGenerationDetails to update
     */
    where?: ContentGenerationDetailWhereInput
    /**
     * Limit how many ContentGenerationDetails to update.
     */
    limit?: number
  }

  /**
   * ContentGenerationDetail upsert
   */
  export type ContentGenerationDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentGenerationDetail to update in case it exists.
     */
    where: ContentGenerationDetailWhereUniqueInput
    /**
     * In case the ContentGenerationDetail found by the `where` argument doesn't exist, create a new ContentGenerationDetail with this data.
     */
    create: XOR<ContentGenerationDetailCreateInput, ContentGenerationDetailUncheckedCreateInput>
    /**
     * In case the ContentGenerationDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentGenerationDetailUpdateInput, ContentGenerationDetailUncheckedUpdateInput>
  }

  /**
   * ContentGenerationDetail delete
   */
  export type ContentGenerationDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
    /**
     * Filter which ContentGenerationDetail to delete.
     */
    where: ContentGenerationDetailWhereUniqueInput
  }

  /**
   * ContentGenerationDetail deleteMany
   */
  export type ContentGenerationDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentGenerationDetails to delete
     */
    where?: ContentGenerationDetailWhereInput
    /**
     * Limit how many ContentGenerationDetails to delete.
     */
    limit?: number
  }

  /**
   * ContentGenerationDetail.contentTypes
   */
  export type ContentGenerationDetail$contentTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    where?: ContentTypeWhereInput
    orderBy?: ContentTypeOrderByWithRelationInput | ContentTypeOrderByWithRelationInput[]
    cursor?: ContentTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentTypeScalarFieldEnum | ContentTypeScalarFieldEnum[]
  }

  /**
   * ContentGenerationDetail.contentLanguages
   */
  export type ContentGenerationDetail$contentLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    where?: ContentLanguageWhereInput
    orderBy?: ContentLanguageOrderByWithRelationInput | ContentLanguageOrderByWithRelationInput[]
    cursor?: ContentLanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentLanguageScalarFieldEnum | ContentLanguageScalarFieldEnum[]
  }

  /**
   * ContentGenerationDetail without action
   */
  export type ContentGenerationDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentGenerationDetail
     */
    select?: ContentGenerationDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentGenerationDetail
     */
    omit?: ContentGenerationDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentGenerationDetailInclude<ExtArgs> | null
  }


  /**
   * Model ContentType
   */

  export type AggregateContentType = {
    _count: ContentTypeCountAggregateOutputType | null
    _avg: ContentTypeAvgAggregateOutputType | null
    _sum: ContentTypeSumAggregateOutputType | null
    _min: ContentTypeMinAggregateOutputType | null
    _max: ContentTypeMaxAggregateOutputType | null
  }

  export type ContentTypeAvgAggregateOutputType = {
    id: number | null
    price: number | null
    contentGenerationDetailId: number | null
  }

  export type ContentTypeSumAggregateOutputType = {
    id: number | null
    price: number | null
    contentGenerationDetailId: number | null
  }

  export type ContentTypeMinAggregateOutputType = {
    id: number | null
    contentType: string | null
    price: number | null
    contentGenerationDetailId: number | null
  }

  export type ContentTypeMaxAggregateOutputType = {
    id: number | null
    contentType: string | null
    price: number | null
    contentGenerationDetailId: number | null
  }

  export type ContentTypeCountAggregateOutputType = {
    id: number
    contentType: number
    price: number
    contentGenerationDetailId: number
    _all: number
  }


  export type ContentTypeAvgAggregateInputType = {
    id?: true
    price?: true
    contentGenerationDetailId?: true
  }

  export type ContentTypeSumAggregateInputType = {
    id?: true
    price?: true
    contentGenerationDetailId?: true
  }

  export type ContentTypeMinAggregateInputType = {
    id?: true
    contentType?: true
    price?: true
    contentGenerationDetailId?: true
  }

  export type ContentTypeMaxAggregateInputType = {
    id?: true
    contentType?: true
    price?: true
    contentGenerationDetailId?: true
  }

  export type ContentTypeCountAggregateInputType = {
    id?: true
    contentType?: true
    price?: true
    contentGenerationDetailId?: true
    _all?: true
  }

  export type ContentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentType to aggregate.
     */
    where?: ContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTypes to fetch.
     */
    orderBy?: ContentTypeOrderByWithRelationInput | ContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentTypes
    **/
    _count?: true | ContentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentTypeMaxAggregateInputType
  }

  export type GetContentTypeAggregateType<T extends ContentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentType[P]>
      : GetScalarType<T[P], AggregateContentType[P]>
  }




  export type ContentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentTypeWhereInput
    orderBy?: ContentTypeOrderByWithAggregationInput | ContentTypeOrderByWithAggregationInput[]
    by: ContentTypeScalarFieldEnum[] | ContentTypeScalarFieldEnum
    having?: ContentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentTypeCountAggregateInputType | true
    _avg?: ContentTypeAvgAggregateInputType
    _sum?: ContentTypeSumAggregateInputType
    _min?: ContentTypeMinAggregateInputType
    _max?: ContentTypeMaxAggregateInputType
  }

  export type ContentTypeGroupByOutputType = {
    id: number
    contentType: string
    price: number
    contentGenerationDetailId: number
    _count: ContentTypeCountAggregateOutputType | null
    _avg: ContentTypeAvgAggregateOutputType | null
    _sum: ContentTypeSumAggregateOutputType | null
    _min: ContentTypeMinAggregateOutputType | null
    _max: ContentTypeMaxAggregateOutputType | null
  }

  type GetContentTypeGroupByPayload<T extends ContentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContentTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentType?: boolean
    price?: boolean
    contentGenerationDetailId?: boolean
    contentGenerationDetail?: boolean | ContentGenerationDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentType"]>



  export type ContentTypeSelectScalar = {
    id?: boolean
    contentType?: boolean
    price?: boolean
    contentGenerationDetailId?: boolean
  }

  export type ContentTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentType" | "price" | "contentGenerationDetailId", ExtArgs["result"]["contentType"]>
  export type ContentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentGenerationDetail?: boolean | ContentGenerationDetailDefaultArgs<ExtArgs>
  }

  export type $ContentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentType"
    objects: {
      contentGenerationDetail: Prisma.$ContentGenerationDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contentType: string
      price: number
      contentGenerationDetailId: number
    }, ExtArgs["result"]["contentType"]>
    composites: {}
  }

  type ContentTypeGetPayload<S extends boolean | null | undefined | ContentTypeDefaultArgs> = $Result.GetResult<Prisma.$ContentTypePayload, S>

  type ContentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentTypeCountAggregateInputType | true
    }

  export interface ContentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentType'], meta: { name: 'ContentType' } }
    /**
     * Find zero or one ContentType that matches the filter.
     * @param {ContentTypeFindUniqueArgs} args - Arguments to find a ContentType
     * @example
     * // Get one ContentType
     * const contentType = await prisma.contentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentTypeFindUniqueArgs>(args: SelectSubset<T, ContentTypeFindUniqueArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentTypeFindUniqueOrThrowArgs} args - Arguments to find a ContentType
     * @example
     * // Get one ContentType
     * const contentType = await prisma.contentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeFindFirstArgs} args - Arguments to find a ContentType
     * @example
     * // Get one ContentType
     * const contentType = await prisma.contentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentTypeFindFirstArgs>(args?: SelectSubset<T, ContentTypeFindFirstArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeFindFirstOrThrowArgs} args - Arguments to find a ContentType
     * @example
     * // Get one ContentType
     * const contentType = await prisma.contentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentTypes
     * const contentTypes = await prisma.contentType.findMany()
     * 
     * // Get first 10 ContentTypes
     * const contentTypes = await prisma.contentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentTypeWithIdOnly = await prisma.contentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentTypeFindManyArgs>(args?: SelectSubset<T, ContentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentType.
     * @param {ContentTypeCreateArgs} args - Arguments to create a ContentType.
     * @example
     * // Create one ContentType
     * const ContentType = await prisma.contentType.create({
     *   data: {
     *     // ... data to create a ContentType
     *   }
     * })
     * 
     */
    create<T extends ContentTypeCreateArgs>(args: SelectSubset<T, ContentTypeCreateArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentTypes.
     * @param {ContentTypeCreateManyArgs} args - Arguments to create many ContentTypes.
     * @example
     * // Create many ContentTypes
     * const contentType = await prisma.contentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentTypeCreateManyArgs>(args?: SelectSubset<T, ContentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContentType.
     * @param {ContentTypeDeleteArgs} args - Arguments to delete one ContentType.
     * @example
     * // Delete one ContentType
     * const ContentType = await prisma.contentType.delete({
     *   where: {
     *     // ... filter to delete one ContentType
     *   }
     * })
     * 
     */
    delete<T extends ContentTypeDeleteArgs>(args: SelectSubset<T, ContentTypeDeleteArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentType.
     * @param {ContentTypeUpdateArgs} args - Arguments to update one ContentType.
     * @example
     * // Update one ContentType
     * const contentType = await prisma.contentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentTypeUpdateArgs>(args: SelectSubset<T, ContentTypeUpdateArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentTypes.
     * @param {ContentTypeDeleteManyArgs} args - Arguments to filter ContentTypes to delete.
     * @example
     * // Delete a few ContentTypes
     * const { count } = await prisma.contentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentTypeDeleteManyArgs>(args?: SelectSubset<T, ContentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentTypes
     * const contentType = await prisma.contentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentTypeUpdateManyArgs>(args: SelectSubset<T, ContentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentType.
     * @param {ContentTypeUpsertArgs} args - Arguments to update or create a ContentType.
     * @example
     * // Update or create a ContentType
     * const contentType = await prisma.contentType.upsert({
     *   create: {
     *     // ... data to create a ContentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentType we want to update
     *   }
     * })
     */
    upsert<T extends ContentTypeUpsertArgs>(args: SelectSubset<T, ContentTypeUpsertArgs<ExtArgs>>): Prisma__ContentTypeClient<$Result.GetResult<Prisma.$ContentTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeCountArgs} args - Arguments to filter ContentTypes to count.
     * @example
     * // Count the number of ContentTypes
     * const count = await prisma.contentType.count({
     *   where: {
     *     // ... the filter for the ContentTypes we want to count
     *   }
     * })
    **/
    count<T extends ContentTypeCountArgs>(
      args?: Subset<T, ContentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentTypeAggregateArgs>(args: Subset<T, ContentTypeAggregateArgs>): Prisma.PrismaPromise<GetContentTypeAggregateType<T>>

    /**
     * Group by ContentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentType model
   */
  readonly fields: ContentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contentGenerationDetail<T extends ContentGenerationDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentGenerationDetailDefaultArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentType model
   */
  interface ContentTypeFieldRefs {
    readonly id: FieldRef<"ContentType", 'Int'>
    readonly contentType: FieldRef<"ContentType", 'String'>
    readonly price: FieldRef<"ContentType", 'Float'>
    readonly contentGenerationDetailId: FieldRef<"ContentType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentType findUnique
   */
  export type ContentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentType to fetch.
     */
    where: ContentTypeWhereUniqueInput
  }

  /**
   * ContentType findUniqueOrThrow
   */
  export type ContentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentType to fetch.
     */
    where: ContentTypeWhereUniqueInput
  }

  /**
   * ContentType findFirst
   */
  export type ContentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentType to fetch.
     */
    where?: ContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTypes to fetch.
     */
    orderBy?: ContentTypeOrderByWithRelationInput | ContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTypes.
     */
    cursor?: ContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTypes.
     */
    distinct?: ContentTypeScalarFieldEnum | ContentTypeScalarFieldEnum[]
  }

  /**
   * ContentType findFirstOrThrow
   */
  export type ContentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentType to fetch.
     */
    where?: ContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTypes to fetch.
     */
    orderBy?: ContentTypeOrderByWithRelationInput | ContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentTypes.
     */
    cursor?: ContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentTypes.
     */
    distinct?: ContentTypeScalarFieldEnum | ContentTypeScalarFieldEnum[]
  }

  /**
   * ContentType findMany
   */
  export type ContentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContentTypes to fetch.
     */
    where?: ContentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentTypes to fetch.
     */
    orderBy?: ContentTypeOrderByWithRelationInput | ContentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentTypes.
     */
    cursor?: ContentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentTypes.
     */
    skip?: number
    distinct?: ContentTypeScalarFieldEnum | ContentTypeScalarFieldEnum[]
  }

  /**
   * ContentType create
   */
  export type ContentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentType.
     */
    data: XOR<ContentTypeCreateInput, ContentTypeUncheckedCreateInput>
  }

  /**
   * ContentType createMany
   */
  export type ContentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentTypes.
     */
    data: ContentTypeCreateManyInput | ContentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentType update
   */
  export type ContentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentType.
     */
    data: XOR<ContentTypeUpdateInput, ContentTypeUncheckedUpdateInput>
    /**
     * Choose, which ContentType to update.
     */
    where: ContentTypeWhereUniqueInput
  }

  /**
   * ContentType updateMany
   */
  export type ContentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentTypes.
     */
    data: XOR<ContentTypeUpdateManyMutationInput, ContentTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContentTypes to update
     */
    where?: ContentTypeWhereInput
    /**
     * Limit how many ContentTypes to update.
     */
    limit?: number
  }

  /**
   * ContentType upsert
   */
  export type ContentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentType to update in case it exists.
     */
    where: ContentTypeWhereUniqueInput
    /**
     * In case the ContentType found by the `where` argument doesn't exist, create a new ContentType with this data.
     */
    create: XOR<ContentTypeCreateInput, ContentTypeUncheckedCreateInput>
    /**
     * In case the ContentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentTypeUpdateInput, ContentTypeUncheckedUpdateInput>
  }

  /**
   * ContentType delete
   */
  export type ContentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
    /**
     * Filter which ContentType to delete.
     */
    where: ContentTypeWhereUniqueInput
  }

  /**
   * ContentType deleteMany
   */
  export type ContentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentTypes to delete
     */
    where?: ContentTypeWhereInput
    /**
     * Limit how many ContentTypes to delete.
     */
    limit?: number
  }

  /**
   * ContentType without action
   */
  export type ContentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentType
     */
    select?: ContentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentType
     */
    omit?: ContentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentTypeInclude<ExtArgs> | null
  }


  /**
   * Model ContentLanguage
   */

  export type AggregateContentLanguage = {
    _count: ContentLanguageCountAggregateOutputType | null
    _avg: ContentLanguageAvgAggregateOutputType | null
    _sum: ContentLanguageSumAggregateOutputType | null
    _min: ContentLanguageMinAggregateOutputType | null
    _max: ContentLanguageMaxAggregateOutputType | null
  }

  export type ContentLanguageAvgAggregateOutputType = {
    id: number | null
    price: number | null
    contentGenerationDetailId: number | null
  }

  export type ContentLanguageSumAggregateOutputType = {
    id: number | null
    price: number | null
    contentGenerationDetailId: number | null
  }

  export type ContentLanguageMinAggregateOutputType = {
    id: number | null
    language: string | null
    price: number | null
    contentGenerationDetailId: number | null
  }

  export type ContentLanguageMaxAggregateOutputType = {
    id: number | null
    language: string | null
    price: number | null
    contentGenerationDetailId: number | null
  }

  export type ContentLanguageCountAggregateOutputType = {
    id: number
    language: number
    price: number
    contentGenerationDetailId: number
    _all: number
  }


  export type ContentLanguageAvgAggregateInputType = {
    id?: true
    price?: true
    contentGenerationDetailId?: true
  }

  export type ContentLanguageSumAggregateInputType = {
    id?: true
    price?: true
    contentGenerationDetailId?: true
  }

  export type ContentLanguageMinAggregateInputType = {
    id?: true
    language?: true
    price?: true
    contentGenerationDetailId?: true
  }

  export type ContentLanguageMaxAggregateInputType = {
    id?: true
    language?: true
    price?: true
    contentGenerationDetailId?: true
  }

  export type ContentLanguageCountAggregateInputType = {
    id?: true
    language?: true
    price?: true
    contentGenerationDetailId?: true
    _all?: true
  }

  export type ContentLanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentLanguage to aggregate.
     */
    where?: ContentLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentLanguages to fetch.
     */
    orderBy?: ContentLanguageOrderByWithRelationInput | ContentLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentLanguages
    **/
    _count?: true | ContentLanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentLanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentLanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentLanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentLanguageMaxAggregateInputType
  }

  export type GetContentLanguageAggregateType<T extends ContentLanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateContentLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentLanguage[P]>
      : GetScalarType<T[P], AggregateContentLanguage[P]>
  }




  export type ContentLanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentLanguageWhereInput
    orderBy?: ContentLanguageOrderByWithAggregationInput | ContentLanguageOrderByWithAggregationInput[]
    by: ContentLanguageScalarFieldEnum[] | ContentLanguageScalarFieldEnum
    having?: ContentLanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentLanguageCountAggregateInputType | true
    _avg?: ContentLanguageAvgAggregateInputType
    _sum?: ContentLanguageSumAggregateInputType
    _min?: ContentLanguageMinAggregateInputType
    _max?: ContentLanguageMaxAggregateInputType
  }

  export type ContentLanguageGroupByOutputType = {
    id: number
    language: string
    price: number
    contentGenerationDetailId: number
    _count: ContentLanguageCountAggregateOutputType | null
    _avg: ContentLanguageAvgAggregateOutputType | null
    _sum: ContentLanguageSumAggregateOutputType | null
    _min: ContentLanguageMinAggregateOutputType | null
    _max: ContentLanguageMaxAggregateOutputType | null
  }

  type GetContentLanguageGroupByPayload<T extends ContentLanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentLanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentLanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentLanguageGroupByOutputType[P]>
            : GetScalarType<T[P], ContentLanguageGroupByOutputType[P]>
        }
      >
    >


  export type ContentLanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    price?: boolean
    contentGenerationDetailId?: boolean
    contentGenerationDetail?: boolean | ContentGenerationDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentLanguage"]>



  export type ContentLanguageSelectScalar = {
    id?: boolean
    language?: boolean
    price?: boolean
    contentGenerationDetailId?: boolean
  }

  export type ContentLanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "language" | "price" | "contentGenerationDetailId", ExtArgs["result"]["contentLanguage"]>
  export type ContentLanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentGenerationDetail?: boolean | ContentGenerationDetailDefaultArgs<ExtArgs>
  }

  export type $ContentLanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentLanguage"
    objects: {
      contentGenerationDetail: Prisma.$ContentGenerationDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      language: string
      price: number
      contentGenerationDetailId: number
    }, ExtArgs["result"]["contentLanguage"]>
    composites: {}
  }

  type ContentLanguageGetPayload<S extends boolean | null | undefined | ContentLanguageDefaultArgs> = $Result.GetResult<Prisma.$ContentLanguagePayload, S>

  type ContentLanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentLanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentLanguageCountAggregateInputType | true
    }

  export interface ContentLanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentLanguage'], meta: { name: 'ContentLanguage' } }
    /**
     * Find zero or one ContentLanguage that matches the filter.
     * @param {ContentLanguageFindUniqueArgs} args - Arguments to find a ContentLanguage
     * @example
     * // Get one ContentLanguage
     * const contentLanguage = await prisma.contentLanguage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentLanguageFindUniqueArgs>(args: SelectSubset<T, ContentLanguageFindUniqueArgs<ExtArgs>>): Prisma__ContentLanguageClient<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentLanguage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentLanguageFindUniqueOrThrowArgs} args - Arguments to find a ContentLanguage
     * @example
     * // Get one ContentLanguage
     * const contentLanguage = await prisma.contentLanguage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentLanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentLanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentLanguageClient<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentLanguage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLanguageFindFirstArgs} args - Arguments to find a ContentLanguage
     * @example
     * // Get one ContentLanguage
     * const contentLanguage = await prisma.contentLanguage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentLanguageFindFirstArgs>(args?: SelectSubset<T, ContentLanguageFindFirstArgs<ExtArgs>>): Prisma__ContentLanguageClient<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentLanguage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLanguageFindFirstOrThrowArgs} args - Arguments to find a ContentLanguage
     * @example
     * // Get one ContentLanguage
     * const contentLanguage = await prisma.contentLanguage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentLanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentLanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentLanguageClient<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentLanguages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentLanguages
     * const contentLanguages = await prisma.contentLanguage.findMany()
     * 
     * // Get first 10 ContentLanguages
     * const contentLanguages = await prisma.contentLanguage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentLanguageWithIdOnly = await prisma.contentLanguage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentLanguageFindManyArgs>(args?: SelectSubset<T, ContentLanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentLanguage.
     * @param {ContentLanguageCreateArgs} args - Arguments to create a ContentLanguage.
     * @example
     * // Create one ContentLanguage
     * const ContentLanguage = await prisma.contentLanguage.create({
     *   data: {
     *     // ... data to create a ContentLanguage
     *   }
     * })
     * 
     */
    create<T extends ContentLanguageCreateArgs>(args: SelectSubset<T, ContentLanguageCreateArgs<ExtArgs>>): Prisma__ContentLanguageClient<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentLanguages.
     * @param {ContentLanguageCreateManyArgs} args - Arguments to create many ContentLanguages.
     * @example
     * // Create many ContentLanguages
     * const contentLanguage = await prisma.contentLanguage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentLanguageCreateManyArgs>(args?: SelectSubset<T, ContentLanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContentLanguage.
     * @param {ContentLanguageDeleteArgs} args - Arguments to delete one ContentLanguage.
     * @example
     * // Delete one ContentLanguage
     * const ContentLanguage = await prisma.contentLanguage.delete({
     *   where: {
     *     // ... filter to delete one ContentLanguage
     *   }
     * })
     * 
     */
    delete<T extends ContentLanguageDeleteArgs>(args: SelectSubset<T, ContentLanguageDeleteArgs<ExtArgs>>): Prisma__ContentLanguageClient<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentLanguage.
     * @param {ContentLanguageUpdateArgs} args - Arguments to update one ContentLanguage.
     * @example
     * // Update one ContentLanguage
     * const contentLanguage = await prisma.contentLanguage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentLanguageUpdateArgs>(args: SelectSubset<T, ContentLanguageUpdateArgs<ExtArgs>>): Prisma__ContentLanguageClient<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentLanguages.
     * @param {ContentLanguageDeleteManyArgs} args - Arguments to filter ContentLanguages to delete.
     * @example
     * // Delete a few ContentLanguages
     * const { count } = await prisma.contentLanguage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentLanguageDeleteManyArgs>(args?: SelectSubset<T, ContentLanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentLanguages
     * const contentLanguage = await prisma.contentLanguage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentLanguageUpdateManyArgs>(args: SelectSubset<T, ContentLanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentLanguage.
     * @param {ContentLanguageUpsertArgs} args - Arguments to update or create a ContentLanguage.
     * @example
     * // Update or create a ContentLanguage
     * const contentLanguage = await prisma.contentLanguage.upsert({
     *   create: {
     *     // ... data to create a ContentLanguage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentLanguage we want to update
     *   }
     * })
     */
    upsert<T extends ContentLanguageUpsertArgs>(args: SelectSubset<T, ContentLanguageUpsertArgs<ExtArgs>>): Prisma__ContentLanguageClient<$Result.GetResult<Prisma.$ContentLanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentLanguages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLanguageCountArgs} args - Arguments to filter ContentLanguages to count.
     * @example
     * // Count the number of ContentLanguages
     * const count = await prisma.contentLanguage.count({
     *   where: {
     *     // ... the filter for the ContentLanguages we want to count
     *   }
     * })
    **/
    count<T extends ContentLanguageCountArgs>(
      args?: Subset<T, ContentLanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentLanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentLanguageAggregateArgs>(args: Subset<T, ContentLanguageAggregateArgs>): Prisma.PrismaPromise<GetContentLanguageAggregateType<T>>

    /**
     * Group by ContentLanguage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentLanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentLanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentLanguageGroupByArgs['orderBy'] }
        : { orderBy?: ContentLanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentLanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentLanguage model
   */
  readonly fields: ContentLanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentLanguage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentLanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contentGenerationDetail<T extends ContentGenerationDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentGenerationDetailDefaultArgs<ExtArgs>>): Prisma__ContentGenerationDetailClient<$Result.GetResult<Prisma.$ContentGenerationDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentLanguage model
   */
  interface ContentLanguageFieldRefs {
    readonly id: FieldRef<"ContentLanguage", 'Int'>
    readonly language: FieldRef<"ContentLanguage", 'String'>
    readonly price: FieldRef<"ContentLanguage", 'Float'>
    readonly contentGenerationDetailId: FieldRef<"ContentLanguage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentLanguage findUnique
   */
  export type ContentLanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContentLanguage to fetch.
     */
    where: ContentLanguageWhereUniqueInput
  }

  /**
   * ContentLanguage findUniqueOrThrow
   */
  export type ContentLanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContentLanguage to fetch.
     */
    where: ContentLanguageWhereUniqueInput
  }

  /**
   * ContentLanguage findFirst
   */
  export type ContentLanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContentLanguage to fetch.
     */
    where?: ContentLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentLanguages to fetch.
     */
    orderBy?: ContentLanguageOrderByWithRelationInput | ContentLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentLanguages.
     */
    cursor?: ContentLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentLanguages.
     */
    distinct?: ContentLanguageScalarFieldEnum | ContentLanguageScalarFieldEnum[]
  }

  /**
   * ContentLanguage findFirstOrThrow
   */
  export type ContentLanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContentLanguage to fetch.
     */
    where?: ContentLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentLanguages to fetch.
     */
    orderBy?: ContentLanguageOrderByWithRelationInput | ContentLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentLanguages.
     */
    cursor?: ContentLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentLanguages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentLanguages.
     */
    distinct?: ContentLanguageScalarFieldEnum | ContentLanguageScalarFieldEnum[]
  }

  /**
   * ContentLanguage findMany
   */
  export type ContentLanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    /**
     * Filter, which ContentLanguages to fetch.
     */
    where?: ContentLanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentLanguages to fetch.
     */
    orderBy?: ContentLanguageOrderByWithRelationInput | ContentLanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentLanguages.
     */
    cursor?: ContentLanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentLanguages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentLanguages.
     */
    skip?: number
    distinct?: ContentLanguageScalarFieldEnum | ContentLanguageScalarFieldEnum[]
  }

  /**
   * ContentLanguage create
   */
  export type ContentLanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentLanguage.
     */
    data: XOR<ContentLanguageCreateInput, ContentLanguageUncheckedCreateInput>
  }

  /**
   * ContentLanguage createMany
   */
  export type ContentLanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentLanguages.
     */
    data: ContentLanguageCreateManyInput | ContentLanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentLanguage update
   */
  export type ContentLanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentLanguage.
     */
    data: XOR<ContentLanguageUpdateInput, ContentLanguageUncheckedUpdateInput>
    /**
     * Choose, which ContentLanguage to update.
     */
    where: ContentLanguageWhereUniqueInput
  }

  /**
   * ContentLanguage updateMany
   */
  export type ContentLanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentLanguages.
     */
    data: XOR<ContentLanguageUpdateManyMutationInput, ContentLanguageUncheckedUpdateManyInput>
    /**
     * Filter which ContentLanguages to update
     */
    where?: ContentLanguageWhereInput
    /**
     * Limit how many ContentLanguages to update.
     */
    limit?: number
  }

  /**
   * ContentLanguage upsert
   */
  export type ContentLanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentLanguage to update in case it exists.
     */
    where: ContentLanguageWhereUniqueInput
    /**
     * In case the ContentLanguage found by the `where` argument doesn't exist, create a new ContentLanguage with this data.
     */
    create: XOR<ContentLanguageCreateInput, ContentLanguageUncheckedCreateInput>
    /**
     * In case the ContentLanguage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentLanguageUpdateInput, ContentLanguageUncheckedUpdateInput>
  }

  /**
   * ContentLanguage delete
   */
  export type ContentLanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
    /**
     * Filter which ContentLanguage to delete.
     */
    where: ContentLanguageWhereUniqueInput
  }

  /**
   * ContentLanguage deleteMany
   */
  export type ContentLanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentLanguages to delete
     */
    where?: ContentLanguageWhereInput
    /**
     * Limit how many ContentLanguages to delete.
     */
    limit?: number
  }

  /**
   * ContentLanguage without action
   */
  export type ContentLanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentLanguage
     */
    select?: ContentLanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentLanguage
     */
    omit?: ContentLanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentLanguageInclude<ExtArgs> | null
  }


  /**
   * Model AppDevelopmentDetail
   */

  export type AggregateAppDevelopmentDetail = {
    _count: AppDevelopmentDetailCountAggregateOutputType | null
    _avg: AppDevelopmentDetailAvgAggregateOutputType | null
    _sum: AppDevelopmentDetailSumAggregateOutputType | null
    _min: AppDevelopmentDetailMinAggregateOutputType | null
    _max: AppDevelopmentDetailMaxAggregateOutputType | null
  }

  export type AppDevelopmentDetailAvgAggregateOutputType = {
    id: number | null
    expectedUsers: number | null
    projectId: number | null
  }

  export type AppDevelopmentDetailSumAggregateOutputType = {
    id: number | null
    expectedUsers: number | null
    projectId: number | null
  }

  export type AppDevelopmentDetailMinAggregateOutputType = {
    id: number | null
    appType: string | null
    complexity: string | null
    targetPlatforms: string | null
    expectedUsers: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type AppDevelopmentDetailMaxAggregateOutputType = {
    id: number | null
    appType: string | null
    complexity: string | null
    targetPlatforms: string | null
    expectedUsers: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type AppDevelopmentDetailCountAggregateOutputType = {
    id: number
    appType: number
    complexity: number
    targetPlatforms: number
    expectedUsers: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type AppDevelopmentDetailAvgAggregateInputType = {
    id?: true
    expectedUsers?: true
    projectId?: true
  }

  export type AppDevelopmentDetailSumAggregateInputType = {
    id?: true
    expectedUsers?: true
    projectId?: true
  }

  export type AppDevelopmentDetailMinAggregateInputType = {
    id?: true
    appType?: true
    complexity?: true
    targetPlatforms?: true
    expectedUsers?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type AppDevelopmentDetailMaxAggregateInputType = {
    id?: true
    appType?: true
    complexity?: true
    targetPlatforms?: true
    expectedUsers?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type AppDevelopmentDetailCountAggregateInputType = {
    id?: true
    appType?: true
    complexity?: true
    targetPlatforms?: true
    expectedUsers?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type AppDevelopmentDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppDevelopmentDetail to aggregate.
     */
    where?: AppDevelopmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppDevelopmentDetails to fetch.
     */
    orderBy?: AppDevelopmentDetailOrderByWithRelationInput | AppDevelopmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppDevelopmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppDevelopmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppDevelopmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppDevelopmentDetails
    **/
    _count?: true | AppDevelopmentDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppDevelopmentDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppDevelopmentDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppDevelopmentDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppDevelopmentDetailMaxAggregateInputType
  }

  export type GetAppDevelopmentDetailAggregateType<T extends AppDevelopmentDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateAppDevelopmentDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppDevelopmentDetail[P]>
      : GetScalarType<T[P], AggregateAppDevelopmentDetail[P]>
  }




  export type AppDevelopmentDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppDevelopmentDetailWhereInput
    orderBy?: AppDevelopmentDetailOrderByWithAggregationInput | AppDevelopmentDetailOrderByWithAggregationInput[]
    by: AppDevelopmentDetailScalarFieldEnum[] | AppDevelopmentDetailScalarFieldEnum
    having?: AppDevelopmentDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppDevelopmentDetailCountAggregateInputType | true
    _avg?: AppDevelopmentDetailAvgAggregateInputType
    _sum?: AppDevelopmentDetailSumAggregateInputType
    _min?: AppDevelopmentDetailMinAggregateInputType
    _max?: AppDevelopmentDetailMaxAggregateInputType
  }

  export type AppDevelopmentDetailGroupByOutputType = {
    id: number
    appType: string | null
    complexity: string | null
    targetPlatforms: string | null
    expectedUsers: number | null
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: AppDevelopmentDetailCountAggregateOutputType | null
    _avg: AppDevelopmentDetailAvgAggregateOutputType | null
    _sum: AppDevelopmentDetailSumAggregateOutputType | null
    _min: AppDevelopmentDetailMinAggregateOutputType | null
    _max: AppDevelopmentDetailMaxAggregateOutputType | null
  }

  type GetAppDevelopmentDetailGroupByPayload<T extends AppDevelopmentDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppDevelopmentDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppDevelopmentDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppDevelopmentDetailGroupByOutputType[P]>
            : GetScalarType<T[P], AppDevelopmentDetailGroupByOutputType[P]>
        }
      >
    >


  export type AppDevelopmentDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appType?: boolean
    complexity?: boolean
    targetPlatforms?: boolean
    expectedUsers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    appFeatures?: boolean | AppDevelopmentDetail$appFeaturesArgs<ExtArgs>
    _count?: boolean | AppDevelopmentDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appDevelopmentDetail"]>



  export type AppDevelopmentDetailSelectScalar = {
    id?: boolean
    appType?: boolean
    complexity?: boolean
    targetPlatforms?: boolean
    expectedUsers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type AppDevelopmentDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appType" | "complexity" | "targetPlatforms" | "expectedUsers" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["appDevelopmentDetail"]>
  export type AppDevelopmentDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    appFeatures?: boolean | AppDevelopmentDetail$appFeaturesArgs<ExtArgs>
    _count?: boolean | AppDevelopmentDetailCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AppDevelopmentDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppDevelopmentDetail"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      appFeatures: Prisma.$AppFeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      appType: string | null
      complexity: string | null
      targetPlatforms: string | null
      expectedUsers: number | null
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["appDevelopmentDetail"]>
    composites: {}
  }

  type AppDevelopmentDetailGetPayload<S extends boolean | null | undefined | AppDevelopmentDetailDefaultArgs> = $Result.GetResult<Prisma.$AppDevelopmentDetailPayload, S>

  type AppDevelopmentDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppDevelopmentDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppDevelopmentDetailCountAggregateInputType | true
    }

  export interface AppDevelopmentDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppDevelopmentDetail'], meta: { name: 'AppDevelopmentDetail' } }
    /**
     * Find zero or one AppDevelopmentDetail that matches the filter.
     * @param {AppDevelopmentDetailFindUniqueArgs} args - Arguments to find a AppDevelopmentDetail
     * @example
     * // Get one AppDevelopmentDetail
     * const appDevelopmentDetail = await prisma.appDevelopmentDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppDevelopmentDetailFindUniqueArgs>(args: SelectSubset<T, AppDevelopmentDetailFindUniqueArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppDevelopmentDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppDevelopmentDetailFindUniqueOrThrowArgs} args - Arguments to find a AppDevelopmentDetail
     * @example
     * // Get one AppDevelopmentDetail
     * const appDevelopmentDetail = await prisma.appDevelopmentDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppDevelopmentDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, AppDevelopmentDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppDevelopmentDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDevelopmentDetailFindFirstArgs} args - Arguments to find a AppDevelopmentDetail
     * @example
     * // Get one AppDevelopmentDetail
     * const appDevelopmentDetail = await prisma.appDevelopmentDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppDevelopmentDetailFindFirstArgs>(args?: SelectSubset<T, AppDevelopmentDetailFindFirstArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppDevelopmentDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDevelopmentDetailFindFirstOrThrowArgs} args - Arguments to find a AppDevelopmentDetail
     * @example
     * // Get one AppDevelopmentDetail
     * const appDevelopmentDetail = await prisma.appDevelopmentDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppDevelopmentDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, AppDevelopmentDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppDevelopmentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDevelopmentDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppDevelopmentDetails
     * const appDevelopmentDetails = await prisma.appDevelopmentDetail.findMany()
     * 
     * // Get first 10 AppDevelopmentDetails
     * const appDevelopmentDetails = await prisma.appDevelopmentDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appDevelopmentDetailWithIdOnly = await prisma.appDevelopmentDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppDevelopmentDetailFindManyArgs>(args?: SelectSubset<T, AppDevelopmentDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppDevelopmentDetail.
     * @param {AppDevelopmentDetailCreateArgs} args - Arguments to create a AppDevelopmentDetail.
     * @example
     * // Create one AppDevelopmentDetail
     * const AppDevelopmentDetail = await prisma.appDevelopmentDetail.create({
     *   data: {
     *     // ... data to create a AppDevelopmentDetail
     *   }
     * })
     * 
     */
    create<T extends AppDevelopmentDetailCreateArgs>(args: SelectSubset<T, AppDevelopmentDetailCreateArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppDevelopmentDetails.
     * @param {AppDevelopmentDetailCreateManyArgs} args - Arguments to create many AppDevelopmentDetails.
     * @example
     * // Create many AppDevelopmentDetails
     * const appDevelopmentDetail = await prisma.appDevelopmentDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppDevelopmentDetailCreateManyArgs>(args?: SelectSubset<T, AppDevelopmentDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AppDevelopmentDetail.
     * @param {AppDevelopmentDetailDeleteArgs} args - Arguments to delete one AppDevelopmentDetail.
     * @example
     * // Delete one AppDevelopmentDetail
     * const AppDevelopmentDetail = await prisma.appDevelopmentDetail.delete({
     *   where: {
     *     // ... filter to delete one AppDevelopmentDetail
     *   }
     * })
     * 
     */
    delete<T extends AppDevelopmentDetailDeleteArgs>(args: SelectSubset<T, AppDevelopmentDetailDeleteArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppDevelopmentDetail.
     * @param {AppDevelopmentDetailUpdateArgs} args - Arguments to update one AppDevelopmentDetail.
     * @example
     * // Update one AppDevelopmentDetail
     * const appDevelopmentDetail = await prisma.appDevelopmentDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppDevelopmentDetailUpdateArgs>(args: SelectSubset<T, AppDevelopmentDetailUpdateArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppDevelopmentDetails.
     * @param {AppDevelopmentDetailDeleteManyArgs} args - Arguments to filter AppDevelopmentDetails to delete.
     * @example
     * // Delete a few AppDevelopmentDetails
     * const { count } = await prisma.appDevelopmentDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppDevelopmentDetailDeleteManyArgs>(args?: SelectSubset<T, AppDevelopmentDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppDevelopmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDevelopmentDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppDevelopmentDetails
     * const appDevelopmentDetail = await prisma.appDevelopmentDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppDevelopmentDetailUpdateManyArgs>(args: SelectSubset<T, AppDevelopmentDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppDevelopmentDetail.
     * @param {AppDevelopmentDetailUpsertArgs} args - Arguments to update or create a AppDevelopmentDetail.
     * @example
     * // Update or create a AppDevelopmentDetail
     * const appDevelopmentDetail = await prisma.appDevelopmentDetail.upsert({
     *   create: {
     *     // ... data to create a AppDevelopmentDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppDevelopmentDetail we want to update
     *   }
     * })
     */
    upsert<T extends AppDevelopmentDetailUpsertArgs>(args: SelectSubset<T, AppDevelopmentDetailUpsertArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppDevelopmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDevelopmentDetailCountArgs} args - Arguments to filter AppDevelopmentDetails to count.
     * @example
     * // Count the number of AppDevelopmentDetails
     * const count = await prisma.appDevelopmentDetail.count({
     *   where: {
     *     // ... the filter for the AppDevelopmentDetails we want to count
     *   }
     * })
    **/
    count<T extends AppDevelopmentDetailCountArgs>(
      args?: Subset<T, AppDevelopmentDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppDevelopmentDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppDevelopmentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDevelopmentDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppDevelopmentDetailAggregateArgs>(args: Subset<T, AppDevelopmentDetailAggregateArgs>): Prisma.PrismaPromise<GetAppDevelopmentDetailAggregateType<T>>

    /**
     * Group by AppDevelopmentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDevelopmentDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppDevelopmentDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppDevelopmentDetailGroupByArgs['orderBy'] }
        : { orderBy?: AppDevelopmentDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppDevelopmentDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppDevelopmentDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppDevelopmentDetail model
   */
  readonly fields: AppDevelopmentDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppDevelopmentDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppDevelopmentDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appFeatures<T extends AppDevelopmentDetail$appFeaturesArgs<ExtArgs> = {}>(args?: Subset<T, AppDevelopmentDetail$appFeaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppDevelopmentDetail model
   */
  interface AppDevelopmentDetailFieldRefs {
    readonly id: FieldRef<"AppDevelopmentDetail", 'Int'>
    readonly appType: FieldRef<"AppDevelopmentDetail", 'String'>
    readonly complexity: FieldRef<"AppDevelopmentDetail", 'String'>
    readonly targetPlatforms: FieldRef<"AppDevelopmentDetail", 'String'>
    readonly expectedUsers: FieldRef<"AppDevelopmentDetail", 'Int'>
    readonly createdAt: FieldRef<"AppDevelopmentDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"AppDevelopmentDetail", 'DateTime'>
    readonly projectId: FieldRef<"AppDevelopmentDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AppDevelopmentDetail findUnique
   */
  export type AppDevelopmentDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which AppDevelopmentDetail to fetch.
     */
    where: AppDevelopmentDetailWhereUniqueInput
  }

  /**
   * AppDevelopmentDetail findUniqueOrThrow
   */
  export type AppDevelopmentDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which AppDevelopmentDetail to fetch.
     */
    where: AppDevelopmentDetailWhereUniqueInput
  }

  /**
   * AppDevelopmentDetail findFirst
   */
  export type AppDevelopmentDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which AppDevelopmentDetail to fetch.
     */
    where?: AppDevelopmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppDevelopmentDetails to fetch.
     */
    orderBy?: AppDevelopmentDetailOrderByWithRelationInput | AppDevelopmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppDevelopmentDetails.
     */
    cursor?: AppDevelopmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppDevelopmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppDevelopmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppDevelopmentDetails.
     */
    distinct?: AppDevelopmentDetailScalarFieldEnum | AppDevelopmentDetailScalarFieldEnum[]
  }

  /**
   * AppDevelopmentDetail findFirstOrThrow
   */
  export type AppDevelopmentDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which AppDevelopmentDetail to fetch.
     */
    where?: AppDevelopmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppDevelopmentDetails to fetch.
     */
    orderBy?: AppDevelopmentDetailOrderByWithRelationInput | AppDevelopmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppDevelopmentDetails.
     */
    cursor?: AppDevelopmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppDevelopmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppDevelopmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppDevelopmentDetails.
     */
    distinct?: AppDevelopmentDetailScalarFieldEnum | AppDevelopmentDetailScalarFieldEnum[]
  }

  /**
   * AppDevelopmentDetail findMany
   */
  export type AppDevelopmentDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which AppDevelopmentDetails to fetch.
     */
    where?: AppDevelopmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppDevelopmentDetails to fetch.
     */
    orderBy?: AppDevelopmentDetailOrderByWithRelationInput | AppDevelopmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppDevelopmentDetails.
     */
    cursor?: AppDevelopmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppDevelopmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppDevelopmentDetails.
     */
    skip?: number
    distinct?: AppDevelopmentDetailScalarFieldEnum | AppDevelopmentDetailScalarFieldEnum[]
  }

  /**
   * AppDevelopmentDetail create
   */
  export type AppDevelopmentDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a AppDevelopmentDetail.
     */
    data: XOR<AppDevelopmentDetailCreateInput, AppDevelopmentDetailUncheckedCreateInput>
  }

  /**
   * AppDevelopmentDetail createMany
   */
  export type AppDevelopmentDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppDevelopmentDetails.
     */
    data: AppDevelopmentDetailCreateManyInput | AppDevelopmentDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppDevelopmentDetail update
   */
  export type AppDevelopmentDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a AppDevelopmentDetail.
     */
    data: XOR<AppDevelopmentDetailUpdateInput, AppDevelopmentDetailUncheckedUpdateInput>
    /**
     * Choose, which AppDevelopmentDetail to update.
     */
    where: AppDevelopmentDetailWhereUniqueInput
  }

  /**
   * AppDevelopmentDetail updateMany
   */
  export type AppDevelopmentDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppDevelopmentDetails.
     */
    data: XOR<AppDevelopmentDetailUpdateManyMutationInput, AppDevelopmentDetailUncheckedUpdateManyInput>
    /**
     * Filter which AppDevelopmentDetails to update
     */
    where?: AppDevelopmentDetailWhereInput
    /**
     * Limit how many AppDevelopmentDetails to update.
     */
    limit?: number
  }

  /**
   * AppDevelopmentDetail upsert
   */
  export type AppDevelopmentDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the AppDevelopmentDetail to update in case it exists.
     */
    where: AppDevelopmentDetailWhereUniqueInput
    /**
     * In case the AppDevelopmentDetail found by the `where` argument doesn't exist, create a new AppDevelopmentDetail with this data.
     */
    create: XOR<AppDevelopmentDetailCreateInput, AppDevelopmentDetailUncheckedCreateInput>
    /**
     * In case the AppDevelopmentDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppDevelopmentDetailUpdateInput, AppDevelopmentDetailUncheckedUpdateInput>
  }

  /**
   * AppDevelopmentDetail delete
   */
  export type AppDevelopmentDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
    /**
     * Filter which AppDevelopmentDetail to delete.
     */
    where: AppDevelopmentDetailWhereUniqueInput
  }

  /**
   * AppDevelopmentDetail deleteMany
   */
  export type AppDevelopmentDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppDevelopmentDetails to delete
     */
    where?: AppDevelopmentDetailWhereInput
    /**
     * Limit how many AppDevelopmentDetails to delete.
     */
    limit?: number
  }

  /**
   * AppDevelopmentDetail.appFeatures
   */
  export type AppDevelopmentDetail$appFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    where?: AppFeatureWhereInput
    orderBy?: AppFeatureOrderByWithRelationInput | AppFeatureOrderByWithRelationInput[]
    cursor?: AppFeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppFeatureScalarFieldEnum | AppFeatureScalarFieldEnum[]
  }

  /**
   * AppDevelopmentDetail without action
   */
  export type AppDevelopmentDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppDevelopmentDetail
     */
    select?: AppDevelopmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppDevelopmentDetail
     */
    omit?: AppDevelopmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDevelopmentDetailInclude<ExtArgs> | null
  }


  /**
   * Model AppFeature
   */

  export type AggregateAppFeature = {
    _count: AppFeatureCountAggregateOutputType | null
    _avg: AppFeatureAvgAggregateOutputType | null
    _sum: AppFeatureSumAggregateOutputType | null
    _min: AppFeatureMinAggregateOutputType | null
    _max: AppFeatureMaxAggregateOutputType | null
  }

  export type AppFeatureAvgAggregateOutputType = {
    id: number | null
    price: number | null
    appDevelopmentDetailId: number | null
  }

  export type AppFeatureSumAggregateOutputType = {
    id: number | null
    price: number | null
    appDevelopmentDetailId: number | null
  }

  export type AppFeatureMinAggregateOutputType = {
    id: number | null
    feature: string | null
    price: number | null
    appDevelopmentDetailId: number | null
  }

  export type AppFeatureMaxAggregateOutputType = {
    id: number | null
    feature: string | null
    price: number | null
    appDevelopmentDetailId: number | null
  }

  export type AppFeatureCountAggregateOutputType = {
    id: number
    feature: number
    price: number
    appDevelopmentDetailId: number
    _all: number
  }


  export type AppFeatureAvgAggregateInputType = {
    id?: true
    price?: true
    appDevelopmentDetailId?: true
  }

  export type AppFeatureSumAggregateInputType = {
    id?: true
    price?: true
    appDevelopmentDetailId?: true
  }

  export type AppFeatureMinAggregateInputType = {
    id?: true
    feature?: true
    price?: true
    appDevelopmentDetailId?: true
  }

  export type AppFeatureMaxAggregateInputType = {
    id?: true
    feature?: true
    price?: true
    appDevelopmentDetailId?: true
  }

  export type AppFeatureCountAggregateInputType = {
    id?: true
    feature?: true
    price?: true
    appDevelopmentDetailId?: true
    _all?: true
  }

  export type AppFeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppFeature to aggregate.
     */
    where?: AppFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppFeatures to fetch.
     */
    orderBy?: AppFeatureOrderByWithRelationInput | AppFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppFeatures
    **/
    _count?: true | AppFeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppFeatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppFeatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppFeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppFeatureMaxAggregateInputType
  }

  export type GetAppFeatureAggregateType<T extends AppFeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateAppFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppFeature[P]>
      : GetScalarType<T[P], AggregateAppFeature[P]>
  }




  export type AppFeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppFeatureWhereInput
    orderBy?: AppFeatureOrderByWithAggregationInput | AppFeatureOrderByWithAggregationInput[]
    by: AppFeatureScalarFieldEnum[] | AppFeatureScalarFieldEnum
    having?: AppFeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppFeatureCountAggregateInputType | true
    _avg?: AppFeatureAvgAggregateInputType
    _sum?: AppFeatureSumAggregateInputType
    _min?: AppFeatureMinAggregateInputType
    _max?: AppFeatureMaxAggregateInputType
  }

  export type AppFeatureGroupByOutputType = {
    id: number
    feature: string
    price: number
    appDevelopmentDetailId: number
    _count: AppFeatureCountAggregateOutputType | null
    _avg: AppFeatureAvgAggregateOutputType | null
    _sum: AppFeatureSumAggregateOutputType | null
    _min: AppFeatureMinAggregateOutputType | null
    _max: AppFeatureMaxAggregateOutputType | null
  }

  type GetAppFeatureGroupByPayload<T extends AppFeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppFeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppFeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppFeatureGroupByOutputType[P]>
            : GetScalarType<T[P], AppFeatureGroupByOutputType[P]>
        }
      >
    >


  export type AppFeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feature?: boolean
    price?: boolean
    appDevelopmentDetailId?: boolean
    appDevelopmentDetail?: boolean | AppDevelopmentDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appFeature"]>



  export type AppFeatureSelectScalar = {
    id?: boolean
    feature?: boolean
    price?: boolean
    appDevelopmentDetailId?: boolean
  }

  export type AppFeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feature" | "price" | "appDevelopmentDetailId", ExtArgs["result"]["appFeature"]>
  export type AppFeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appDevelopmentDetail?: boolean | AppDevelopmentDetailDefaultArgs<ExtArgs>
  }

  export type $AppFeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppFeature"
    objects: {
      appDevelopmentDetail: Prisma.$AppDevelopmentDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      feature: string
      price: number
      appDevelopmentDetailId: number
    }, ExtArgs["result"]["appFeature"]>
    composites: {}
  }

  type AppFeatureGetPayload<S extends boolean | null | undefined | AppFeatureDefaultArgs> = $Result.GetResult<Prisma.$AppFeaturePayload, S>

  type AppFeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppFeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppFeatureCountAggregateInputType | true
    }

  export interface AppFeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppFeature'], meta: { name: 'AppFeature' } }
    /**
     * Find zero or one AppFeature that matches the filter.
     * @param {AppFeatureFindUniqueArgs} args - Arguments to find a AppFeature
     * @example
     * // Get one AppFeature
     * const appFeature = await prisma.appFeature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppFeatureFindUniqueArgs>(args: SelectSubset<T, AppFeatureFindUniqueArgs<ExtArgs>>): Prisma__AppFeatureClient<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppFeature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppFeatureFindUniqueOrThrowArgs} args - Arguments to find a AppFeature
     * @example
     * // Get one AppFeature
     * const appFeature = await prisma.appFeature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppFeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, AppFeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppFeatureClient<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppFeature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFeatureFindFirstArgs} args - Arguments to find a AppFeature
     * @example
     * // Get one AppFeature
     * const appFeature = await prisma.appFeature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppFeatureFindFirstArgs>(args?: SelectSubset<T, AppFeatureFindFirstArgs<ExtArgs>>): Prisma__AppFeatureClient<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppFeature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFeatureFindFirstOrThrowArgs} args - Arguments to find a AppFeature
     * @example
     * // Get one AppFeature
     * const appFeature = await prisma.appFeature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppFeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, AppFeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppFeatureClient<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppFeatures
     * const appFeatures = await prisma.appFeature.findMany()
     * 
     * // Get first 10 AppFeatures
     * const appFeatures = await prisma.appFeature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appFeatureWithIdOnly = await prisma.appFeature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppFeatureFindManyArgs>(args?: SelectSubset<T, AppFeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppFeature.
     * @param {AppFeatureCreateArgs} args - Arguments to create a AppFeature.
     * @example
     * // Create one AppFeature
     * const AppFeature = await prisma.appFeature.create({
     *   data: {
     *     // ... data to create a AppFeature
     *   }
     * })
     * 
     */
    create<T extends AppFeatureCreateArgs>(args: SelectSubset<T, AppFeatureCreateArgs<ExtArgs>>): Prisma__AppFeatureClient<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppFeatures.
     * @param {AppFeatureCreateManyArgs} args - Arguments to create many AppFeatures.
     * @example
     * // Create many AppFeatures
     * const appFeature = await prisma.appFeature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppFeatureCreateManyArgs>(args?: SelectSubset<T, AppFeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AppFeature.
     * @param {AppFeatureDeleteArgs} args - Arguments to delete one AppFeature.
     * @example
     * // Delete one AppFeature
     * const AppFeature = await prisma.appFeature.delete({
     *   where: {
     *     // ... filter to delete one AppFeature
     *   }
     * })
     * 
     */
    delete<T extends AppFeatureDeleteArgs>(args: SelectSubset<T, AppFeatureDeleteArgs<ExtArgs>>): Prisma__AppFeatureClient<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppFeature.
     * @param {AppFeatureUpdateArgs} args - Arguments to update one AppFeature.
     * @example
     * // Update one AppFeature
     * const appFeature = await prisma.appFeature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppFeatureUpdateArgs>(args: SelectSubset<T, AppFeatureUpdateArgs<ExtArgs>>): Prisma__AppFeatureClient<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppFeatures.
     * @param {AppFeatureDeleteManyArgs} args - Arguments to filter AppFeatures to delete.
     * @example
     * // Delete a few AppFeatures
     * const { count } = await prisma.appFeature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppFeatureDeleteManyArgs>(args?: SelectSubset<T, AppFeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppFeatures
     * const appFeature = await prisma.appFeature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppFeatureUpdateManyArgs>(args: SelectSubset<T, AppFeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppFeature.
     * @param {AppFeatureUpsertArgs} args - Arguments to update or create a AppFeature.
     * @example
     * // Update or create a AppFeature
     * const appFeature = await prisma.appFeature.upsert({
     *   create: {
     *     // ... data to create a AppFeature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppFeature we want to update
     *   }
     * })
     */
    upsert<T extends AppFeatureUpsertArgs>(args: SelectSubset<T, AppFeatureUpsertArgs<ExtArgs>>): Prisma__AppFeatureClient<$Result.GetResult<Prisma.$AppFeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFeatureCountArgs} args - Arguments to filter AppFeatures to count.
     * @example
     * // Count the number of AppFeatures
     * const count = await prisma.appFeature.count({
     *   where: {
     *     // ... the filter for the AppFeatures we want to count
     *   }
     * })
    **/
    count<T extends AppFeatureCountArgs>(
      args?: Subset<T, AppFeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppFeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppFeatureAggregateArgs>(args: Subset<T, AppFeatureAggregateArgs>): Prisma.PrismaPromise<GetAppFeatureAggregateType<T>>

    /**
     * Group by AppFeature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppFeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppFeatureGroupByArgs['orderBy'] }
        : { orderBy?: AppFeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppFeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppFeature model
   */
  readonly fields: AppFeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppFeature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppFeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appDevelopmentDetail<T extends AppDevelopmentDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDevelopmentDetailDefaultArgs<ExtArgs>>): Prisma__AppDevelopmentDetailClient<$Result.GetResult<Prisma.$AppDevelopmentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppFeature model
   */
  interface AppFeatureFieldRefs {
    readonly id: FieldRef<"AppFeature", 'Int'>
    readonly feature: FieldRef<"AppFeature", 'String'>
    readonly price: FieldRef<"AppFeature", 'Float'>
    readonly appDevelopmentDetailId: FieldRef<"AppFeature", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AppFeature findUnique
   */
  export type AppFeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    /**
     * Filter, which AppFeature to fetch.
     */
    where: AppFeatureWhereUniqueInput
  }

  /**
   * AppFeature findUniqueOrThrow
   */
  export type AppFeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    /**
     * Filter, which AppFeature to fetch.
     */
    where: AppFeatureWhereUniqueInput
  }

  /**
   * AppFeature findFirst
   */
  export type AppFeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    /**
     * Filter, which AppFeature to fetch.
     */
    where?: AppFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppFeatures to fetch.
     */
    orderBy?: AppFeatureOrderByWithRelationInput | AppFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppFeatures.
     */
    cursor?: AppFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppFeatures.
     */
    distinct?: AppFeatureScalarFieldEnum | AppFeatureScalarFieldEnum[]
  }

  /**
   * AppFeature findFirstOrThrow
   */
  export type AppFeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    /**
     * Filter, which AppFeature to fetch.
     */
    where?: AppFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppFeatures to fetch.
     */
    orderBy?: AppFeatureOrderByWithRelationInput | AppFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppFeatures.
     */
    cursor?: AppFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppFeatures.
     */
    distinct?: AppFeatureScalarFieldEnum | AppFeatureScalarFieldEnum[]
  }

  /**
   * AppFeature findMany
   */
  export type AppFeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    /**
     * Filter, which AppFeatures to fetch.
     */
    where?: AppFeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppFeatures to fetch.
     */
    orderBy?: AppFeatureOrderByWithRelationInput | AppFeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppFeatures.
     */
    cursor?: AppFeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppFeatures.
     */
    skip?: number
    distinct?: AppFeatureScalarFieldEnum | AppFeatureScalarFieldEnum[]
  }

  /**
   * AppFeature create
   */
  export type AppFeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a AppFeature.
     */
    data: XOR<AppFeatureCreateInput, AppFeatureUncheckedCreateInput>
  }

  /**
   * AppFeature createMany
   */
  export type AppFeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppFeatures.
     */
    data: AppFeatureCreateManyInput | AppFeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppFeature update
   */
  export type AppFeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a AppFeature.
     */
    data: XOR<AppFeatureUpdateInput, AppFeatureUncheckedUpdateInput>
    /**
     * Choose, which AppFeature to update.
     */
    where: AppFeatureWhereUniqueInput
  }

  /**
   * AppFeature updateMany
   */
  export type AppFeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppFeatures.
     */
    data: XOR<AppFeatureUpdateManyMutationInput, AppFeatureUncheckedUpdateManyInput>
    /**
     * Filter which AppFeatures to update
     */
    where?: AppFeatureWhereInput
    /**
     * Limit how many AppFeatures to update.
     */
    limit?: number
  }

  /**
   * AppFeature upsert
   */
  export type AppFeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the AppFeature to update in case it exists.
     */
    where: AppFeatureWhereUniqueInput
    /**
     * In case the AppFeature found by the `where` argument doesn't exist, create a new AppFeature with this data.
     */
    create: XOR<AppFeatureCreateInput, AppFeatureUncheckedCreateInput>
    /**
     * In case the AppFeature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppFeatureUpdateInput, AppFeatureUncheckedUpdateInput>
  }

  /**
   * AppFeature delete
   */
  export type AppFeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
    /**
     * Filter which AppFeature to delete.
     */
    where: AppFeatureWhereUniqueInput
  }

  /**
   * AppFeature deleteMany
   */
  export type AppFeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppFeatures to delete
     */
    where?: AppFeatureWhereInput
    /**
     * Limit how many AppFeatures to delete.
     */
    limit?: number
  }

  /**
   * AppFeature without action
   */
  export type AppFeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppFeature
     */
    select?: AppFeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppFeature
     */
    omit?: AppFeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFeatureInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>



  export type AdminSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
  }


  /**
   * Model ProjectStatusHistory
   */

  export type AggregateProjectStatusHistory = {
    _count: ProjectStatusHistoryCountAggregateOutputType | null
    _avg: ProjectStatusHistoryAvgAggregateOutputType | null
    _sum: ProjectStatusHistorySumAggregateOutputType | null
    _min: ProjectStatusHistoryMinAggregateOutputType | null
    _max: ProjectStatusHistoryMaxAggregateOutputType | null
  }

  export type ProjectStatusHistoryAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectStatusHistorySumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectStatusHistoryMinAggregateOutputType = {
    id: number | null
    projectId: number | null
    oldStatus: string | null
    newStatus: string | null
    changedBy: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ProjectStatusHistoryMaxAggregateOutputType = {
    id: number | null
    projectId: number | null
    oldStatus: string | null
    newStatus: string | null
    changedBy: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ProjectStatusHistoryCountAggregateOutputType = {
    id: number
    projectId: number
    oldStatus: number
    newStatus: number
    changedBy: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ProjectStatusHistoryAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectStatusHistorySumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectStatusHistoryMinAggregateInputType = {
    id?: true
    projectId?: true
    oldStatus?: true
    newStatus?: true
    changedBy?: true
    notes?: true
    createdAt?: true
  }

  export type ProjectStatusHistoryMaxAggregateInputType = {
    id?: true
    projectId?: true
    oldStatus?: true
    newStatus?: true
    changedBy?: true
    notes?: true
    createdAt?: true
  }

  export type ProjectStatusHistoryCountAggregateInputType = {
    id?: true
    projectId?: true
    oldStatus?: true
    newStatus?: true
    changedBy?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ProjectStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStatusHistory to aggregate.
     */
    where?: ProjectStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusHistories to fetch.
     */
    orderBy?: ProjectStatusHistoryOrderByWithRelationInput | ProjectStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectStatusHistories
    **/
    _count?: true | ProjectStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectStatusHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectStatusHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectStatusHistoryMaxAggregateInputType
  }

  export type GetProjectStatusHistoryAggregateType<T extends ProjectStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectStatusHistory[P]>
      : GetScalarType<T[P], AggregateProjectStatusHistory[P]>
  }




  export type ProjectStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectStatusHistoryWhereInput
    orderBy?: ProjectStatusHistoryOrderByWithAggregationInput | ProjectStatusHistoryOrderByWithAggregationInput[]
    by: ProjectStatusHistoryScalarFieldEnum[] | ProjectStatusHistoryScalarFieldEnum
    having?: ProjectStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectStatusHistoryCountAggregateInputType | true
    _avg?: ProjectStatusHistoryAvgAggregateInputType
    _sum?: ProjectStatusHistorySumAggregateInputType
    _min?: ProjectStatusHistoryMinAggregateInputType
    _max?: ProjectStatusHistoryMaxAggregateInputType
  }

  export type ProjectStatusHistoryGroupByOutputType = {
    id: number
    projectId: number
    oldStatus: string | null
    newStatus: string
    changedBy: string | null
    notes: string | null
    createdAt: Date
    _count: ProjectStatusHistoryCountAggregateOutputType | null
    _avg: ProjectStatusHistoryAvgAggregateOutputType | null
    _sum: ProjectStatusHistorySumAggregateOutputType | null
    _min: ProjectStatusHistoryMinAggregateOutputType | null
    _max: ProjectStatusHistoryMaxAggregateOutputType | null
  }

  type GetProjectStatusHistoryGroupByPayload<T extends ProjectStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ProjectStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    notes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["projectStatusHistory"]>



  export type ProjectStatusHistorySelectScalar = {
    id?: boolean
    projectId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ProjectStatusHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "oldStatus" | "newStatus" | "changedBy" | "notes" | "createdAt", ExtArgs["result"]["projectStatusHistory"]>

  export type $ProjectStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectStatusHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      projectId: number
      oldStatus: string | null
      newStatus: string
      changedBy: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["projectStatusHistory"]>
    composites: {}
  }

  type ProjectStatusHistoryGetPayload<S extends boolean | null | undefined | ProjectStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$ProjectStatusHistoryPayload, S>

  type ProjectStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectStatusHistoryCountAggregateInputType | true
    }

  export interface ProjectStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectStatusHistory'], meta: { name: 'ProjectStatusHistory' } }
    /**
     * Find zero or one ProjectStatusHistory that matches the filter.
     * @param {ProjectStatusHistoryFindUniqueArgs} args - Arguments to find a ProjectStatusHistory
     * @example
     * // Get one ProjectStatusHistory
     * const projectStatusHistory = await prisma.projectStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectStatusHistoryFindUniqueArgs>(args: SelectSubset<T, ProjectStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__ProjectStatusHistoryClient<$Result.GetResult<Prisma.$ProjectStatusHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectStatusHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a ProjectStatusHistory
     * @example
     * // Get one ProjectStatusHistory
     * const projectStatusHistory = await prisma.projectStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectStatusHistoryClient<$Result.GetResult<Prisma.$ProjectStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusHistoryFindFirstArgs} args - Arguments to find a ProjectStatusHistory
     * @example
     * // Get one ProjectStatusHistory
     * const projectStatusHistory = await prisma.projectStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectStatusHistoryFindFirstArgs>(args?: SelectSubset<T, ProjectStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__ProjectStatusHistoryClient<$Result.GetResult<Prisma.$ProjectStatusHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a ProjectStatusHistory
     * @example
     * // Get one ProjectStatusHistory
     * const projectStatusHistory = await prisma.projectStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectStatusHistoryClient<$Result.GetResult<Prisma.$ProjectStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectStatusHistories
     * const projectStatusHistories = await prisma.projectStatusHistory.findMany()
     * 
     * // Get first 10 ProjectStatusHistories
     * const projectStatusHistories = await prisma.projectStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectStatusHistoryWithIdOnly = await prisma.projectStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectStatusHistoryFindManyArgs>(args?: SelectSubset<T, ProjectStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStatusHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectStatusHistory.
     * @param {ProjectStatusHistoryCreateArgs} args - Arguments to create a ProjectStatusHistory.
     * @example
     * // Create one ProjectStatusHistory
     * const ProjectStatusHistory = await prisma.projectStatusHistory.create({
     *   data: {
     *     // ... data to create a ProjectStatusHistory
     *   }
     * })
     * 
     */
    create<T extends ProjectStatusHistoryCreateArgs>(args: SelectSubset<T, ProjectStatusHistoryCreateArgs<ExtArgs>>): Prisma__ProjectStatusHistoryClient<$Result.GetResult<Prisma.$ProjectStatusHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectStatusHistories.
     * @param {ProjectStatusHistoryCreateManyArgs} args - Arguments to create many ProjectStatusHistories.
     * @example
     * // Create many ProjectStatusHistories
     * const projectStatusHistory = await prisma.projectStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectStatusHistoryCreateManyArgs>(args?: SelectSubset<T, ProjectStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectStatusHistory.
     * @param {ProjectStatusHistoryDeleteArgs} args - Arguments to delete one ProjectStatusHistory.
     * @example
     * // Delete one ProjectStatusHistory
     * const ProjectStatusHistory = await prisma.projectStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one ProjectStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends ProjectStatusHistoryDeleteArgs>(args: SelectSubset<T, ProjectStatusHistoryDeleteArgs<ExtArgs>>): Prisma__ProjectStatusHistoryClient<$Result.GetResult<Prisma.$ProjectStatusHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectStatusHistory.
     * @param {ProjectStatusHistoryUpdateArgs} args - Arguments to update one ProjectStatusHistory.
     * @example
     * // Update one ProjectStatusHistory
     * const projectStatusHistory = await prisma.projectStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectStatusHistoryUpdateArgs>(args: SelectSubset<T, ProjectStatusHistoryUpdateArgs<ExtArgs>>): Prisma__ProjectStatusHistoryClient<$Result.GetResult<Prisma.$ProjectStatusHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectStatusHistories.
     * @param {ProjectStatusHistoryDeleteManyArgs} args - Arguments to filter ProjectStatusHistories to delete.
     * @example
     * // Delete a few ProjectStatusHistories
     * const { count } = await prisma.projectStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, ProjectStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectStatusHistories
     * const projectStatusHistory = await prisma.projectStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectStatusHistoryUpdateManyArgs>(args: SelectSubset<T, ProjectStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectStatusHistory.
     * @param {ProjectStatusHistoryUpsertArgs} args - Arguments to update or create a ProjectStatusHistory.
     * @example
     * // Update or create a ProjectStatusHistory
     * const projectStatusHistory = await prisma.projectStatusHistory.upsert({
     *   create: {
     *     // ... data to create a ProjectStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends ProjectStatusHistoryUpsertArgs>(args: SelectSubset<T, ProjectStatusHistoryUpsertArgs<ExtArgs>>): Prisma__ProjectStatusHistoryClient<$Result.GetResult<Prisma.$ProjectStatusHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusHistoryCountArgs} args - Arguments to filter ProjectStatusHistories to count.
     * @example
     * // Count the number of ProjectStatusHistories
     * const count = await prisma.projectStatusHistory.count({
     *   where: {
     *     // ... the filter for the ProjectStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends ProjectStatusHistoryCountArgs>(
      args?: Subset<T, ProjectStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectStatusHistoryAggregateArgs>(args: Subset<T, ProjectStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetProjectStatusHistoryAggregateType<T>>

    /**
     * Group by ProjectStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ProjectStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectStatusHistory model
   */
  readonly fields: ProjectStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectStatusHistory model
   */
  interface ProjectStatusHistoryFieldRefs {
    readonly id: FieldRef<"ProjectStatusHistory", 'Int'>
    readonly projectId: FieldRef<"ProjectStatusHistory", 'Int'>
    readonly oldStatus: FieldRef<"ProjectStatusHistory", 'String'>
    readonly newStatus: FieldRef<"ProjectStatusHistory", 'String'>
    readonly changedBy: FieldRef<"ProjectStatusHistory", 'String'>
    readonly notes: FieldRef<"ProjectStatusHistory", 'String'>
    readonly createdAt: FieldRef<"ProjectStatusHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectStatusHistory findUnique
   */
  export type ProjectStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStatusHistory to fetch.
     */
    where: ProjectStatusHistoryWhereUniqueInput
  }

  /**
   * ProjectStatusHistory findUniqueOrThrow
   */
  export type ProjectStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStatusHistory to fetch.
     */
    where: ProjectStatusHistoryWhereUniqueInput
  }

  /**
   * ProjectStatusHistory findFirst
   */
  export type ProjectStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStatusHistory to fetch.
     */
    where?: ProjectStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusHistories to fetch.
     */
    orderBy?: ProjectStatusHistoryOrderByWithRelationInput | ProjectStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStatusHistories.
     */
    cursor?: ProjectStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStatusHistories.
     */
    distinct?: ProjectStatusHistoryScalarFieldEnum | ProjectStatusHistoryScalarFieldEnum[]
  }

  /**
   * ProjectStatusHistory findFirstOrThrow
   */
  export type ProjectStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStatusHistory to fetch.
     */
    where?: ProjectStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusHistories to fetch.
     */
    orderBy?: ProjectStatusHistoryOrderByWithRelationInput | ProjectStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStatusHistories.
     */
    cursor?: ProjectStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStatusHistories.
     */
    distinct?: ProjectStatusHistoryScalarFieldEnum | ProjectStatusHistoryScalarFieldEnum[]
  }

  /**
   * ProjectStatusHistory findMany
   */
  export type ProjectStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStatusHistories to fetch.
     */
    where?: ProjectStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStatusHistories to fetch.
     */
    orderBy?: ProjectStatusHistoryOrderByWithRelationInput | ProjectStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectStatusHistories.
     */
    cursor?: ProjectStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStatusHistories.
     */
    skip?: number
    distinct?: ProjectStatusHistoryScalarFieldEnum | ProjectStatusHistoryScalarFieldEnum[]
  }

  /**
   * ProjectStatusHistory create
   */
  export type ProjectStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
    /**
     * The data needed to create a ProjectStatusHistory.
     */
    data: XOR<ProjectStatusHistoryCreateInput, ProjectStatusHistoryUncheckedCreateInput>
  }

  /**
   * ProjectStatusHistory createMany
   */
  export type ProjectStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectStatusHistories.
     */
    data: ProjectStatusHistoryCreateManyInput | ProjectStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectStatusHistory update
   */
  export type ProjectStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
    /**
     * The data needed to update a ProjectStatusHistory.
     */
    data: XOR<ProjectStatusHistoryUpdateInput, ProjectStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which ProjectStatusHistory to update.
     */
    where: ProjectStatusHistoryWhereUniqueInput
  }

  /**
   * ProjectStatusHistory updateMany
   */
  export type ProjectStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectStatusHistories.
     */
    data: XOR<ProjectStatusHistoryUpdateManyMutationInput, ProjectStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ProjectStatusHistories to update
     */
    where?: ProjectStatusHistoryWhereInput
    /**
     * Limit how many ProjectStatusHistories to update.
     */
    limit?: number
  }

  /**
   * ProjectStatusHistory upsert
   */
  export type ProjectStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
    /**
     * The filter to search for the ProjectStatusHistory to update in case it exists.
     */
    where: ProjectStatusHistoryWhereUniqueInput
    /**
     * In case the ProjectStatusHistory found by the `where` argument doesn't exist, create a new ProjectStatusHistory with this data.
     */
    create: XOR<ProjectStatusHistoryCreateInput, ProjectStatusHistoryUncheckedCreateInput>
    /**
     * In case the ProjectStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectStatusHistoryUpdateInput, ProjectStatusHistoryUncheckedUpdateInput>
  }

  /**
   * ProjectStatusHistory delete
   */
  export type ProjectStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
    /**
     * Filter which ProjectStatusHistory to delete.
     */
    where: ProjectStatusHistoryWhereUniqueInput
  }

  /**
   * ProjectStatusHistory deleteMany
   */
  export type ProjectStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStatusHistories to delete
     */
    where?: ProjectStatusHistoryWhereInput
    /**
     * Limit how many ProjectStatusHistories to delete.
     */
    limit?: number
  }

  /**
   * ProjectStatusHistory without action
   */
  export type ProjectStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStatusHistory
     */
    select?: ProjectStatusHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStatusHistory
     */
    omit?: ProjectStatusHistoryOmit<ExtArgs> | null
  }


  /**
   * Model PortfolioProject
   */

  export type AggregatePortfolioProject = {
    _count: PortfolioProjectCountAggregateOutputType | null
    _avg: PortfolioProjectAvgAggregateOutputType | null
    _sum: PortfolioProjectSumAggregateOutputType | null
    _min: PortfolioProjectMinAggregateOutputType | null
    _max: PortfolioProjectMaxAggregateOutputType | null
  }

  export type PortfolioProjectAvgAggregateOutputType = {
    id: number | null
  }

  export type PortfolioProjectSumAggregateOutputType = {
    id: number | null
  }

  export type PortfolioProjectMinAggregateOutputType = {
    id: number | null
    title: string | null
    category: string | null
    image: string | null
    description: string | null
    technologies: string | null
    liveUrl: string | null
    githubUrl: string | null
    featured: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioProjectMaxAggregateOutputType = {
    id: number | null
    title: string | null
    category: string | null
    image: string | null
    description: string | null
    technologies: string | null
    liveUrl: string | null
    githubUrl: string | null
    featured: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortfolioProjectCountAggregateOutputType = {
    id: number
    title: number
    category: number
    image: number
    description: number
    technologies: number
    liveUrl: number
    githubUrl: number
    featured: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortfolioProjectAvgAggregateInputType = {
    id?: true
  }

  export type PortfolioProjectSumAggregateInputType = {
    id?: true
  }

  export type PortfolioProjectMinAggregateInputType = {
    id?: true
    title?: true
    category?: true
    image?: true
    description?: true
    technologies?: true
    liveUrl?: true
    githubUrl?: true
    featured?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioProjectMaxAggregateInputType = {
    id?: true
    title?: true
    category?: true
    image?: true
    description?: true
    technologies?: true
    liveUrl?: true
    githubUrl?: true
    featured?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortfolioProjectCountAggregateInputType = {
    id?: true
    title?: true
    category?: true
    image?: true
    description?: true
    technologies?: true
    liveUrl?: true
    githubUrl?: true
    featured?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortfolioProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioProject to aggregate.
     */
    where?: PortfolioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioProjects to fetch.
     */
    orderBy?: PortfolioProjectOrderByWithRelationInput | PortfolioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioProjects
    **/
    _count?: true | PortfolioProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortfolioProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortfolioProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioProjectMaxAggregateInputType
  }

  export type GetPortfolioProjectAggregateType<T extends PortfolioProjectAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioProject[P]>
      : GetScalarType<T[P], AggregatePortfolioProject[P]>
  }




  export type PortfolioProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioProjectWhereInput
    orderBy?: PortfolioProjectOrderByWithAggregationInput | PortfolioProjectOrderByWithAggregationInput[]
    by: PortfolioProjectScalarFieldEnum[] | PortfolioProjectScalarFieldEnum
    having?: PortfolioProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioProjectCountAggregateInputType | true
    _avg?: PortfolioProjectAvgAggregateInputType
    _sum?: PortfolioProjectSumAggregateInputType
    _min?: PortfolioProjectMinAggregateInputType
    _max?: PortfolioProjectMaxAggregateInputType
  }

  export type PortfolioProjectGroupByOutputType = {
    id: number
    title: string
    category: string
    image: string
    description: string
    technologies: string
    liveUrl: string
    githubUrl: string | null
    featured: boolean
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PortfolioProjectCountAggregateOutputType | null
    _avg: PortfolioProjectAvgAggregateOutputType | null
    _sum: PortfolioProjectSumAggregateOutputType | null
    _min: PortfolioProjectMinAggregateOutputType | null
    _max: PortfolioProjectMaxAggregateOutputType | null
  }

  type GetPortfolioProjectGroupByPayload<T extends PortfolioProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioProjectGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioProjectGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    category?: boolean
    image?: boolean
    description?: boolean
    technologies?: boolean
    liveUrl?: boolean
    githubUrl?: boolean
    featured?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["portfolioProject"]>



  export type PortfolioProjectSelectScalar = {
    id?: boolean
    title?: boolean
    category?: boolean
    image?: boolean
    description?: boolean
    technologies?: boolean
    liveUrl?: boolean
    githubUrl?: boolean
    featured?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortfolioProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "category" | "image" | "description" | "technologies" | "liveUrl" | "githubUrl" | "featured" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["portfolioProject"]>

  export type $PortfolioProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioProject"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      category: string
      image: string
      description: string
      technologies: string
      liveUrl: string
      githubUrl: string | null
      featured: boolean
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portfolioProject"]>
    composites: {}
  }

  type PortfolioProjectGetPayload<S extends boolean | null | undefined | PortfolioProjectDefaultArgs> = $Result.GetResult<Prisma.$PortfolioProjectPayload, S>

  type PortfolioProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioProjectCountAggregateInputType | true
    }

  export interface PortfolioProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioProject'], meta: { name: 'PortfolioProject' } }
    /**
     * Find zero or one PortfolioProject that matches the filter.
     * @param {PortfolioProjectFindUniqueArgs} args - Arguments to find a PortfolioProject
     * @example
     * // Get one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioProjectFindUniqueArgs>(args: SelectSubset<T, PortfolioProjectFindUniqueArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PortfolioProject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioProjectFindUniqueOrThrowArgs} args - Arguments to find a PortfolioProject
     * @example
     * // Get one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectFindFirstArgs} args - Arguments to find a PortfolioProject
     * @example
     * // Get one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioProjectFindFirstArgs>(args?: SelectSubset<T, PortfolioProjectFindFirstArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortfolioProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectFindFirstOrThrowArgs} args - Arguments to find a PortfolioProject
     * @example
     * // Get one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PortfolioProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProject.findMany()
     * 
     * // Get first 10 PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioProjectWithIdOnly = await prisma.portfolioProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioProjectFindManyArgs>(args?: SelectSubset<T, PortfolioProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PortfolioProject.
     * @param {PortfolioProjectCreateArgs} args - Arguments to create a PortfolioProject.
     * @example
     * // Create one PortfolioProject
     * const PortfolioProject = await prisma.portfolioProject.create({
     *   data: {
     *     // ... data to create a PortfolioProject
     *   }
     * })
     * 
     */
    create<T extends PortfolioProjectCreateArgs>(args: SelectSubset<T, PortfolioProjectCreateArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PortfolioProjects.
     * @param {PortfolioProjectCreateManyArgs} args - Arguments to create many PortfolioProjects.
     * @example
     * // Create many PortfolioProjects
     * const portfolioProject = await prisma.portfolioProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioProjectCreateManyArgs>(args?: SelectSubset<T, PortfolioProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PortfolioProject.
     * @param {PortfolioProjectDeleteArgs} args - Arguments to delete one PortfolioProject.
     * @example
     * // Delete one PortfolioProject
     * const PortfolioProject = await prisma.portfolioProject.delete({
     *   where: {
     *     // ... filter to delete one PortfolioProject
     *   }
     * })
     * 
     */
    delete<T extends PortfolioProjectDeleteArgs>(args: SelectSubset<T, PortfolioProjectDeleteArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PortfolioProject.
     * @param {PortfolioProjectUpdateArgs} args - Arguments to update one PortfolioProject.
     * @example
     * // Update one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioProjectUpdateArgs>(args: SelectSubset<T, PortfolioProjectUpdateArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PortfolioProjects.
     * @param {PortfolioProjectDeleteManyArgs} args - Arguments to filter PortfolioProjects to delete.
     * @example
     * // Delete a few PortfolioProjects
     * const { count } = await prisma.portfolioProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioProjectDeleteManyArgs>(args?: SelectSubset<T, PortfolioProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioProjects
     * const portfolioProject = await prisma.portfolioProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioProjectUpdateManyArgs>(args: SelectSubset<T, PortfolioProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PortfolioProject.
     * @param {PortfolioProjectUpsertArgs} args - Arguments to update or create a PortfolioProject.
     * @example
     * // Update or create a PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.upsert({
     *   create: {
     *     // ... data to create a PortfolioProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioProject we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioProjectUpsertArgs>(args: SelectSubset<T, PortfolioProjectUpsertArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PortfolioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectCountArgs} args - Arguments to filter PortfolioProjects to count.
     * @example
     * // Count the number of PortfolioProjects
     * const count = await prisma.portfolioProject.count({
     *   where: {
     *     // ... the filter for the PortfolioProjects we want to count
     *   }
     * })
    **/
    count<T extends PortfolioProjectCountArgs>(
      args?: Subset<T, PortfolioProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioProjectAggregateArgs>(args: Subset<T, PortfolioProjectAggregateArgs>): Prisma.PrismaPromise<GetPortfolioProjectAggregateType<T>>

    /**
     * Group by PortfolioProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioProjectGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioProject model
   */
  readonly fields: PortfolioProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioProject model
   */
  interface PortfolioProjectFieldRefs {
    readonly id: FieldRef<"PortfolioProject", 'Int'>
    readonly title: FieldRef<"PortfolioProject", 'String'>
    readonly category: FieldRef<"PortfolioProject", 'String'>
    readonly image: FieldRef<"PortfolioProject", 'String'>
    readonly description: FieldRef<"PortfolioProject", 'String'>
    readonly technologies: FieldRef<"PortfolioProject", 'String'>
    readonly liveUrl: FieldRef<"PortfolioProject", 'String'>
    readonly githubUrl: FieldRef<"PortfolioProject", 'String'>
    readonly featured: FieldRef<"PortfolioProject", 'Boolean'>
    readonly status: FieldRef<"PortfolioProject", 'String'>
    readonly createdAt: FieldRef<"PortfolioProject", 'DateTime'>
    readonly updatedAt: FieldRef<"PortfolioProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioProject findUnique
   */
  export type PortfolioProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
    /**
     * Filter, which PortfolioProject to fetch.
     */
    where: PortfolioProjectWhereUniqueInput
  }

  /**
   * PortfolioProject findUniqueOrThrow
   */
  export type PortfolioProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
    /**
     * Filter, which PortfolioProject to fetch.
     */
    where: PortfolioProjectWhereUniqueInput
  }

  /**
   * PortfolioProject findFirst
   */
  export type PortfolioProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
    /**
     * Filter, which PortfolioProject to fetch.
     */
    where?: PortfolioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioProjects to fetch.
     */
    orderBy?: PortfolioProjectOrderByWithRelationInput | PortfolioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioProjects.
     */
    cursor?: PortfolioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioProjects.
     */
    distinct?: PortfolioProjectScalarFieldEnum | PortfolioProjectScalarFieldEnum[]
  }

  /**
   * PortfolioProject findFirstOrThrow
   */
  export type PortfolioProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
    /**
     * Filter, which PortfolioProject to fetch.
     */
    where?: PortfolioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioProjects to fetch.
     */
    orderBy?: PortfolioProjectOrderByWithRelationInput | PortfolioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioProjects.
     */
    cursor?: PortfolioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioProjects.
     */
    distinct?: PortfolioProjectScalarFieldEnum | PortfolioProjectScalarFieldEnum[]
  }

  /**
   * PortfolioProject findMany
   */
  export type PortfolioProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
    /**
     * Filter, which PortfolioProjects to fetch.
     */
    where?: PortfolioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioProjects to fetch.
     */
    orderBy?: PortfolioProjectOrderByWithRelationInput | PortfolioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioProjects.
     */
    cursor?: PortfolioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioProjects.
     */
    skip?: number
    distinct?: PortfolioProjectScalarFieldEnum | PortfolioProjectScalarFieldEnum[]
  }

  /**
   * PortfolioProject create
   */
  export type PortfolioProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
    /**
     * The data needed to create a PortfolioProject.
     */
    data: XOR<PortfolioProjectCreateInput, PortfolioProjectUncheckedCreateInput>
  }

  /**
   * PortfolioProject createMany
   */
  export type PortfolioProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioProjects.
     */
    data: PortfolioProjectCreateManyInput | PortfolioProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortfolioProject update
   */
  export type PortfolioProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
    /**
     * The data needed to update a PortfolioProject.
     */
    data: XOR<PortfolioProjectUpdateInput, PortfolioProjectUncheckedUpdateInput>
    /**
     * Choose, which PortfolioProject to update.
     */
    where: PortfolioProjectWhereUniqueInput
  }

  /**
   * PortfolioProject updateMany
   */
  export type PortfolioProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioProjects.
     */
    data: XOR<PortfolioProjectUpdateManyMutationInput, PortfolioProjectUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioProjects to update
     */
    where?: PortfolioProjectWhereInput
    /**
     * Limit how many PortfolioProjects to update.
     */
    limit?: number
  }

  /**
   * PortfolioProject upsert
   */
  export type PortfolioProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
    /**
     * The filter to search for the PortfolioProject to update in case it exists.
     */
    where: PortfolioProjectWhereUniqueInput
    /**
     * In case the PortfolioProject found by the `where` argument doesn't exist, create a new PortfolioProject with this data.
     */
    create: XOR<PortfolioProjectCreateInput, PortfolioProjectUncheckedCreateInput>
    /**
     * In case the PortfolioProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioProjectUpdateInput, PortfolioProjectUncheckedUpdateInput>
  }

  /**
   * PortfolioProject delete
   */
  export type PortfolioProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
    /**
     * Filter which PortfolioProject to delete.
     */
    where: PortfolioProjectWhereUniqueInput
  }

  /**
   * PortfolioProject deleteMany
   */
  export type PortfolioProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioProjects to delete
     */
    where?: PortfolioProjectWhereInput
    /**
     * Limit how many PortfolioProjects to delete.
     */
    limit?: number
  }

  /**
   * PortfolioProject without action
   */
  export type PortfolioProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortfolioProject
     */
    omit?: PortfolioProjectOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    full_name: 'full_name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ContactFormScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ContactFormScalarFieldEnum = (typeof ContactFormScalarFieldEnum)[keyof typeof ContactFormScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    projectName: 'projectName',
    projectTitle: 'projectTitle',
    category: 'category',
    price: 'price',
    deadline: 'deadline',
    details: 'details',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const WebDevelopmentDetailScalarFieldEnum: {
    id: 'id',
    tech: 'tech',
    webPages: 'webPages',
    projectId: 'projectId'
  };

  export type WebDevelopmentDetailScalarFieldEnum = (typeof WebDevelopmentDetailScalarFieldEnum)[keyof typeof WebDevelopmentDetailScalarFieldEnum]


  export const WebDevelopmentFeatureScalarFieldEnum: {
    id: 'id',
    feature: 'feature',
    price: 'price',
    webDevDetailId: 'webDevDetailId'
  };

  export type WebDevelopmentFeatureScalarFieldEnum = (typeof WebDevelopmentFeatureScalarFieldEnum)[keyof typeof WebDevelopmentFeatureScalarFieldEnum]


  export const SeoDetailScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type SeoDetailScalarFieldEnum = (typeof SeoDetailScalarFieldEnum)[keyof typeof SeoDetailScalarFieldEnum]


  export const SeoTypeScalarFieldEnum: {
    id: 'id',
    seoType: 'seoType',
    price: 'price',
    seoDetailId: 'seoDetailId'
  };

  export type SeoTypeScalarFieldEnum = (typeof SeoTypeScalarFieldEnum)[keyof typeof SeoTypeScalarFieldEnum]


  export const DigitalMarketingDetailScalarFieldEnum: {
    id: 'id',
    targetAudience: 'targetAudience',
    marketingBudget: 'marketingBudget',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type DigitalMarketingDetailScalarFieldEnum = (typeof DigitalMarketingDetailScalarFieldEnum)[keyof typeof DigitalMarketingDetailScalarFieldEnum]


  export const DigitalMarketingServiceScalarFieldEnum: {
    id: 'id',
    service: 'service',
    price: 'price',
    digitalMarketingDetailId: 'digitalMarketingDetailId'
  };

  export type DigitalMarketingServiceScalarFieldEnum = (typeof DigitalMarketingServiceScalarFieldEnum)[keyof typeof DigitalMarketingServiceScalarFieldEnum]


  export const SocialPlatformScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    price: 'price',
    digitalMarketingDetailId: 'digitalMarketingDetailId'
  };

  export type SocialPlatformScalarFieldEnum = (typeof SocialPlatformScalarFieldEnum)[keyof typeof SocialPlatformScalarFieldEnum]


  export const ContentGenerationDetailScalarFieldEnum: {
    id: 'id',
    volume: 'volume',
    contentTone: 'contentTone',
    targetKeywords: 'targetKeywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type ContentGenerationDetailScalarFieldEnum = (typeof ContentGenerationDetailScalarFieldEnum)[keyof typeof ContentGenerationDetailScalarFieldEnum]


  export const ContentTypeScalarFieldEnum: {
    id: 'id',
    contentType: 'contentType',
    price: 'price',
    contentGenerationDetailId: 'contentGenerationDetailId'
  };

  export type ContentTypeScalarFieldEnum = (typeof ContentTypeScalarFieldEnum)[keyof typeof ContentTypeScalarFieldEnum]


  export const ContentLanguageScalarFieldEnum: {
    id: 'id',
    language: 'language',
    price: 'price',
    contentGenerationDetailId: 'contentGenerationDetailId'
  };

  export type ContentLanguageScalarFieldEnum = (typeof ContentLanguageScalarFieldEnum)[keyof typeof ContentLanguageScalarFieldEnum]


  export const AppDevelopmentDetailScalarFieldEnum: {
    id: 'id',
    appType: 'appType',
    complexity: 'complexity',
    targetPlatforms: 'targetPlatforms',
    expectedUsers: 'expectedUsers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type AppDevelopmentDetailScalarFieldEnum = (typeof AppDevelopmentDetailScalarFieldEnum)[keyof typeof AppDevelopmentDetailScalarFieldEnum]


  export const AppFeatureScalarFieldEnum: {
    id: 'id',
    feature: 'feature',
    price: 'price',
    appDevelopmentDetailId: 'appDevelopmentDetailId'
  };

  export type AppFeatureScalarFieldEnum = (typeof AppFeatureScalarFieldEnum)[keyof typeof AppFeatureScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ProjectStatusHistoryScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    oldStatus: 'oldStatus',
    newStatus: 'newStatus',
    changedBy: 'changedBy',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ProjectStatusHistoryScalarFieldEnum = (typeof ProjectStatusHistoryScalarFieldEnum)[keyof typeof ProjectStatusHistoryScalarFieldEnum]


  export const PortfolioProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    category: 'category',
    image: 'image',
    description: 'description',
    technologies: 'technologies',
    liveUrl: 'liveUrl',
    githubUrl: 'githubUrl',
    featured: 'featured',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortfolioProjectScalarFieldEnum = (typeof PortfolioProjectScalarFieldEnum)[keyof typeof PortfolioProjectScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    password: 'password',
    full_name: 'full_name'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const ContactFormOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message'
  };

  export type ContactFormOrderByRelevanceFieldEnum = (typeof ContactFormOrderByRelevanceFieldEnum)[keyof typeof ContactFormOrderByRelevanceFieldEnum]


  export const ProjectOrderByRelevanceFieldEnum: {
    username: 'username',
    email: 'email',
    password: 'password',
    projectName: 'projectName',
    projectTitle: 'projectTitle',
    category: 'category',
    deadline: 'deadline',
    details: 'details',
    status: 'status'
  };

  export type ProjectOrderByRelevanceFieldEnum = (typeof ProjectOrderByRelevanceFieldEnum)[keyof typeof ProjectOrderByRelevanceFieldEnum]


  export const WebDevelopmentDetailOrderByRelevanceFieldEnum: {
    tech: 'tech'
  };

  export type WebDevelopmentDetailOrderByRelevanceFieldEnum = (typeof WebDevelopmentDetailOrderByRelevanceFieldEnum)[keyof typeof WebDevelopmentDetailOrderByRelevanceFieldEnum]


  export const WebDevelopmentFeatureOrderByRelevanceFieldEnum: {
    feature: 'feature'
  };

  export type WebDevelopmentFeatureOrderByRelevanceFieldEnum = (typeof WebDevelopmentFeatureOrderByRelevanceFieldEnum)[keyof typeof WebDevelopmentFeatureOrderByRelevanceFieldEnum]


  export const SeoTypeOrderByRelevanceFieldEnum: {
    seoType: 'seoType'
  };

  export type SeoTypeOrderByRelevanceFieldEnum = (typeof SeoTypeOrderByRelevanceFieldEnum)[keyof typeof SeoTypeOrderByRelevanceFieldEnum]


  export const DigitalMarketingDetailOrderByRelevanceFieldEnum: {
    targetAudience: 'targetAudience',
    duration: 'duration'
  };

  export type DigitalMarketingDetailOrderByRelevanceFieldEnum = (typeof DigitalMarketingDetailOrderByRelevanceFieldEnum)[keyof typeof DigitalMarketingDetailOrderByRelevanceFieldEnum]


  export const DigitalMarketingServiceOrderByRelevanceFieldEnum: {
    service: 'service'
  };

  export type DigitalMarketingServiceOrderByRelevanceFieldEnum = (typeof DigitalMarketingServiceOrderByRelevanceFieldEnum)[keyof typeof DigitalMarketingServiceOrderByRelevanceFieldEnum]


  export const SocialPlatformOrderByRelevanceFieldEnum: {
    platform: 'platform'
  };

  export type SocialPlatformOrderByRelevanceFieldEnum = (typeof SocialPlatformOrderByRelevanceFieldEnum)[keyof typeof SocialPlatformOrderByRelevanceFieldEnum]


  export const ContentGenerationDetailOrderByRelevanceFieldEnum: {
    volume: 'volume',
    contentTone: 'contentTone',
    targetKeywords: 'targetKeywords'
  };

  export type ContentGenerationDetailOrderByRelevanceFieldEnum = (typeof ContentGenerationDetailOrderByRelevanceFieldEnum)[keyof typeof ContentGenerationDetailOrderByRelevanceFieldEnum]


  export const ContentTypeOrderByRelevanceFieldEnum: {
    contentType: 'contentType'
  };

  export type ContentTypeOrderByRelevanceFieldEnum = (typeof ContentTypeOrderByRelevanceFieldEnum)[keyof typeof ContentTypeOrderByRelevanceFieldEnum]


  export const ContentLanguageOrderByRelevanceFieldEnum: {
    language: 'language'
  };

  export type ContentLanguageOrderByRelevanceFieldEnum = (typeof ContentLanguageOrderByRelevanceFieldEnum)[keyof typeof ContentLanguageOrderByRelevanceFieldEnum]


  export const AppDevelopmentDetailOrderByRelevanceFieldEnum: {
    appType: 'appType',
    complexity: 'complexity',
    targetPlatforms: 'targetPlatforms'
  };

  export type AppDevelopmentDetailOrderByRelevanceFieldEnum = (typeof AppDevelopmentDetailOrderByRelevanceFieldEnum)[keyof typeof AppDevelopmentDetailOrderByRelevanceFieldEnum]


  export const AppFeatureOrderByRelevanceFieldEnum: {
    feature: 'feature'
  };

  export type AppFeatureOrderByRelevanceFieldEnum = (typeof AppFeatureOrderByRelevanceFieldEnum)[keyof typeof AppFeatureOrderByRelevanceFieldEnum]


  export const AdminOrderByRelevanceFieldEnum: {
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role'
  };

  export type AdminOrderByRelevanceFieldEnum = (typeof AdminOrderByRelevanceFieldEnum)[keyof typeof AdminOrderByRelevanceFieldEnum]


  export const ProjectStatusHistoryOrderByRelevanceFieldEnum: {
    oldStatus: 'oldStatus',
    newStatus: 'newStatus',
    changedBy: 'changedBy',
    notes: 'notes'
  };

  export type ProjectStatusHistoryOrderByRelevanceFieldEnum = (typeof ProjectStatusHistoryOrderByRelevanceFieldEnum)[keyof typeof ProjectStatusHistoryOrderByRelevanceFieldEnum]


  export const PortfolioProjectOrderByRelevanceFieldEnum: {
    title: 'title',
    category: 'category',
    image: 'image',
    description: 'description',
    technologies: 'technologies',
    liveUrl: 'liveUrl',
    githubUrl: 'githubUrl',
    status: 'status'
  };

  export type PortfolioProjectOrderByRelevanceFieldEnum = (typeof PortfolioProjectOrderByRelevanceFieldEnum)[keyof typeof PortfolioProjectOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    full_name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    contactForms?: ContactFormListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    full_name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    contactForms?: ContactFormOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    full_name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    contactForms?: ContactFormListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    full_name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    full_name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ContactFormWhereInput = {
    AND?: ContactFormWhereInput | ContactFormWhereInput[]
    OR?: ContactFormWhereInput[]
    NOT?: ContactFormWhereInput | ContactFormWhereInput[]
    id?: IntFilter<"ContactForm"> | number
    name?: StringFilter<"ContactForm"> | string
    email?: StringFilter<"ContactForm"> | string
    subject?: StringFilter<"ContactForm"> | string
    message?: StringFilter<"ContactForm"> | string
    createdAt?: DateTimeFilter<"ContactForm"> | Date | string
    updatedAt?: DateTimeFilter<"ContactForm"> | Date | string
    userId?: IntNullableFilter<"ContactForm"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ContactFormOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: ContactFormOrderByRelevanceInput
  }

  export type ContactFormWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactFormWhereInput | ContactFormWhereInput[]
    OR?: ContactFormWhereInput[]
    NOT?: ContactFormWhereInput | ContactFormWhereInput[]
    name?: StringFilter<"ContactForm"> | string
    email?: StringFilter<"ContactForm"> | string
    subject?: StringFilter<"ContactForm"> | string
    message?: StringFilter<"ContactForm"> | string
    createdAt?: DateTimeFilter<"ContactForm"> | Date | string
    updatedAt?: DateTimeFilter<"ContactForm"> | Date | string
    userId?: IntNullableFilter<"ContactForm"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ContactFormOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ContactFormCountOrderByAggregateInput
    _avg?: ContactFormAvgOrderByAggregateInput
    _max?: ContactFormMaxOrderByAggregateInput
    _min?: ContactFormMinOrderByAggregateInput
    _sum?: ContactFormSumOrderByAggregateInput
  }

  export type ContactFormScalarWhereWithAggregatesInput = {
    AND?: ContactFormScalarWhereWithAggregatesInput | ContactFormScalarWhereWithAggregatesInput[]
    OR?: ContactFormScalarWhereWithAggregatesInput[]
    NOT?: ContactFormScalarWhereWithAggregatesInput | ContactFormScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactForm"> | number
    name?: StringWithAggregatesFilter<"ContactForm"> | string
    email?: StringWithAggregatesFilter<"ContactForm"> | string
    subject?: StringWithAggregatesFilter<"ContactForm"> | string
    message?: StringWithAggregatesFilter<"ContactForm"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactForm"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"ContactForm"> | number | null
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    username?: StringFilter<"Project"> | string
    email?: StringFilter<"Project"> | string
    password?: StringFilter<"Project"> | string
    projectName?: StringFilter<"Project"> | string
    projectTitle?: StringFilter<"Project"> | string
    category?: StringFilter<"Project"> | string
    price?: FloatFilter<"Project"> | number
    deadline?: StringNullableFilter<"Project"> | string | null
    details?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    userId?: IntNullableFilter<"Project"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    webDevelopmentDetails?: XOR<WebDevelopmentDetailNullableScalarRelationFilter, WebDevelopmentDetailWhereInput> | null
    seoDetails?: XOR<SeoDetailNullableScalarRelationFilter, SeoDetailWhereInput> | null
    digitalMarketingDetails?: XOR<DigitalMarketingDetailNullableScalarRelationFilter, DigitalMarketingDetailWhereInput> | null
    contentGenerationDetails?: XOR<ContentGenerationDetailNullableScalarRelationFilter, ContentGenerationDetailWhereInput> | null
    appDevelopmentDetails?: XOR<AppDevelopmentDetailNullableScalarRelationFilter, AppDevelopmentDetailWhereInput> | null
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    projectName?: SortOrder
    projectTitle?: SortOrder
    category?: SortOrder
    price?: SortOrder
    deadline?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    webDevelopmentDetails?: WebDevelopmentDetailOrderByWithRelationInput
    seoDetails?: SeoDetailOrderByWithRelationInput
    digitalMarketingDetails?: DigitalMarketingDetailOrderByWithRelationInput
    contentGenerationDetails?: ContentGenerationDetailOrderByWithRelationInput
    appDevelopmentDetails?: AppDevelopmentDetailOrderByWithRelationInput
    _relevance?: ProjectOrderByRelevanceInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    username?: StringFilter<"Project"> | string
    email?: StringFilter<"Project"> | string
    password?: StringFilter<"Project"> | string
    projectName?: StringFilter<"Project"> | string
    projectTitle?: StringFilter<"Project"> | string
    category?: StringFilter<"Project"> | string
    price?: FloatFilter<"Project"> | number
    deadline?: StringNullableFilter<"Project"> | string | null
    details?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    userId?: IntNullableFilter<"Project"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    webDevelopmentDetails?: XOR<WebDevelopmentDetailNullableScalarRelationFilter, WebDevelopmentDetailWhereInput> | null
    seoDetails?: XOR<SeoDetailNullableScalarRelationFilter, SeoDetailWhereInput> | null
    digitalMarketingDetails?: XOR<DigitalMarketingDetailNullableScalarRelationFilter, DigitalMarketingDetailWhereInput> | null
    contentGenerationDetails?: XOR<ContentGenerationDetailNullableScalarRelationFilter, ContentGenerationDetailWhereInput> | null
    appDevelopmentDetails?: XOR<AppDevelopmentDetailNullableScalarRelationFilter, AppDevelopmentDetailWhereInput> | null
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    projectName?: SortOrder
    projectTitle?: SortOrder
    category?: SortOrder
    price?: SortOrder
    deadline?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    username?: StringWithAggregatesFilter<"Project"> | string
    email?: StringWithAggregatesFilter<"Project"> | string
    password?: StringWithAggregatesFilter<"Project"> | string
    projectName?: StringWithAggregatesFilter<"Project"> | string
    projectTitle?: StringWithAggregatesFilter<"Project"> | string
    category?: StringWithAggregatesFilter<"Project"> | string
    price?: FloatWithAggregatesFilter<"Project"> | number
    deadline?: StringNullableWithAggregatesFilter<"Project"> | string | null
    details?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    userId?: IntNullableWithAggregatesFilter<"Project"> | number | null
  }

  export type WebDevelopmentDetailWhereInput = {
    AND?: WebDevelopmentDetailWhereInput | WebDevelopmentDetailWhereInput[]
    OR?: WebDevelopmentDetailWhereInput[]
    NOT?: WebDevelopmentDetailWhereInput | WebDevelopmentDetailWhereInput[]
    id?: IntFilter<"WebDevelopmentDetail"> | number
    tech?: StringFilter<"WebDevelopmentDetail"> | string
    webPages?: IntNullableFilter<"WebDevelopmentDetail"> | number | null
    projectId?: IntFilter<"WebDevelopmentDetail"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    webFeatures?: WebDevelopmentFeatureListRelationFilter
  }

  export type WebDevelopmentDetailOrderByWithRelationInput = {
    id?: SortOrder
    tech?: SortOrder
    webPages?: SortOrderInput | SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    webFeatures?: WebDevelopmentFeatureOrderByRelationAggregateInput
    _relevance?: WebDevelopmentDetailOrderByRelevanceInput
  }

  export type WebDevelopmentDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId?: number
    AND?: WebDevelopmentDetailWhereInput | WebDevelopmentDetailWhereInput[]
    OR?: WebDevelopmentDetailWhereInput[]
    NOT?: WebDevelopmentDetailWhereInput | WebDevelopmentDetailWhereInput[]
    tech?: StringFilter<"WebDevelopmentDetail"> | string
    webPages?: IntNullableFilter<"WebDevelopmentDetail"> | number | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    webFeatures?: WebDevelopmentFeatureListRelationFilter
  }, "id" | "projectId">

  export type WebDevelopmentDetailOrderByWithAggregationInput = {
    id?: SortOrder
    tech?: SortOrder
    webPages?: SortOrderInput | SortOrder
    projectId?: SortOrder
    _count?: WebDevelopmentDetailCountOrderByAggregateInput
    _avg?: WebDevelopmentDetailAvgOrderByAggregateInput
    _max?: WebDevelopmentDetailMaxOrderByAggregateInput
    _min?: WebDevelopmentDetailMinOrderByAggregateInput
    _sum?: WebDevelopmentDetailSumOrderByAggregateInput
  }

  export type WebDevelopmentDetailScalarWhereWithAggregatesInput = {
    AND?: WebDevelopmentDetailScalarWhereWithAggregatesInput | WebDevelopmentDetailScalarWhereWithAggregatesInput[]
    OR?: WebDevelopmentDetailScalarWhereWithAggregatesInput[]
    NOT?: WebDevelopmentDetailScalarWhereWithAggregatesInput | WebDevelopmentDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WebDevelopmentDetail"> | number
    tech?: StringWithAggregatesFilter<"WebDevelopmentDetail"> | string
    webPages?: IntNullableWithAggregatesFilter<"WebDevelopmentDetail"> | number | null
    projectId?: IntWithAggregatesFilter<"WebDevelopmentDetail"> | number
  }

  export type WebDevelopmentFeatureWhereInput = {
    AND?: WebDevelopmentFeatureWhereInput | WebDevelopmentFeatureWhereInput[]
    OR?: WebDevelopmentFeatureWhereInput[]
    NOT?: WebDevelopmentFeatureWhereInput | WebDevelopmentFeatureWhereInput[]
    id?: IntFilter<"WebDevelopmentFeature"> | number
    feature?: StringFilter<"WebDevelopmentFeature"> | string
    price?: FloatFilter<"WebDevelopmentFeature"> | number
    webDevDetailId?: IntFilter<"WebDevelopmentFeature"> | number
    webDevDetail?: XOR<WebDevelopmentDetailScalarRelationFilter, WebDevelopmentDetailWhereInput>
  }

  export type WebDevelopmentFeatureOrderByWithRelationInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    webDevDetailId?: SortOrder
    webDevDetail?: WebDevelopmentDetailOrderByWithRelationInput
    _relevance?: WebDevelopmentFeatureOrderByRelevanceInput
  }

  export type WebDevelopmentFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WebDevelopmentFeatureWhereInput | WebDevelopmentFeatureWhereInput[]
    OR?: WebDevelopmentFeatureWhereInput[]
    NOT?: WebDevelopmentFeatureWhereInput | WebDevelopmentFeatureWhereInput[]
    feature?: StringFilter<"WebDevelopmentFeature"> | string
    price?: FloatFilter<"WebDevelopmentFeature"> | number
    webDevDetailId?: IntFilter<"WebDevelopmentFeature"> | number
    webDevDetail?: XOR<WebDevelopmentDetailScalarRelationFilter, WebDevelopmentDetailWhereInput>
  }, "id">

  export type WebDevelopmentFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    webDevDetailId?: SortOrder
    _count?: WebDevelopmentFeatureCountOrderByAggregateInput
    _avg?: WebDevelopmentFeatureAvgOrderByAggregateInput
    _max?: WebDevelopmentFeatureMaxOrderByAggregateInput
    _min?: WebDevelopmentFeatureMinOrderByAggregateInput
    _sum?: WebDevelopmentFeatureSumOrderByAggregateInput
  }

  export type WebDevelopmentFeatureScalarWhereWithAggregatesInput = {
    AND?: WebDevelopmentFeatureScalarWhereWithAggregatesInput | WebDevelopmentFeatureScalarWhereWithAggregatesInput[]
    OR?: WebDevelopmentFeatureScalarWhereWithAggregatesInput[]
    NOT?: WebDevelopmentFeatureScalarWhereWithAggregatesInput | WebDevelopmentFeatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WebDevelopmentFeature"> | number
    feature?: StringWithAggregatesFilter<"WebDevelopmentFeature"> | string
    price?: FloatWithAggregatesFilter<"WebDevelopmentFeature"> | number
    webDevDetailId?: IntWithAggregatesFilter<"WebDevelopmentFeature"> | number
  }

  export type SeoDetailWhereInput = {
    AND?: SeoDetailWhereInput | SeoDetailWhereInput[]
    OR?: SeoDetailWhereInput[]
    NOT?: SeoDetailWhereInput | SeoDetailWhereInput[]
    id?: IntFilter<"SeoDetail"> | number
    createdAt?: DateTimeFilter<"SeoDetail"> | Date | string
    updatedAt?: DateTimeFilter<"SeoDetail"> | Date | string
    projectId?: IntFilter<"SeoDetail"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    seoTypes?: SeoTypeListRelationFilter
  }

  export type SeoDetailOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    seoTypes?: SeoTypeOrderByRelationAggregateInput
  }

  export type SeoDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId?: number
    AND?: SeoDetailWhereInput | SeoDetailWhereInput[]
    OR?: SeoDetailWhereInput[]
    NOT?: SeoDetailWhereInput | SeoDetailWhereInput[]
    createdAt?: DateTimeFilter<"SeoDetail"> | Date | string
    updatedAt?: DateTimeFilter<"SeoDetail"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    seoTypes?: SeoTypeListRelationFilter
  }, "id" | "projectId">

  export type SeoDetailOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: SeoDetailCountOrderByAggregateInput
    _avg?: SeoDetailAvgOrderByAggregateInput
    _max?: SeoDetailMaxOrderByAggregateInput
    _min?: SeoDetailMinOrderByAggregateInput
    _sum?: SeoDetailSumOrderByAggregateInput
  }

  export type SeoDetailScalarWhereWithAggregatesInput = {
    AND?: SeoDetailScalarWhereWithAggregatesInput | SeoDetailScalarWhereWithAggregatesInput[]
    OR?: SeoDetailScalarWhereWithAggregatesInput[]
    NOT?: SeoDetailScalarWhereWithAggregatesInput | SeoDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SeoDetail"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SeoDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SeoDetail"> | Date | string
    projectId?: IntWithAggregatesFilter<"SeoDetail"> | number
  }

  export type SeoTypeWhereInput = {
    AND?: SeoTypeWhereInput | SeoTypeWhereInput[]
    OR?: SeoTypeWhereInput[]
    NOT?: SeoTypeWhereInput | SeoTypeWhereInput[]
    id?: IntFilter<"SeoType"> | number
    seoType?: StringFilter<"SeoType"> | string
    price?: FloatFilter<"SeoType"> | number
    seoDetailId?: IntFilter<"SeoType"> | number
    seoDetail?: XOR<SeoDetailScalarRelationFilter, SeoDetailWhereInput>
  }

  export type SeoTypeOrderByWithRelationInput = {
    id?: SortOrder
    seoType?: SortOrder
    price?: SortOrder
    seoDetailId?: SortOrder
    seoDetail?: SeoDetailOrderByWithRelationInput
    _relevance?: SeoTypeOrderByRelevanceInput
  }

  export type SeoTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeoTypeWhereInput | SeoTypeWhereInput[]
    OR?: SeoTypeWhereInput[]
    NOT?: SeoTypeWhereInput | SeoTypeWhereInput[]
    seoType?: StringFilter<"SeoType"> | string
    price?: FloatFilter<"SeoType"> | number
    seoDetailId?: IntFilter<"SeoType"> | number
    seoDetail?: XOR<SeoDetailScalarRelationFilter, SeoDetailWhereInput>
  }, "id">

  export type SeoTypeOrderByWithAggregationInput = {
    id?: SortOrder
    seoType?: SortOrder
    price?: SortOrder
    seoDetailId?: SortOrder
    _count?: SeoTypeCountOrderByAggregateInput
    _avg?: SeoTypeAvgOrderByAggregateInput
    _max?: SeoTypeMaxOrderByAggregateInput
    _min?: SeoTypeMinOrderByAggregateInput
    _sum?: SeoTypeSumOrderByAggregateInput
  }

  export type SeoTypeScalarWhereWithAggregatesInput = {
    AND?: SeoTypeScalarWhereWithAggregatesInput | SeoTypeScalarWhereWithAggregatesInput[]
    OR?: SeoTypeScalarWhereWithAggregatesInput[]
    NOT?: SeoTypeScalarWhereWithAggregatesInput | SeoTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SeoType"> | number
    seoType?: StringWithAggregatesFilter<"SeoType"> | string
    price?: FloatWithAggregatesFilter<"SeoType"> | number
    seoDetailId?: IntWithAggregatesFilter<"SeoType"> | number
  }

  export type DigitalMarketingDetailWhereInput = {
    AND?: DigitalMarketingDetailWhereInput | DigitalMarketingDetailWhereInput[]
    OR?: DigitalMarketingDetailWhereInput[]
    NOT?: DigitalMarketingDetailWhereInput | DigitalMarketingDetailWhereInput[]
    id?: IntFilter<"DigitalMarketingDetail"> | number
    targetAudience?: StringNullableFilter<"DigitalMarketingDetail"> | string | null
    marketingBudget?: FloatNullableFilter<"DigitalMarketingDetail"> | number | null
    duration?: StringNullableFilter<"DigitalMarketingDetail"> | string | null
    createdAt?: DateTimeFilter<"DigitalMarketingDetail"> | Date | string
    updatedAt?: DateTimeFilter<"DigitalMarketingDetail"> | Date | string
    projectId?: IntFilter<"DigitalMarketingDetail"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    marketingServices?: DigitalMarketingServiceListRelationFilter
    socialPlatforms?: SocialPlatformListRelationFilter
  }

  export type DigitalMarketingDetailOrderByWithRelationInput = {
    id?: SortOrder
    targetAudience?: SortOrderInput | SortOrder
    marketingBudget?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    marketingServices?: DigitalMarketingServiceOrderByRelationAggregateInput
    socialPlatforms?: SocialPlatformOrderByRelationAggregateInput
    _relevance?: DigitalMarketingDetailOrderByRelevanceInput
  }

  export type DigitalMarketingDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId?: number
    AND?: DigitalMarketingDetailWhereInput | DigitalMarketingDetailWhereInput[]
    OR?: DigitalMarketingDetailWhereInput[]
    NOT?: DigitalMarketingDetailWhereInput | DigitalMarketingDetailWhereInput[]
    targetAudience?: StringNullableFilter<"DigitalMarketingDetail"> | string | null
    marketingBudget?: FloatNullableFilter<"DigitalMarketingDetail"> | number | null
    duration?: StringNullableFilter<"DigitalMarketingDetail"> | string | null
    createdAt?: DateTimeFilter<"DigitalMarketingDetail"> | Date | string
    updatedAt?: DateTimeFilter<"DigitalMarketingDetail"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    marketingServices?: DigitalMarketingServiceListRelationFilter
    socialPlatforms?: SocialPlatformListRelationFilter
  }, "id" | "projectId">

  export type DigitalMarketingDetailOrderByWithAggregationInput = {
    id?: SortOrder
    targetAudience?: SortOrderInput | SortOrder
    marketingBudget?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: DigitalMarketingDetailCountOrderByAggregateInput
    _avg?: DigitalMarketingDetailAvgOrderByAggregateInput
    _max?: DigitalMarketingDetailMaxOrderByAggregateInput
    _min?: DigitalMarketingDetailMinOrderByAggregateInput
    _sum?: DigitalMarketingDetailSumOrderByAggregateInput
  }

  export type DigitalMarketingDetailScalarWhereWithAggregatesInput = {
    AND?: DigitalMarketingDetailScalarWhereWithAggregatesInput | DigitalMarketingDetailScalarWhereWithAggregatesInput[]
    OR?: DigitalMarketingDetailScalarWhereWithAggregatesInput[]
    NOT?: DigitalMarketingDetailScalarWhereWithAggregatesInput | DigitalMarketingDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DigitalMarketingDetail"> | number
    targetAudience?: StringNullableWithAggregatesFilter<"DigitalMarketingDetail"> | string | null
    marketingBudget?: FloatNullableWithAggregatesFilter<"DigitalMarketingDetail"> | number | null
    duration?: StringNullableWithAggregatesFilter<"DigitalMarketingDetail"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DigitalMarketingDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DigitalMarketingDetail"> | Date | string
    projectId?: IntWithAggregatesFilter<"DigitalMarketingDetail"> | number
  }

  export type DigitalMarketingServiceWhereInput = {
    AND?: DigitalMarketingServiceWhereInput | DigitalMarketingServiceWhereInput[]
    OR?: DigitalMarketingServiceWhereInput[]
    NOT?: DigitalMarketingServiceWhereInput | DigitalMarketingServiceWhereInput[]
    id?: IntFilter<"DigitalMarketingService"> | number
    service?: StringFilter<"DigitalMarketingService"> | string
    price?: FloatFilter<"DigitalMarketingService"> | number
    digitalMarketingDetailId?: IntFilter<"DigitalMarketingService"> | number
    digitalMarketingDetail?: XOR<DigitalMarketingDetailScalarRelationFilter, DigitalMarketingDetailWhereInput>
  }

  export type DigitalMarketingServiceOrderByWithRelationInput = {
    id?: SortOrder
    service?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
    digitalMarketingDetail?: DigitalMarketingDetailOrderByWithRelationInput
    _relevance?: DigitalMarketingServiceOrderByRelevanceInput
  }

  export type DigitalMarketingServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DigitalMarketingServiceWhereInput | DigitalMarketingServiceWhereInput[]
    OR?: DigitalMarketingServiceWhereInput[]
    NOT?: DigitalMarketingServiceWhereInput | DigitalMarketingServiceWhereInput[]
    service?: StringFilter<"DigitalMarketingService"> | string
    price?: FloatFilter<"DigitalMarketingService"> | number
    digitalMarketingDetailId?: IntFilter<"DigitalMarketingService"> | number
    digitalMarketingDetail?: XOR<DigitalMarketingDetailScalarRelationFilter, DigitalMarketingDetailWhereInput>
  }, "id">

  export type DigitalMarketingServiceOrderByWithAggregationInput = {
    id?: SortOrder
    service?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
    _count?: DigitalMarketingServiceCountOrderByAggregateInput
    _avg?: DigitalMarketingServiceAvgOrderByAggregateInput
    _max?: DigitalMarketingServiceMaxOrderByAggregateInput
    _min?: DigitalMarketingServiceMinOrderByAggregateInput
    _sum?: DigitalMarketingServiceSumOrderByAggregateInput
  }

  export type DigitalMarketingServiceScalarWhereWithAggregatesInput = {
    AND?: DigitalMarketingServiceScalarWhereWithAggregatesInput | DigitalMarketingServiceScalarWhereWithAggregatesInput[]
    OR?: DigitalMarketingServiceScalarWhereWithAggregatesInput[]
    NOT?: DigitalMarketingServiceScalarWhereWithAggregatesInput | DigitalMarketingServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DigitalMarketingService"> | number
    service?: StringWithAggregatesFilter<"DigitalMarketingService"> | string
    price?: FloatWithAggregatesFilter<"DigitalMarketingService"> | number
    digitalMarketingDetailId?: IntWithAggregatesFilter<"DigitalMarketingService"> | number
  }

  export type SocialPlatformWhereInput = {
    AND?: SocialPlatformWhereInput | SocialPlatformWhereInput[]
    OR?: SocialPlatformWhereInput[]
    NOT?: SocialPlatformWhereInput | SocialPlatformWhereInput[]
    id?: IntFilter<"SocialPlatform"> | number
    platform?: StringFilter<"SocialPlatform"> | string
    price?: FloatFilter<"SocialPlatform"> | number
    digitalMarketingDetailId?: IntFilter<"SocialPlatform"> | number
    digitalMarketingDetail?: XOR<DigitalMarketingDetailScalarRelationFilter, DigitalMarketingDetailWhereInput>
  }

  export type SocialPlatformOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
    digitalMarketingDetail?: DigitalMarketingDetailOrderByWithRelationInput
    _relevance?: SocialPlatformOrderByRelevanceInput
  }

  export type SocialPlatformWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SocialPlatformWhereInput | SocialPlatformWhereInput[]
    OR?: SocialPlatformWhereInput[]
    NOT?: SocialPlatformWhereInput | SocialPlatformWhereInput[]
    platform?: StringFilter<"SocialPlatform"> | string
    price?: FloatFilter<"SocialPlatform"> | number
    digitalMarketingDetailId?: IntFilter<"SocialPlatform"> | number
    digitalMarketingDetail?: XOR<DigitalMarketingDetailScalarRelationFilter, DigitalMarketingDetailWhereInput>
  }, "id">

  export type SocialPlatformOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
    _count?: SocialPlatformCountOrderByAggregateInput
    _avg?: SocialPlatformAvgOrderByAggregateInput
    _max?: SocialPlatformMaxOrderByAggregateInput
    _min?: SocialPlatformMinOrderByAggregateInput
    _sum?: SocialPlatformSumOrderByAggregateInput
  }

  export type SocialPlatformScalarWhereWithAggregatesInput = {
    AND?: SocialPlatformScalarWhereWithAggregatesInput | SocialPlatformScalarWhereWithAggregatesInput[]
    OR?: SocialPlatformScalarWhereWithAggregatesInput[]
    NOT?: SocialPlatformScalarWhereWithAggregatesInput | SocialPlatformScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SocialPlatform"> | number
    platform?: StringWithAggregatesFilter<"SocialPlatform"> | string
    price?: FloatWithAggregatesFilter<"SocialPlatform"> | number
    digitalMarketingDetailId?: IntWithAggregatesFilter<"SocialPlatform"> | number
  }

  export type ContentGenerationDetailWhereInput = {
    AND?: ContentGenerationDetailWhereInput | ContentGenerationDetailWhereInput[]
    OR?: ContentGenerationDetailWhereInput[]
    NOT?: ContentGenerationDetailWhereInput | ContentGenerationDetailWhereInput[]
    id?: IntFilter<"ContentGenerationDetail"> | number
    volume?: StringNullableFilter<"ContentGenerationDetail"> | string | null
    contentTone?: StringNullableFilter<"ContentGenerationDetail"> | string | null
    targetKeywords?: StringNullableFilter<"ContentGenerationDetail"> | string | null
    createdAt?: DateTimeFilter<"ContentGenerationDetail"> | Date | string
    updatedAt?: DateTimeFilter<"ContentGenerationDetail"> | Date | string
    projectId?: IntFilter<"ContentGenerationDetail"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    contentTypes?: ContentTypeListRelationFilter
    contentLanguages?: ContentLanguageListRelationFilter
  }

  export type ContentGenerationDetailOrderByWithRelationInput = {
    id?: SortOrder
    volume?: SortOrderInput | SortOrder
    contentTone?: SortOrderInput | SortOrder
    targetKeywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    contentTypes?: ContentTypeOrderByRelationAggregateInput
    contentLanguages?: ContentLanguageOrderByRelationAggregateInput
    _relevance?: ContentGenerationDetailOrderByRelevanceInput
  }

  export type ContentGenerationDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId?: number
    AND?: ContentGenerationDetailWhereInput | ContentGenerationDetailWhereInput[]
    OR?: ContentGenerationDetailWhereInput[]
    NOT?: ContentGenerationDetailWhereInput | ContentGenerationDetailWhereInput[]
    volume?: StringNullableFilter<"ContentGenerationDetail"> | string | null
    contentTone?: StringNullableFilter<"ContentGenerationDetail"> | string | null
    targetKeywords?: StringNullableFilter<"ContentGenerationDetail"> | string | null
    createdAt?: DateTimeFilter<"ContentGenerationDetail"> | Date | string
    updatedAt?: DateTimeFilter<"ContentGenerationDetail"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    contentTypes?: ContentTypeListRelationFilter
    contentLanguages?: ContentLanguageListRelationFilter
  }, "id" | "projectId">

  export type ContentGenerationDetailOrderByWithAggregationInput = {
    id?: SortOrder
    volume?: SortOrderInput | SortOrder
    contentTone?: SortOrderInput | SortOrder
    targetKeywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: ContentGenerationDetailCountOrderByAggregateInput
    _avg?: ContentGenerationDetailAvgOrderByAggregateInput
    _max?: ContentGenerationDetailMaxOrderByAggregateInput
    _min?: ContentGenerationDetailMinOrderByAggregateInput
    _sum?: ContentGenerationDetailSumOrderByAggregateInput
  }

  export type ContentGenerationDetailScalarWhereWithAggregatesInput = {
    AND?: ContentGenerationDetailScalarWhereWithAggregatesInput | ContentGenerationDetailScalarWhereWithAggregatesInput[]
    OR?: ContentGenerationDetailScalarWhereWithAggregatesInput[]
    NOT?: ContentGenerationDetailScalarWhereWithAggregatesInput | ContentGenerationDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentGenerationDetail"> | number
    volume?: StringNullableWithAggregatesFilter<"ContentGenerationDetail"> | string | null
    contentTone?: StringNullableWithAggregatesFilter<"ContentGenerationDetail"> | string | null
    targetKeywords?: StringNullableWithAggregatesFilter<"ContentGenerationDetail"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentGenerationDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentGenerationDetail"> | Date | string
    projectId?: IntWithAggregatesFilter<"ContentGenerationDetail"> | number
  }

  export type ContentTypeWhereInput = {
    AND?: ContentTypeWhereInput | ContentTypeWhereInput[]
    OR?: ContentTypeWhereInput[]
    NOT?: ContentTypeWhereInput | ContentTypeWhereInput[]
    id?: IntFilter<"ContentType"> | number
    contentType?: StringFilter<"ContentType"> | string
    price?: FloatFilter<"ContentType"> | number
    contentGenerationDetailId?: IntFilter<"ContentType"> | number
    contentGenerationDetail?: XOR<ContentGenerationDetailScalarRelationFilter, ContentGenerationDetailWhereInput>
  }

  export type ContentTypeOrderByWithRelationInput = {
    id?: SortOrder
    contentType?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
    contentGenerationDetail?: ContentGenerationDetailOrderByWithRelationInput
    _relevance?: ContentTypeOrderByRelevanceInput
  }

  export type ContentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContentTypeWhereInput | ContentTypeWhereInput[]
    OR?: ContentTypeWhereInput[]
    NOT?: ContentTypeWhereInput | ContentTypeWhereInput[]
    contentType?: StringFilter<"ContentType"> | string
    price?: FloatFilter<"ContentType"> | number
    contentGenerationDetailId?: IntFilter<"ContentType"> | number
    contentGenerationDetail?: XOR<ContentGenerationDetailScalarRelationFilter, ContentGenerationDetailWhereInput>
  }, "id">

  export type ContentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    contentType?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
    _count?: ContentTypeCountOrderByAggregateInput
    _avg?: ContentTypeAvgOrderByAggregateInput
    _max?: ContentTypeMaxOrderByAggregateInput
    _min?: ContentTypeMinOrderByAggregateInput
    _sum?: ContentTypeSumOrderByAggregateInput
  }

  export type ContentTypeScalarWhereWithAggregatesInput = {
    AND?: ContentTypeScalarWhereWithAggregatesInput | ContentTypeScalarWhereWithAggregatesInput[]
    OR?: ContentTypeScalarWhereWithAggregatesInput[]
    NOT?: ContentTypeScalarWhereWithAggregatesInput | ContentTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentType"> | number
    contentType?: StringWithAggregatesFilter<"ContentType"> | string
    price?: FloatWithAggregatesFilter<"ContentType"> | number
    contentGenerationDetailId?: IntWithAggregatesFilter<"ContentType"> | number
  }

  export type ContentLanguageWhereInput = {
    AND?: ContentLanguageWhereInput | ContentLanguageWhereInput[]
    OR?: ContentLanguageWhereInput[]
    NOT?: ContentLanguageWhereInput | ContentLanguageWhereInput[]
    id?: IntFilter<"ContentLanguage"> | number
    language?: StringFilter<"ContentLanguage"> | string
    price?: FloatFilter<"ContentLanguage"> | number
    contentGenerationDetailId?: IntFilter<"ContentLanguage"> | number
    contentGenerationDetail?: XOR<ContentGenerationDetailScalarRelationFilter, ContentGenerationDetailWhereInput>
  }

  export type ContentLanguageOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
    contentGenerationDetail?: ContentGenerationDetailOrderByWithRelationInput
    _relevance?: ContentLanguageOrderByRelevanceInput
  }

  export type ContentLanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContentLanguageWhereInput | ContentLanguageWhereInput[]
    OR?: ContentLanguageWhereInput[]
    NOT?: ContentLanguageWhereInput | ContentLanguageWhereInput[]
    language?: StringFilter<"ContentLanguage"> | string
    price?: FloatFilter<"ContentLanguage"> | number
    contentGenerationDetailId?: IntFilter<"ContentLanguage"> | number
    contentGenerationDetail?: XOR<ContentGenerationDetailScalarRelationFilter, ContentGenerationDetailWhereInput>
  }, "id">

  export type ContentLanguageOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
    _count?: ContentLanguageCountOrderByAggregateInput
    _avg?: ContentLanguageAvgOrderByAggregateInput
    _max?: ContentLanguageMaxOrderByAggregateInput
    _min?: ContentLanguageMinOrderByAggregateInput
    _sum?: ContentLanguageSumOrderByAggregateInput
  }

  export type ContentLanguageScalarWhereWithAggregatesInput = {
    AND?: ContentLanguageScalarWhereWithAggregatesInput | ContentLanguageScalarWhereWithAggregatesInput[]
    OR?: ContentLanguageScalarWhereWithAggregatesInput[]
    NOT?: ContentLanguageScalarWhereWithAggregatesInput | ContentLanguageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentLanguage"> | number
    language?: StringWithAggregatesFilter<"ContentLanguage"> | string
    price?: FloatWithAggregatesFilter<"ContentLanguage"> | number
    contentGenerationDetailId?: IntWithAggregatesFilter<"ContentLanguage"> | number
  }

  export type AppDevelopmentDetailWhereInput = {
    AND?: AppDevelopmentDetailWhereInput | AppDevelopmentDetailWhereInput[]
    OR?: AppDevelopmentDetailWhereInput[]
    NOT?: AppDevelopmentDetailWhereInput | AppDevelopmentDetailWhereInput[]
    id?: IntFilter<"AppDevelopmentDetail"> | number
    appType?: StringNullableFilter<"AppDevelopmentDetail"> | string | null
    complexity?: StringNullableFilter<"AppDevelopmentDetail"> | string | null
    targetPlatforms?: StringNullableFilter<"AppDevelopmentDetail"> | string | null
    expectedUsers?: IntNullableFilter<"AppDevelopmentDetail"> | number | null
    createdAt?: DateTimeFilter<"AppDevelopmentDetail"> | Date | string
    updatedAt?: DateTimeFilter<"AppDevelopmentDetail"> | Date | string
    projectId?: IntFilter<"AppDevelopmentDetail"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    appFeatures?: AppFeatureListRelationFilter
  }

  export type AppDevelopmentDetailOrderByWithRelationInput = {
    id?: SortOrder
    appType?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    targetPlatforms?: SortOrderInput | SortOrder
    expectedUsers?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    appFeatures?: AppFeatureOrderByRelationAggregateInput
    _relevance?: AppDevelopmentDetailOrderByRelevanceInput
  }

  export type AppDevelopmentDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId?: number
    AND?: AppDevelopmentDetailWhereInput | AppDevelopmentDetailWhereInput[]
    OR?: AppDevelopmentDetailWhereInput[]
    NOT?: AppDevelopmentDetailWhereInput | AppDevelopmentDetailWhereInput[]
    appType?: StringNullableFilter<"AppDevelopmentDetail"> | string | null
    complexity?: StringNullableFilter<"AppDevelopmentDetail"> | string | null
    targetPlatforms?: StringNullableFilter<"AppDevelopmentDetail"> | string | null
    expectedUsers?: IntNullableFilter<"AppDevelopmentDetail"> | number | null
    createdAt?: DateTimeFilter<"AppDevelopmentDetail"> | Date | string
    updatedAt?: DateTimeFilter<"AppDevelopmentDetail"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    appFeatures?: AppFeatureListRelationFilter
  }, "id" | "projectId">

  export type AppDevelopmentDetailOrderByWithAggregationInput = {
    id?: SortOrder
    appType?: SortOrderInput | SortOrder
    complexity?: SortOrderInput | SortOrder
    targetPlatforms?: SortOrderInput | SortOrder
    expectedUsers?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: AppDevelopmentDetailCountOrderByAggregateInput
    _avg?: AppDevelopmentDetailAvgOrderByAggregateInput
    _max?: AppDevelopmentDetailMaxOrderByAggregateInput
    _min?: AppDevelopmentDetailMinOrderByAggregateInput
    _sum?: AppDevelopmentDetailSumOrderByAggregateInput
  }

  export type AppDevelopmentDetailScalarWhereWithAggregatesInput = {
    AND?: AppDevelopmentDetailScalarWhereWithAggregatesInput | AppDevelopmentDetailScalarWhereWithAggregatesInput[]
    OR?: AppDevelopmentDetailScalarWhereWithAggregatesInput[]
    NOT?: AppDevelopmentDetailScalarWhereWithAggregatesInput | AppDevelopmentDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppDevelopmentDetail"> | number
    appType?: StringNullableWithAggregatesFilter<"AppDevelopmentDetail"> | string | null
    complexity?: StringNullableWithAggregatesFilter<"AppDevelopmentDetail"> | string | null
    targetPlatforms?: StringNullableWithAggregatesFilter<"AppDevelopmentDetail"> | string | null
    expectedUsers?: IntNullableWithAggregatesFilter<"AppDevelopmentDetail"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AppDevelopmentDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AppDevelopmentDetail"> | Date | string
    projectId?: IntWithAggregatesFilter<"AppDevelopmentDetail"> | number
  }

  export type AppFeatureWhereInput = {
    AND?: AppFeatureWhereInput | AppFeatureWhereInput[]
    OR?: AppFeatureWhereInput[]
    NOT?: AppFeatureWhereInput | AppFeatureWhereInput[]
    id?: IntFilter<"AppFeature"> | number
    feature?: StringFilter<"AppFeature"> | string
    price?: FloatFilter<"AppFeature"> | number
    appDevelopmentDetailId?: IntFilter<"AppFeature"> | number
    appDevelopmentDetail?: XOR<AppDevelopmentDetailScalarRelationFilter, AppDevelopmentDetailWhereInput>
  }

  export type AppFeatureOrderByWithRelationInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    appDevelopmentDetailId?: SortOrder
    appDevelopmentDetail?: AppDevelopmentDetailOrderByWithRelationInput
    _relevance?: AppFeatureOrderByRelevanceInput
  }

  export type AppFeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppFeatureWhereInput | AppFeatureWhereInput[]
    OR?: AppFeatureWhereInput[]
    NOT?: AppFeatureWhereInput | AppFeatureWhereInput[]
    feature?: StringFilter<"AppFeature"> | string
    price?: FloatFilter<"AppFeature"> | number
    appDevelopmentDetailId?: IntFilter<"AppFeature"> | number
    appDevelopmentDetail?: XOR<AppDevelopmentDetailScalarRelationFilter, AppDevelopmentDetailWhereInput>
  }, "id">

  export type AppFeatureOrderByWithAggregationInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    appDevelopmentDetailId?: SortOrder
    _count?: AppFeatureCountOrderByAggregateInput
    _avg?: AppFeatureAvgOrderByAggregateInput
    _max?: AppFeatureMaxOrderByAggregateInput
    _min?: AppFeatureMinOrderByAggregateInput
    _sum?: AppFeatureSumOrderByAggregateInput
  }

  export type AppFeatureScalarWhereWithAggregatesInput = {
    AND?: AppFeatureScalarWhereWithAggregatesInput | AppFeatureScalarWhereWithAggregatesInput[]
    OR?: AppFeatureScalarWhereWithAggregatesInput[]
    NOT?: AppFeatureScalarWhereWithAggregatesInput | AppFeatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppFeature"> | number
    feature?: StringWithAggregatesFilter<"AppFeature"> | string
    price?: FloatWithAggregatesFilter<"AppFeature"> | number
    appDevelopmentDetailId?: IntWithAggregatesFilter<"AppFeature"> | number
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    role?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: AdminOrderByRelevanceInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    password?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    role?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    role?: StringWithAggregatesFilter<"Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type ProjectStatusHistoryWhereInput = {
    AND?: ProjectStatusHistoryWhereInput | ProjectStatusHistoryWhereInput[]
    OR?: ProjectStatusHistoryWhereInput[]
    NOT?: ProjectStatusHistoryWhereInput | ProjectStatusHistoryWhereInput[]
    id?: IntFilter<"ProjectStatusHistory"> | number
    projectId?: IntFilter<"ProjectStatusHistory"> | number
    oldStatus?: StringNullableFilter<"ProjectStatusHistory"> | string | null
    newStatus?: StringFilter<"ProjectStatusHistory"> | string
    changedBy?: StringNullableFilter<"ProjectStatusHistory"> | string | null
    notes?: StringNullableFilter<"ProjectStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"ProjectStatusHistory"> | Date | string
  }

  export type ProjectStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: ProjectStatusHistoryOrderByRelevanceInput
  }

  export type ProjectStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProjectStatusHistoryWhereInput | ProjectStatusHistoryWhereInput[]
    OR?: ProjectStatusHistoryWhereInput[]
    NOT?: ProjectStatusHistoryWhereInput | ProjectStatusHistoryWhereInput[]
    projectId?: IntFilter<"ProjectStatusHistory"> | number
    oldStatus?: StringNullableFilter<"ProjectStatusHistory"> | string | null
    newStatus?: StringFilter<"ProjectStatusHistory"> | string
    changedBy?: StringNullableFilter<"ProjectStatusHistory"> | string | null
    notes?: StringNullableFilter<"ProjectStatusHistory"> | string | null
    createdAt?: DateTimeFilter<"ProjectStatusHistory"> | Date | string
  }, "id">

  export type ProjectStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProjectStatusHistoryCountOrderByAggregateInput
    _avg?: ProjectStatusHistoryAvgOrderByAggregateInput
    _max?: ProjectStatusHistoryMaxOrderByAggregateInput
    _min?: ProjectStatusHistoryMinOrderByAggregateInput
    _sum?: ProjectStatusHistorySumOrderByAggregateInput
  }

  export type ProjectStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: ProjectStatusHistoryScalarWhereWithAggregatesInput | ProjectStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: ProjectStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: ProjectStatusHistoryScalarWhereWithAggregatesInput | ProjectStatusHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectStatusHistory"> | number
    projectId?: IntWithAggregatesFilter<"ProjectStatusHistory"> | number
    oldStatus?: StringNullableWithAggregatesFilter<"ProjectStatusHistory"> | string | null
    newStatus?: StringWithAggregatesFilter<"ProjectStatusHistory"> | string
    changedBy?: StringNullableWithAggregatesFilter<"ProjectStatusHistory"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ProjectStatusHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectStatusHistory"> | Date | string
  }

  export type PortfolioProjectWhereInput = {
    AND?: PortfolioProjectWhereInput | PortfolioProjectWhereInput[]
    OR?: PortfolioProjectWhereInput[]
    NOT?: PortfolioProjectWhereInput | PortfolioProjectWhereInput[]
    id?: IntFilter<"PortfolioProject"> | number
    title?: StringFilter<"PortfolioProject"> | string
    category?: StringFilter<"PortfolioProject"> | string
    image?: StringFilter<"PortfolioProject"> | string
    description?: StringFilter<"PortfolioProject"> | string
    technologies?: StringFilter<"PortfolioProject"> | string
    liveUrl?: StringFilter<"PortfolioProject"> | string
    githubUrl?: StringNullableFilter<"PortfolioProject"> | string | null
    featured?: BoolFilter<"PortfolioProject"> | boolean
    status?: StringFilter<"PortfolioProject"> | string
    createdAt?: DateTimeFilter<"PortfolioProject"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioProject"> | Date | string
  }

  export type PortfolioProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrder
    technologies?: SortOrder
    liveUrl?: SortOrder
    githubUrl?: SortOrderInput | SortOrder
    featured?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: PortfolioProjectOrderByRelevanceInput
  }

  export type PortfolioProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PortfolioProjectWhereInput | PortfolioProjectWhereInput[]
    OR?: PortfolioProjectWhereInput[]
    NOT?: PortfolioProjectWhereInput | PortfolioProjectWhereInput[]
    title?: StringFilter<"PortfolioProject"> | string
    category?: StringFilter<"PortfolioProject"> | string
    image?: StringFilter<"PortfolioProject"> | string
    description?: StringFilter<"PortfolioProject"> | string
    technologies?: StringFilter<"PortfolioProject"> | string
    liveUrl?: StringFilter<"PortfolioProject"> | string
    githubUrl?: StringNullableFilter<"PortfolioProject"> | string | null
    featured?: BoolFilter<"PortfolioProject"> | boolean
    status?: StringFilter<"PortfolioProject"> | string
    createdAt?: DateTimeFilter<"PortfolioProject"> | Date | string
    updatedAt?: DateTimeFilter<"PortfolioProject"> | Date | string
  }, "id">

  export type PortfolioProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrder
    technologies?: SortOrder
    liveUrl?: SortOrder
    githubUrl?: SortOrderInput | SortOrder
    featured?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortfolioProjectCountOrderByAggregateInput
    _avg?: PortfolioProjectAvgOrderByAggregateInput
    _max?: PortfolioProjectMaxOrderByAggregateInput
    _min?: PortfolioProjectMinOrderByAggregateInput
    _sum?: PortfolioProjectSumOrderByAggregateInput
  }

  export type PortfolioProjectScalarWhereWithAggregatesInput = {
    AND?: PortfolioProjectScalarWhereWithAggregatesInput | PortfolioProjectScalarWhereWithAggregatesInput[]
    OR?: PortfolioProjectScalarWhereWithAggregatesInput[]
    NOT?: PortfolioProjectScalarWhereWithAggregatesInput | PortfolioProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PortfolioProject"> | number
    title?: StringWithAggregatesFilter<"PortfolioProject"> | string
    category?: StringWithAggregatesFilter<"PortfolioProject"> | string
    image?: StringWithAggregatesFilter<"PortfolioProject"> | string
    description?: StringWithAggregatesFilter<"PortfolioProject"> | string
    technologies?: StringWithAggregatesFilter<"PortfolioProject"> | string
    liveUrl?: StringWithAggregatesFilter<"PortfolioProject"> | string
    githubUrl?: StringNullableWithAggregatesFilter<"PortfolioProject"> | string | null
    featured?: BoolWithAggregatesFilter<"PortfolioProject"> | boolean
    status?: StringWithAggregatesFilter<"PortfolioProject"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioProject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PortfolioProject"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    full_name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutUserInput
    contactForms?: ContactFormCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    full_name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
    contactForms?: ContactFormUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutUserNestedInput
    contactForms?: ContactFormUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
    contactForms?: ContactFormUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    full_name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormCreateInput = {
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutContactFormsInput
  }

  export type ContactFormUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
  }

  export type ContactFormUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutContactFormsNestedInput
  }

  export type ContactFormUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ContactFormCreateManyInput = {
    id?: number
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
  }

  export type ContactFormUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProjectCreateInput = {
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProjectsInput
    webDevelopmentDetails?: WebDevelopmentDetailCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailUncheckedCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProjectsNestedInput
    webDevelopmentDetails?: WebDevelopmentDetailUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUncheckedUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
  }

  export type ProjectUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WebDevelopmentDetailCreateInput = {
    tech: string
    webPages?: number | null
    project: ProjectCreateNestedOneWithoutWebDevelopmentDetailsInput
    webFeatures?: WebDevelopmentFeatureCreateNestedManyWithoutWebDevDetailInput
  }

  export type WebDevelopmentDetailUncheckedCreateInput = {
    id?: number
    tech: string
    webPages?: number | null
    projectId: number
    webFeatures?: WebDevelopmentFeatureUncheckedCreateNestedManyWithoutWebDevDetailInput
  }

  export type WebDevelopmentDetailUpdateInput = {
    tech?: StringFieldUpdateOperationsInput | string
    webPages?: NullableIntFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneRequiredWithoutWebDevelopmentDetailsNestedInput
    webFeatures?: WebDevelopmentFeatureUpdateManyWithoutWebDevDetailNestedInput
  }

  export type WebDevelopmentDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tech?: StringFieldUpdateOperationsInput | string
    webPages?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
    webFeatures?: WebDevelopmentFeatureUncheckedUpdateManyWithoutWebDevDetailNestedInput
  }

  export type WebDevelopmentDetailCreateManyInput = {
    id?: number
    tech: string
    webPages?: number | null
    projectId: number
  }

  export type WebDevelopmentDetailUpdateManyMutationInput = {
    tech?: StringFieldUpdateOperationsInput | string
    webPages?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WebDevelopmentDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tech?: StringFieldUpdateOperationsInput | string
    webPages?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type WebDevelopmentFeatureCreateInput = {
    feature: string
    price: number
    webDevDetail: WebDevelopmentDetailCreateNestedOneWithoutWebFeaturesInput
  }

  export type WebDevelopmentFeatureUncheckedCreateInput = {
    id?: number
    feature: string
    price: number
    webDevDetailId: number
  }

  export type WebDevelopmentFeatureUpdateInput = {
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    webDevDetail?: WebDevelopmentDetailUpdateOneRequiredWithoutWebFeaturesNestedInput
  }

  export type WebDevelopmentFeatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    webDevDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type WebDevelopmentFeatureCreateManyInput = {
    id?: number
    feature: string
    price: number
    webDevDetailId: number
  }

  export type WebDevelopmentFeatureUpdateManyMutationInput = {
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type WebDevelopmentFeatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    webDevDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type SeoDetailCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSeoDetailsInput
    seoTypes?: SeoTypeCreateNestedManyWithoutSeoDetailInput
  }

  export type SeoDetailUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    seoTypes?: SeoTypeUncheckedCreateNestedManyWithoutSeoDetailInput
  }

  export type SeoDetailUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSeoDetailsNestedInput
    seoTypes?: SeoTypeUpdateManyWithoutSeoDetailNestedInput
  }

  export type SeoDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    seoTypes?: SeoTypeUncheckedUpdateManyWithoutSeoDetailNestedInput
  }

  export type SeoDetailCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type SeoDetailUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type SeoTypeCreateInput = {
    seoType: string
    price: number
    seoDetail: SeoDetailCreateNestedOneWithoutSeoTypesInput
  }

  export type SeoTypeUncheckedCreateInput = {
    id?: number
    seoType: string
    price: number
    seoDetailId: number
  }

  export type SeoTypeUpdateInput = {
    seoType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    seoDetail?: SeoDetailUpdateOneRequiredWithoutSeoTypesNestedInput
  }

  export type SeoTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seoType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    seoDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type SeoTypeCreateManyInput = {
    id?: number
    seoType: string
    price: number
    seoDetailId: number
  }

  export type SeoTypeUpdateManyMutationInput = {
    seoType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type SeoTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seoType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    seoDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type DigitalMarketingDetailCreateInput = {
    targetAudience?: string | null
    marketingBudget?: number | null
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDigitalMarketingDetailsInput
    marketingServices?: DigitalMarketingServiceCreateNestedManyWithoutDigitalMarketingDetailInput
    socialPlatforms?: SocialPlatformCreateNestedManyWithoutDigitalMarketingDetailInput
  }

  export type DigitalMarketingDetailUncheckedCreateInput = {
    id?: number
    targetAudience?: string | null
    marketingBudget?: number | null
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    marketingServices?: DigitalMarketingServiceUncheckedCreateNestedManyWithoutDigitalMarketingDetailInput
    socialPlatforms?: SocialPlatformUncheckedCreateNestedManyWithoutDigitalMarketingDetailInput
  }

  export type DigitalMarketingDetailUpdateInput = {
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDigitalMarketingDetailsNestedInput
    marketingServices?: DigitalMarketingServiceUpdateManyWithoutDigitalMarketingDetailNestedInput
    socialPlatforms?: SocialPlatformUpdateManyWithoutDigitalMarketingDetailNestedInput
  }

  export type DigitalMarketingDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    marketingServices?: DigitalMarketingServiceUncheckedUpdateManyWithoutDigitalMarketingDetailNestedInput
    socialPlatforms?: SocialPlatformUncheckedUpdateManyWithoutDigitalMarketingDetailNestedInput
  }

  export type DigitalMarketingDetailCreateManyInput = {
    id?: number
    targetAudience?: string | null
    marketingBudget?: number | null
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type DigitalMarketingDetailUpdateManyMutationInput = {
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DigitalMarketingDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type DigitalMarketingServiceCreateInput = {
    service: string
    price: number
    digitalMarketingDetail: DigitalMarketingDetailCreateNestedOneWithoutMarketingServicesInput
  }

  export type DigitalMarketingServiceUncheckedCreateInput = {
    id?: number
    service: string
    price: number
    digitalMarketingDetailId: number
  }

  export type DigitalMarketingServiceUpdateInput = {
    service?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    digitalMarketingDetail?: DigitalMarketingDetailUpdateOneRequiredWithoutMarketingServicesNestedInput
  }

  export type DigitalMarketingServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    service?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    digitalMarketingDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type DigitalMarketingServiceCreateManyInput = {
    id?: number
    service: string
    price: number
    digitalMarketingDetailId: number
  }

  export type DigitalMarketingServiceUpdateManyMutationInput = {
    service?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type DigitalMarketingServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    service?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    digitalMarketingDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type SocialPlatformCreateInput = {
    platform: string
    price: number
    digitalMarketingDetail: DigitalMarketingDetailCreateNestedOneWithoutSocialPlatformsInput
  }

  export type SocialPlatformUncheckedCreateInput = {
    id?: number
    platform: string
    price: number
    digitalMarketingDetailId: number
  }

  export type SocialPlatformUpdateInput = {
    platform?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    digitalMarketingDetail?: DigitalMarketingDetailUpdateOneRequiredWithoutSocialPlatformsNestedInput
  }

  export type SocialPlatformUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    digitalMarketingDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type SocialPlatformCreateManyInput = {
    id?: number
    platform: string
    price: number
    digitalMarketingDetailId: number
  }

  export type SocialPlatformUpdateManyMutationInput = {
    platform?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type SocialPlatformUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    digitalMarketingDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentGenerationDetailCreateInput = {
    volume?: string | null
    contentTone?: string | null
    targetKeywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutContentGenerationDetailsInput
    contentTypes?: ContentTypeCreateNestedManyWithoutContentGenerationDetailInput
    contentLanguages?: ContentLanguageCreateNestedManyWithoutContentGenerationDetailInput
  }

  export type ContentGenerationDetailUncheckedCreateInput = {
    id?: number
    volume?: string | null
    contentTone?: string | null
    targetKeywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    contentTypes?: ContentTypeUncheckedCreateNestedManyWithoutContentGenerationDetailInput
    contentLanguages?: ContentLanguageUncheckedCreateNestedManyWithoutContentGenerationDetailInput
  }

  export type ContentGenerationDetailUpdateInput = {
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutContentGenerationDetailsNestedInput
    contentTypes?: ContentTypeUpdateManyWithoutContentGenerationDetailNestedInput
    contentLanguages?: ContentLanguageUpdateManyWithoutContentGenerationDetailNestedInput
  }

  export type ContentGenerationDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    contentTypes?: ContentTypeUncheckedUpdateManyWithoutContentGenerationDetailNestedInput
    contentLanguages?: ContentLanguageUncheckedUpdateManyWithoutContentGenerationDetailNestedInput
  }

  export type ContentGenerationDetailCreateManyInput = {
    id?: number
    volume?: string | null
    contentTone?: string | null
    targetKeywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type ContentGenerationDetailUpdateManyMutationInput = {
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentGenerationDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTypeCreateInput = {
    contentType: string
    price: number
    contentGenerationDetail: ContentGenerationDetailCreateNestedOneWithoutContentTypesInput
  }

  export type ContentTypeUncheckedCreateInput = {
    id?: number
    contentType: string
    price: number
    contentGenerationDetailId: number
  }

  export type ContentTypeUpdateInput = {
    contentType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    contentGenerationDetail?: ContentGenerationDetailUpdateOneRequiredWithoutContentTypesNestedInput
  }

  export type ContentTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    contentGenerationDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentTypeCreateManyInput = {
    id?: number
    contentType: string
    price: number
    contentGenerationDetailId: number
  }

  export type ContentTypeUpdateManyMutationInput = {
    contentType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ContentTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    contentGenerationDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentLanguageCreateInput = {
    language: string
    price: number
    contentGenerationDetail: ContentGenerationDetailCreateNestedOneWithoutContentLanguagesInput
  }

  export type ContentLanguageUncheckedCreateInput = {
    id?: number
    language: string
    price: number
    contentGenerationDetailId: number
  }

  export type ContentLanguageUpdateInput = {
    language?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    contentGenerationDetail?: ContentGenerationDetailUpdateOneRequiredWithoutContentLanguagesNestedInput
  }

  export type ContentLanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    contentGenerationDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentLanguageCreateManyInput = {
    id?: number
    language: string
    price: number
    contentGenerationDetailId: number
  }

  export type ContentLanguageUpdateManyMutationInput = {
    language?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ContentLanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    contentGenerationDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type AppDevelopmentDetailCreateInput = {
    appType?: string | null
    complexity?: string | null
    targetPlatforms?: string | null
    expectedUsers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAppDevelopmentDetailsInput
    appFeatures?: AppFeatureCreateNestedManyWithoutAppDevelopmentDetailInput
  }

  export type AppDevelopmentDetailUncheckedCreateInput = {
    id?: number
    appType?: string | null
    complexity?: string | null
    targetPlatforms?: string | null
    expectedUsers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    appFeatures?: AppFeatureUncheckedCreateNestedManyWithoutAppDevelopmentDetailInput
  }

  export type AppDevelopmentDetailUpdateInput = {
    appType?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: NullableStringFieldUpdateOperationsInput | string | null
    targetPlatforms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAppDevelopmentDetailsNestedInput
    appFeatures?: AppFeatureUpdateManyWithoutAppDevelopmentDetailNestedInput
  }

  export type AppDevelopmentDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    appType?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: NullableStringFieldUpdateOperationsInput | string | null
    targetPlatforms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    appFeatures?: AppFeatureUncheckedUpdateManyWithoutAppDevelopmentDetailNestedInput
  }

  export type AppDevelopmentDetailCreateManyInput = {
    id?: number
    appType?: string | null
    complexity?: string | null
    targetPlatforms?: string | null
    expectedUsers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type AppDevelopmentDetailUpdateManyMutationInput = {
    appType?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: NullableStringFieldUpdateOperationsInput | string | null
    targetPlatforms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppDevelopmentDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    appType?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: NullableStringFieldUpdateOperationsInput | string | null
    targetPlatforms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type AppFeatureCreateInput = {
    feature: string
    price: number
    appDevelopmentDetail: AppDevelopmentDetailCreateNestedOneWithoutAppFeaturesInput
  }

  export type AppFeatureUncheckedCreateInput = {
    id?: number
    feature: string
    price: number
    appDevelopmentDetailId: number
  }

  export type AppFeatureUpdateInput = {
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    appDevelopmentDetail?: AppDevelopmentDetailUpdateOneRequiredWithoutAppFeaturesNestedInput
  }

  export type AppFeatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    appDevelopmentDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type AppFeatureCreateManyInput = {
    id?: number
    feature: string
    price: number
    appDevelopmentDetailId: number
  }

  export type AppFeatureUpdateManyMutationInput = {
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type AppFeatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    appDevelopmentDetailId?: IntFieldUpdateOperationsInput | number
  }

  export type AdminCreateInput = {
    email: string
    password: string
    name: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatusHistoryCreateInput = {
    projectId: number
    oldStatus?: string | null
    newStatus: string
    changedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProjectStatusHistoryUncheckedCreateInput = {
    id?: number
    projectId: number
    oldStatus?: string | null
    newStatus: string
    changedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProjectStatusHistoryUpdateInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatusHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatusHistoryCreateManyInput = {
    id?: number
    projectId: number
    oldStatus?: string | null
    newStatus: string
    changedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProjectStatusHistoryUpdateManyMutationInput = {
    projectId?: IntFieldUpdateOperationsInput | number
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatusHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    projectId?: IntFieldUpdateOperationsInput | number
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioProjectCreateInput = {
    title: string
    category: string
    image: string
    description: string
    technologies: string
    liveUrl: string
    githubUrl?: string | null
    featured?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioProjectUncheckedCreateInput = {
    id?: number
    title: string
    category: string
    image: string
    description: string
    technologies: string
    liveUrl: string
    githubUrl?: string | null
    featured?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioProjectUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technologies?: StringFieldUpdateOperationsInput | string
    liveUrl?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technologies?: StringFieldUpdateOperationsInput | string
    liveUrl?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioProjectCreateManyInput = {
    id?: number
    title: string
    category: string
    image: string
    description: string
    technologies: string
    liveUrl: string
    githubUrl?: string | null
    featured?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortfolioProjectUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technologies?: StringFieldUpdateOperationsInput | string
    liveUrl?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    technologies?: StringFieldUpdateOperationsInput | string
    liveUrl?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ContactFormListRelationFilter = {
    every?: ContactFormWhereInput
    some?: ContactFormWhereInput
    none?: ContactFormWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    full_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    full_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    full_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ContactFormOrderByRelevanceInput = {
    fields: ContactFormOrderByRelevanceFieldEnum | ContactFormOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactFormCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ContactFormAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ContactFormMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ContactFormMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ContactFormSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type WebDevelopmentDetailNullableScalarRelationFilter = {
    is?: WebDevelopmentDetailWhereInput | null
    isNot?: WebDevelopmentDetailWhereInput | null
  }

  export type SeoDetailNullableScalarRelationFilter = {
    is?: SeoDetailWhereInput | null
    isNot?: SeoDetailWhereInput | null
  }

  export type DigitalMarketingDetailNullableScalarRelationFilter = {
    is?: DigitalMarketingDetailWhereInput | null
    isNot?: DigitalMarketingDetailWhereInput | null
  }

  export type ContentGenerationDetailNullableScalarRelationFilter = {
    is?: ContentGenerationDetailWhereInput | null
    isNot?: ContentGenerationDetailWhereInput | null
  }

  export type AppDevelopmentDetailNullableScalarRelationFilter = {
    is?: AppDevelopmentDetailWhereInput | null
    isNot?: AppDevelopmentDetailWhereInput | null
  }

  export type ProjectOrderByRelevanceInput = {
    fields: ProjectOrderByRelevanceFieldEnum | ProjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    projectName?: SortOrder
    projectTitle?: SortOrder
    category?: SortOrder
    price?: SortOrder
    deadline?: SortOrder
    details?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    userId?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    projectName?: SortOrder
    projectTitle?: SortOrder
    category?: SortOrder
    price?: SortOrder
    deadline?: SortOrder
    details?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    projectName?: SortOrder
    projectTitle?: SortOrder
    category?: SortOrder
    price?: SortOrder
    deadline?: SortOrder
    details?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    userId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type WebDevelopmentFeatureListRelationFilter = {
    every?: WebDevelopmentFeatureWhereInput
    some?: WebDevelopmentFeatureWhereInput
    none?: WebDevelopmentFeatureWhereInput
  }

  export type WebDevelopmentFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebDevelopmentDetailOrderByRelevanceInput = {
    fields: WebDevelopmentDetailOrderByRelevanceFieldEnum | WebDevelopmentDetailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WebDevelopmentDetailCountOrderByAggregateInput = {
    id?: SortOrder
    tech?: SortOrder
    webPages?: SortOrder
    projectId?: SortOrder
  }

  export type WebDevelopmentDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    webPages?: SortOrder
    projectId?: SortOrder
  }

  export type WebDevelopmentDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    tech?: SortOrder
    webPages?: SortOrder
    projectId?: SortOrder
  }

  export type WebDevelopmentDetailMinOrderByAggregateInput = {
    id?: SortOrder
    tech?: SortOrder
    webPages?: SortOrder
    projectId?: SortOrder
  }

  export type WebDevelopmentDetailSumOrderByAggregateInput = {
    id?: SortOrder
    webPages?: SortOrder
    projectId?: SortOrder
  }

  export type WebDevelopmentDetailScalarRelationFilter = {
    is?: WebDevelopmentDetailWhereInput
    isNot?: WebDevelopmentDetailWhereInput
  }

  export type WebDevelopmentFeatureOrderByRelevanceInput = {
    fields: WebDevelopmentFeatureOrderByRelevanceFieldEnum | WebDevelopmentFeatureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WebDevelopmentFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    webDevDetailId?: SortOrder
  }

  export type WebDevelopmentFeatureAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    webDevDetailId?: SortOrder
  }

  export type WebDevelopmentFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    webDevDetailId?: SortOrder
  }

  export type WebDevelopmentFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    webDevDetailId?: SortOrder
  }

  export type WebDevelopmentFeatureSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    webDevDetailId?: SortOrder
  }

  export type SeoTypeListRelationFilter = {
    every?: SeoTypeWhereInput
    some?: SeoTypeWhereInput
    none?: SeoTypeWhereInput
  }

  export type SeoTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeoDetailCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SeoDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type SeoDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SeoDetailMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SeoDetailSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type SeoDetailScalarRelationFilter = {
    is?: SeoDetailWhereInput
    isNot?: SeoDetailWhereInput
  }

  export type SeoTypeOrderByRelevanceInput = {
    fields: SeoTypeOrderByRelevanceFieldEnum | SeoTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SeoTypeCountOrderByAggregateInput = {
    id?: SortOrder
    seoType?: SortOrder
    price?: SortOrder
    seoDetailId?: SortOrder
  }

  export type SeoTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    seoDetailId?: SortOrder
  }

  export type SeoTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    seoType?: SortOrder
    price?: SortOrder
    seoDetailId?: SortOrder
  }

  export type SeoTypeMinOrderByAggregateInput = {
    id?: SortOrder
    seoType?: SortOrder
    price?: SortOrder
    seoDetailId?: SortOrder
  }

  export type SeoTypeSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    seoDetailId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DigitalMarketingServiceListRelationFilter = {
    every?: DigitalMarketingServiceWhereInput
    some?: DigitalMarketingServiceWhereInput
    none?: DigitalMarketingServiceWhereInput
  }

  export type SocialPlatformListRelationFilter = {
    every?: SocialPlatformWhereInput
    some?: SocialPlatformWhereInput
    none?: SocialPlatformWhereInput
  }

  export type DigitalMarketingServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialPlatformOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DigitalMarketingDetailOrderByRelevanceInput = {
    fields: DigitalMarketingDetailOrderByRelevanceFieldEnum | DigitalMarketingDetailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DigitalMarketingDetailCountOrderByAggregateInput = {
    id?: SortOrder
    targetAudience?: SortOrder
    marketingBudget?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type DigitalMarketingDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    marketingBudget?: SortOrder
    projectId?: SortOrder
  }

  export type DigitalMarketingDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    targetAudience?: SortOrder
    marketingBudget?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type DigitalMarketingDetailMinOrderByAggregateInput = {
    id?: SortOrder
    targetAudience?: SortOrder
    marketingBudget?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type DigitalMarketingDetailSumOrderByAggregateInput = {
    id?: SortOrder
    marketingBudget?: SortOrder
    projectId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DigitalMarketingDetailScalarRelationFilter = {
    is?: DigitalMarketingDetailWhereInput
    isNot?: DigitalMarketingDetailWhereInput
  }

  export type DigitalMarketingServiceOrderByRelevanceInput = {
    fields: DigitalMarketingServiceOrderByRelevanceFieldEnum | DigitalMarketingServiceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DigitalMarketingServiceCountOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type DigitalMarketingServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type DigitalMarketingServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type DigitalMarketingServiceMinOrderByAggregateInput = {
    id?: SortOrder
    service?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type DigitalMarketingServiceSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type SocialPlatformOrderByRelevanceInput = {
    fields: SocialPlatformOrderByRelevanceFieldEnum | SocialPlatformOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SocialPlatformCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type SocialPlatformAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type SocialPlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type SocialPlatformMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type SocialPlatformSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    digitalMarketingDetailId?: SortOrder
  }

  export type ContentTypeListRelationFilter = {
    every?: ContentTypeWhereInput
    some?: ContentTypeWhereInput
    none?: ContentTypeWhereInput
  }

  export type ContentLanguageListRelationFilter = {
    every?: ContentLanguageWhereInput
    some?: ContentLanguageWhereInput
    none?: ContentLanguageWhereInput
  }

  export type ContentTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentLanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentGenerationDetailOrderByRelevanceInput = {
    fields: ContentGenerationDetailOrderByRelevanceFieldEnum | ContentGenerationDetailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContentGenerationDetailCountOrderByAggregateInput = {
    id?: SortOrder
    volume?: SortOrder
    contentTone?: SortOrder
    targetKeywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ContentGenerationDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ContentGenerationDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    volume?: SortOrder
    contentTone?: SortOrder
    targetKeywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ContentGenerationDetailMinOrderByAggregateInput = {
    id?: SortOrder
    volume?: SortOrder
    contentTone?: SortOrder
    targetKeywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ContentGenerationDetailSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ContentGenerationDetailScalarRelationFilter = {
    is?: ContentGenerationDetailWhereInput
    isNot?: ContentGenerationDetailWhereInput
  }

  export type ContentTypeOrderByRelevanceInput = {
    fields: ContentTypeOrderByRelevanceFieldEnum | ContentTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type ContentTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type ContentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type ContentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type ContentTypeSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type ContentLanguageOrderByRelevanceInput = {
    fields: ContentLanguageOrderByRelevanceFieldEnum | ContentLanguageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContentLanguageCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type ContentLanguageAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type ContentLanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type ContentLanguageMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type ContentLanguageSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    contentGenerationDetailId?: SortOrder
  }

  export type AppFeatureListRelationFilter = {
    every?: AppFeatureWhereInput
    some?: AppFeatureWhereInput
    none?: AppFeatureWhereInput
  }

  export type AppFeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppDevelopmentDetailOrderByRelevanceInput = {
    fields: AppDevelopmentDetailOrderByRelevanceFieldEnum | AppDevelopmentDetailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AppDevelopmentDetailCountOrderByAggregateInput = {
    id?: SortOrder
    appType?: SortOrder
    complexity?: SortOrder
    targetPlatforms?: SortOrder
    expectedUsers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type AppDevelopmentDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    expectedUsers?: SortOrder
    projectId?: SortOrder
  }

  export type AppDevelopmentDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    appType?: SortOrder
    complexity?: SortOrder
    targetPlatforms?: SortOrder
    expectedUsers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type AppDevelopmentDetailMinOrderByAggregateInput = {
    id?: SortOrder
    appType?: SortOrder
    complexity?: SortOrder
    targetPlatforms?: SortOrder
    expectedUsers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type AppDevelopmentDetailSumOrderByAggregateInput = {
    id?: SortOrder
    expectedUsers?: SortOrder
    projectId?: SortOrder
  }

  export type AppDevelopmentDetailScalarRelationFilter = {
    is?: AppDevelopmentDetailWhereInput
    isNot?: AppDevelopmentDetailWhereInput
  }

  export type AppFeatureOrderByRelevanceInput = {
    fields: AppFeatureOrderByRelevanceFieldEnum | AppFeatureOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AppFeatureCountOrderByAggregateInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    appDevelopmentDetailId?: SortOrder
  }

  export type AppFeatureAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    appDevelopmentDetailId?: SortOrder
  }

  export type AppFeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    appDevelopmentDetailId?: SortOrder
  }

  export type AppFeatureMinOrderByAggregateInput = {
    id?: SortOrder
    feature?: SortOrder
    price?: SortOrder
    appDevelopmentDetailId?: SortOrder
  }

  export type AppFeatureSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    appDevelopmentDetailId?: SortOrder
  }

  export type AdminOrderByRelevanceInput = {
    fields: AdminOrderByRelevanceFieldEnum | AdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProjectStatusHistoryOrderByRelevanceInput = {
    fields: ProjectStatusHistoryOrderByRelevanceFieldEnum | ProjectStatusHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProjectStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectStatusHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectStatusHistorySumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PortfolioProjectOrderByRelevanceInput = {
    fields: PortfolioProjectOrderByRelevanceFieldEnum | PortfolioProjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PortfolioProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrder
    technologies?: SortOrder
    liveUrl?: SortOrder
    githubUrl?: SortOrder
    featured?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioProjectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PortfolioProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrder
    technologies?: SortOrder
    liveUrl?: SortOrder
    githubUrl?: SortOrder
    featured?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrder
    technologies?: SortOrder
    liveUrl?: SortOrder
    githubUrl?: SortOrder
    featured?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioProjectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ContactFormCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactFormCreateWithoutUserInput, ContactFormUncheckedCreateWithoutUserInput> | ContactFormCreateWithoutUserInput[] | ContactFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactFormCreateOrConnectWithoutUserInput | ContactFormCreateOrConnectWithoutUserInput[]
    createMany?: ContactFormCreateManyUserInputEnvelope
    connect?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ContactFormUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactFormCreateWithoutUserInput, ContactFormUncheckedCreateWithoutUserInput> | ContactFormCreateWithoutUserInput[] | ContactFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactFormCreateOrConnectWithoutUserInput | ContactFormCreateOrConnectWithoutUserInput[]
    createMany?: ContactFormCreateManyUserInputEnvelope
    connect?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ContactFormUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactFormCreateWithoutUserInput, ContactFormUncheckedCreateWithoutUserInput> | ContactFormCreateWithoutUserInput[] | ContactFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactFormCreateOrConnectWithoutUserInput | ContactFormCreateOrConnectWithoutUserInput[]
    upsert?: ContactFormUpsertWithWhereUniqueWithoutUserInput | ContactFormUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactFormCreateManyUserInputEnvelope
    set?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
    disconnect?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
    delete?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
    connect?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
    update?: ContactFormUpdateWithWhereUniqueWithoutUserInput | ContactFormUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactFormUpdateManyWithWhereWithoutUserInput | ContactFormUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactFormScalarWhereInput | ContactFormScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput> | ProjectCreateWithoutUserInput[] | ProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutUserInput | ProjectCreateOrConnectWithoutUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutUserInput | ProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectCreateManyUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutUserInput | ProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutUserInput | ProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ContactFormUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactFormCreateWithoutUserInput, ContactFormUncheckedCreateWithoutUserInput> | ContactFormCreateWithoutUserInput[] | ContactFormUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactFormCreateOrConnectWithoutUserInput | ContactFormCreateOrConnectWithoutUserInput[]
    upsert?: ContactFormUpsertWithWhereUniqueWithoutUserInput | ContactFormUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactFormCreateManyUserInputEnvelope
    set?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
    disconnect?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
    delete?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
    connect?: ContactFormWhereUniqueInput | ContactFormWhereUniqueInput[]
    update?: ContactFormUpdateWithWhereUniqueWithoutUserInput | ContactFormUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactFormUpdateManyWithWhereWithoutUserInput | ContactFormUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactFormScalarWhereInput | ContactFormScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutContactFormsInput = {
    create?: XOR<UserCreateWithoutContactFormsInput, UserUncheckedCreateWithoutContactFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactFormsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutContactFormsNestedInput = {
    create?: XOR<UserCreateWithoutContactFormsInput, UserUncheckedCreateWithoutContactFormsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactFormsInput
    upsert?: UserUpsertWithoutContactFormsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactFormsInput, UserUpdateWithoutContactFormsInput>, UserUncheckedUpdateWithoutContactFormsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type WebDevelopmentDetailCreateNestedOneWithoutProjectInput = {
    create?: XOR<WebDevelopmentDetailCreateWithoutProjectInput, WebDevelopmentDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: WebDevelopmentDetailCreateOrConnectWithoutProjectInput
    connect?: WebDevelopmentDetailWhereUniqueInput
  }

  export type SeoDetailCreateNestedOneWithoutProjectInput = {
    create?: XOR<SeoDetailCreateWithoutProjectInput, SeoDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: SeoDetailCreateOrConnectWithoutProjectInput
    connect?: SeoDetailWhereUniqueInput
  }

  export type DigitalMarketingDetailCreateNestedOneWithoutProjectInput = {
    create?: XOR<DigitalMarketingDetailCreateWithoutProjectInput, DigitalMarketingDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: DigitalMarketingDetailCreateOrConnectWithoutProjectInput
    connect?: DigitalMarketingDetailWhereUniqueInput
  }

  export type ContentGenerationDetailCreateNestedOneWithoutProjectInput = {
    create?: XOR<ContentGenerationDetailCreateWithoutProjectInput, ContentGenerationDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ContentGenerationDetailCreateOrConnectWithoutProjectInput
    connect?: ContentGenerationDetailWhereUniqueInput
  }

  export type AppDevelopmentDetailCreateNestedOneWithoutProjectInput = {
    create?: XOR<AppDevelopmentDetailCreateWithoutProjectInput, AppDevelopmentDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: AppDevelopmentDetailCreateOrConnectWithoutProjectInput
    connect?: AppDevelopmentDetailWhereUniqueInput
  }

  export type WebDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<WebDevelopmentDetailCreateWithoutProjectInput, WebDevelopmentDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: WebDevelopmentDetailCreateOrConnectWithoutProjectInput
    connect?: WebDevelopmentDetailWhereUniqueInput
  }

  export type SeoDetailUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<SeoDetailCreateWithoutProjectInput, SeoDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: SeoDetailCreateOrConnectWithoutProjectInput
    connect?: SeoDetailWhereUniqueInput
  }

  export type DigitalMarketingDetailUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<DigitalMarketingDetailCreateWithoutProjectInput, DigitalMarketingDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: DigitalMarketingDetailCreateOrConnectWithoutProjectInput
    connect?: DigitalMarketingDetailWhereUniqueInput
  }

  export type ContentGenerationDetailUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<ContentGenerationDetailCreateWithoutProjectInput, ContentGenerationDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ContentGenerationDetailCreateOrConnectWithoutProjectInput
    connect?: ContentGenerationDetailWhereUniqueInput
  }

  export type AppDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<AppDevelopmentDetailCreateWithoutProjectInput, AppDevelopmentDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: AppDevelopmentDetailCreateOrConnectWithoutProjectInput
    connect?: AppDevelopmentDetailWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type WebDevelopmentDetailUpdateOneWithoutProjectNestedInput = {
    create?: XOR<WebDevelopmentDetailCreateWithoutProjectInput, WebDevelopmentDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: WebDevelopmentDetailCreateOrConnectWithoutProjectInput
    upsert?: WebDevelopmentDetailUpsertWithoutProjectInput
    disconnect?: WebDevelopmentDetailWhereInput | boolean
    delete?: WebDevelopmentDetailWhereInput | boolean
    connect?: WebDevelopmentDetailWhereUniqueInput
    update?: XOR<XOR<WebDevelopmentDetailUpdateToOneWithWhereWithoutProjectInput, WebDevelopmentDetailUpdateWithoutProjectInput>, WebDevelopmentDetailUncheckedUpdateWithoutProjectInput>
  }

  export type SeoDetailUpdateOneWithoutProjectNestedInput = {
    create?: XOR<SeoDetailCreateWithoutProjectInput, SeoDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: SeoDetailCreateOrConnectWithoutProjectInput
    upsert?: SeoDetailUpsertWithoutProjectInput
    disconnect?: SeoDetailWhereInput | boolean
    delete?: SeoDetailWhereInput | boolean
    connect?: SeoDetailWhereUniqueInput
    update?: XOR<XOR<SeoDetailUpdateToOneWithWhereWithoutProjectInput, SeoDetailUpdateWithoutProjectInput>, SeoDetailUncheckedUpdateWithoutProjectInput>
  }

  export type DigitalMarketingDetailUpdateOneWithoutProjectNestedInput = {
    create?: XOR<DigitalMarketingDetailCreateWithoutProjectInput, DigitalMarketingDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: DigitalMarketingDetailCreateOrConnectWithoutProjectInput
    upsert?: DigitalMarketingDetailUpsertWithoutProjectInput
    disconnect?: DigitalMarketingDetailWhereInput | boolean
    delete?: DigitalMarketingDetailWhereInput | boolean
    connect?: DigitalMarketingDetailWhereUniqueInput
    update?: XOR<XOR<DigitalMarketingDetailUpdateToOneWithWhereWithoutProjectInput, DigitalMarketingDetailUpdateWithoutProjectInput>, DigitalMarketingDetailUncheckedUpdateWithoutProjectInput>
  }

  export type ContentGenerationDetailUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ContentGenerationDetailCreateWithoutProjectInput, ContentGenerationDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ContentGenerationDetailCreateOrConnectWithoutProjectInput
    upsert?: ContentGenerationDetailUpsertWithoutProjectInput
    disconnect?: ContentGenerationDetailWhereInput | boolean
    delete?: ContentGenerationDetailWhereInput | boolean
    connect?: ContentGenerationDetailWhereUniqueInput
    update?: XOR<XOR<ContentGenerationDetailUpdateToOneWithWhereWithoutProjectInput, ContentGenerationDetailUpdateWithoutProjectInput>, ContentGenerationDetailUncheckedUpdateWithoutProjectInput>
  }

  export type AppDevelopmentDetailUpdateOneWithoutProjectNestedInput = {
    create?: XOR<AppDevelopmentDetailCreateWithoutProjectInput, AppDevelopmentDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: AppDevelopmentDetailCreateOrConnectWithoutProjectInput
    upsert?: AppDevelopmentDetailUpsertWithoutProjectInput
    disconnect?: AppDevelopmentDetailWhereInput | boolean
    delete?: AppDevelopmentDetailWhereInput | boolean
    connect?: AppDevelopmentDetailWhereUniqueInput
    update?: XOR<XOR<AppDevelopmentDetailUpdateToOneWithWhereWithoutProjectInput, AppDevelopmentDetailUpdateWithoutProjectInput>, AppDevelopmentDetailUncheckedUpdateWithoutProjectInput>
  }

  export type WebDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<WebDevelopmentDetailCreateWithoutProjectInput, WebDevelopmentDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: WebDevelopmentDetailCreateOrConnectWithoutProjectInput
    upsert?: WebDevelopmentDetailUpsertWithoutProjectInput
    disconnect?: WebDevelopmentDetailWhereInput | boolean
    delete?: WebDevelopmentDetailWhereInput | boolean
    connect?: WebDevelopmentDetailWhereUniqueInput
    update?: XOR<XOR<WebDevelopmentDetailUpdateToOneWithWhereWithoutProjectInput, WebDevelopmentDetailUpdateWithoutProjectInput>, WebDevelopmentDetailUncheckedUpdateWithoutProjectInput>
  }

  export type SeoDetailUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<SeoDetailCreateWithoutProjectInput, SeoDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: SeoDetailCreateOrConnectWithoutProjectInput
    upsert?: SeoDetailUpsertWithoutProjectInput
    disconnect?: SeoDetailWhereInput | boolean
    delete?: SeoDetailWhereInput | boolean
    connect?: SeoDetailWhereUniqueInput
    update?: XOR<XOR<SeoDetailUpdateToOneWithWhereWithoutProjectInput, SeoDetailUpdateWithoutProjectInput>, SeoDetailUncheckedUpdateWithoutProjectInput>
  }

  export type DigitalMarketingDetailUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<DigitalMarketingDetailCreateWithoutProjectInput, DigitalMarketingDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: DigitalMarketingDetailCreateOrConnectWithoutProjectInput
    upsert?: DigitalMarketingDetailUpsertWithoutProjectInput
    disconnect?: DigitalMarketingDetailWhereInput | boolean
    delete?: DigitalMarketingDetailWhereInput | boolean
    connect?: DigitalMarketingDetailWhereUniqueInput
    update?: XOR<XOR<DigitalMarketingDetailUpdateToOneWithWhereWithoutProjectInput, DigitalMarketingDetailUpdateWithoutProjectInput>, DigitalMarketingDetailUncheckedUpdateWithoutProjectInput>
  }

  export type ContentGenerationDetailUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ContentGenerationDetailCreateWithoutProjectInput, ContentGenerationDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ContentGenerationDetailCreateOrConnectWithoutProjectInput
    upsert?: ContentGenerationDetailUpsertWithoutProjectInput
    disconnect?: ContentGenerationDetailWhereInput | boolean
    delete?: ContentGenerationDetailWhereInput | boolean
    connect?: ContentGenerationDetailWhereUniqueInput
    update?: XOR<XOR<ContentGenerationDetailUpdateToOneWithWhereWithoutProjectInput, ContentGenerationDetailUpdateWithoutProjectInput>, ContentGenerationDetailUncheckedUpdateWithoutProjectInput>
  }

  export type AppDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<AppDevelopmentDetailCreateWithoutProjectInput, AppDevelopmentDetailUncheckedCreateWithoutProjectInput>
    connectOrCreate?: AppDevelopmentDetailCreateOrConnectWithoutProjectInput
    upsert?: AppDevelopmentDetailUpsertWithoutProjectInput
    disconnect?: AppDevelopmentDetailWhereInput | boolean
    delete?: AppDevelopmentDetailWhereInput | boolean
    connect?: AppDevelopmentDetailWhereUniqueInput
    update?: XOR<XOR<AppDevelopmentDetailUpdateToOneWithWhereWithoutProjectInput, AppDevelopmentDetailUpdateWithoutProjectInput>, AppDevelopmentDetailUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectCreateNestedOneWithoutWebDevelopmentDetailsInput = {
    create?: XOR<ProjectCreateWithoutWebDevelopmentDetailsInput, ProjectUncheckedCreateWithoutWebDevelopmentDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWebDevelopmentDetailsInput
    connect?: ProjectWhereUniqueInput
  }

  export type WebDevelopmentFeatureCreateNestedManyWithoutWebDevDetailInput = {
    create?: XOR<WebDevelopmentFeatureCreateWithoutWebDevDetailInput, WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput> | WebDevelopmentFeatureCreateWithoutWebDevDetailInput[] | WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput[]
    connectOrCreate?: WebDevelopmentFeatureCreateOrConnectWithoutWebDevDetailInput | WebDevelopmentFeatureCreateOrConnectWithoutWebDevDetailInput[]
    createMany?: WebDevelopmentFeatureCreateManyWebDevDetailInputEnvelope
    connect?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
  }

  export type WebDevelopmentFeatureUncheckedCreateNestedManyWithoutWebDevDetailInput = {
    create?: XOR<WebDevelopmentFeatureCreateWithoutWebDevDetailInput, WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput> | WebDevelopmentFeatureCreateWithoutWebDevDetailInput[] | WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput[]
    connectOrCreate?: WebDevelopmentFeatureCreateOrConnectWithoutWebDevDetailInput | WebDevelopmentFeatureCreateOrConnectWithoutWebDevDetailInput[]
    createMany?: WebDevelopmentFeatureCreateManyWebDevDetailInputEnvelope
    connect?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutWebDevelopmentDetailsNestedInput = {
    create?: XOR<ProjectCreateWithoutWebDevelopmentDetailsInput, ProjectUncheckedCreateWithoutWebDevelopmentDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWebDevelopmentDetailsInput
    upsert?: ProjectUpsertWithoutWebDevelopmentDetailsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWebDevelopmentDetailsInput, ProjectUpdateWithoutWebDevelopmentDetailsInput>, ProjectUncheckedUpdateWithoutWebDevelopmentDetailsInput>
  }

  export type WebDevelopmentFeatureUpdateManyWithoutWebDevDetailNestedInput = {
    create?: XOR<WebDevelopmentFeatureCreateWithoutWebDevDetailInput, WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput> | WebDevelopmentFeatureCreateWithoutWebDevDetailInput[] | WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput[]
    connectOrCreate?: WebDevelopmentFeatureCreateOrConnectWithoutWebDevDetailInput | WebDevelopmentFeatureCreateOrConnectWithoutWebDevDetailInput[]
    upsert?: WebDevelopmentFeatureUpsertWithWhereUniqueWithoutWebDevDetailInput | WebDevelopmentFeatureUpsertWithWhereUniqueWithoutWebDevDetailInput[]
    createMany?: WebDevelopmentFeatureCreateManyWebDevDetailInputEnvelope
    set?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
    disconnect?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
    delete?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
    connect?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
    update?: WebDevelopmentFeatureUpdateWithWhereUniqueWithoutWebDevDetailInput | WebDevelopmentFeatureUpdateWithWhereUniqueWithoutWebDevDetailInput[]
    updateMany?: WebDevelopmentFeatureUpdateManyWithWhereWithoutWebDevDetailInput | WebDevelopmentFeatureUpdateManyWithWhereWithoutWebDevDetailInput[]
    deleteMany?: WebDevelopmentFeatureScalarWhereInput | WebDevelopmentFeatureScalarWhereInput[]
  }

  export type WebDevelopmentFeatureUncheckedUpdateManyWithoutWebDevDetailNestedInput = {
    create?: XOR<WebDevelopmentFeatureCreateWithoutWebDevDetailInput, WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput> | WebDevelopmentFeatureCreateWithoutWebDevDetailInput[] | WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput[]
    connectOrCreate?: WebDevelopmentFeatureCreateOrConnectWithoutWebDevDetailInput | WebDevelopmentFeatureCreateOrConnectWithoutWebDevDetailInput[]
    upsert?: WebDevelopmentFeatureUpsertWithWhereUniqueWithoutWebDevDetailInput | WebDevelopmentFeatureUpsertWithWhereUniqueWithoutWebDevDetailInput[]
    createMany?: WebDevelopmentFeatureCreateManyWebDevDetailInputEnvelope
    set?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
    disconnect?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
    delete?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
    connect?: WebDevelopmentFeatureWhereUniqueInput | WebDevelopmentFeatureWhereUniqueInput[]
    update?: WebDevelopmentFeatureUpdateWithWhereUniqueWithoutWebDevDetailInput | WebDevelopmentFeatureUpdateWithWhereUniqueWithoutWebDevDetailInput[]
    updateMany?: WebDevelopmentFeatureUpdateManyWithWhereWithoutWebDevDetailInput | WebDevelopmentFeatureUpdateManyWithWhereWithoutWebDevDetailInput[]
    deleteMany?: WebDevelopmentFeatureScalarWhereInput | WebDevelopmentFeatureScalarWhereInput[]
  }

  export type WebDevelopmentDetailCreateNestedOneWithoutWebFeaturesInput = {
    create?: XOR<WebDevelopmentDetailCreateWithoutWebFeaturesInput, WebDevelopmentDetailUncheckedCreateWithoutWebFeaturesInput>
    connectOrCreate?: WebDevelopmentDetailCreateOrConnectWithoutWebFeaturesInput
    connect?: WebDevelopmentDetailWhereUniqueInput
  }

  export type WebDevelopmentDetailUpdateOneRequiredWithoutWebFeaturesNestedInput = {
    create?: XOR<WebDevelopmentDetailCreateWithoutWebFeaturesInput, WebDevelopmentDetailUncheckedCreateWithoutWebFeaturesInput>
    connectOrCreate?: WebDevelopmentDetailCreateOrConnectWithoutWebFeaturesInput
    upsert?: WebDevelopmentDetailUpsertWithoutWebFeaturesInput
    connect?: WebDevelopmentDetailWhereUniqueInput
    update?: XOR<XOR<WebDevelopmentDetailUpdateToOneWithWhereWithoutWebFeaturesInput, WebDevelopmentDetailUpdateWithoutWebFeaturesInput>, WebDevelopmentDetailUncheckedUpdateWithoutWebFeaturesInput>
  }

  export type ProjectCreateNestedOneWithoutSeoDetailsInput = {
    create?: XOR<ProjectCreateWithoutSeoDetailsInput, ProjectUncheckedCreateWithoutSeoDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSeoDetailsInput
    connect?: ProjectWhereUniqueInput
  }

  export type SeoTypeCreateNestedManyWithoutSeoDetailInput = {
    create?: XOR<SeoTypeCreateWithoutSeoDetailInput, SeoTypeUncheckedCreateWithoutSeoDetailInput> | SeoTypeCreateWithoutSeoDetailInput[] | SeoTypeUncheckedCreateWithoutSeoDetailInput[]
    connectOrCreate?: SeoTypeCreateOrConnectWithoutSeoDetailInput | SeoTypeCreateOrConnectWithoutSeoDetailInput[]
    createMany?: SeoTypeCreateManySeoDetailInputEnvelope
    connect?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
  }

  export type SeoTypeUncheckedCreateNestedManyWithoutSeoDetailInput = {
    create?: XOR<SeoTypeCreateWithoutSeoDetailInput, SeoTypeUncheckedCreateWithoutSeoDetailInput> | SeoTypeCreateWithoutSeoDetailInput[] | SeoTypeUncheckedCreateWithoutSeoDetailInput[]
    connectOrCreate?: SeoTypeCreateOrConnectWithoutSeoDetailInput | SeoTypeCreateOrConnectWithoutSeoDetailInput[]
    createMany?: SeoTypeCreateManySeoDetailInputEnvelope
    connect?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutSeoDetailsNestedInput = {
    create?: XOR<ProjectCreateWithoutSeoDetailsInput, ProjectUncheckedCreateWithoutSeoDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSeoDetailsInput
    upsert?: ProjectUpsertWithoutSeoDetailsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSeoDetailsInput, ProjectUpdateWithoutSeoDetailsInput>, ProjectUncheckedUpdateWithoutSeoDetailsInput>
  }

  export type SeoTypeUpdateManyWithoutSeoDetailNestedInput = {
    create?: XOR<SeoTypeCreateWithoutSeoDetailInput, SeoTypeUncheckedCreateWithoutSeoDetailInput> | SeoTypeCreateWithoutSeoDetailInput[] | SeoTypeUncheckedCreateWithoutSeoDetailInput[]
    connectOrCreate?: SeoTypeCreateOrConnectWithoutSeoDetailInput | SeoTypeCreateOrConnectWithoutSeoDetailInput[]
    upsert?: SeoTypeUpsertWithWhereUniqueWithoutSeoDetailInput | SeoTypeUpsertWithWhereUniqueWithoutSeoDetailInput[]
    createMany?: SeoTypeCreateManySeoDetailInputEnvelope
    set?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
    disconnect?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
    delete?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
    connect?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
    update?: SeoTypeUpdateWithWhereUniqueWithoutSeoDetailInput | SeoTypeUpdateWithWhereUniqueWithoutSeoDetailInput[]
    updateMany?: SeoTypeUpdateManyWithWhereWithoutSeoDetailInput | SeoTypeUpdateManyWithWhereWithoutSeoDetailInput[]
    deleteMany?: SeoTypeScalarWhereInput | SeoTypeScalarWhereInput[]
  }

  export type SeoTypeUncheckedUpdateManyWithoutSeoDetailNestedInput = {
    create?: XOR<SeoTypeCreateWithoutSeoDetailInput, SeoTypeUncheckedCreateWithoutSeoDetailInput> | SeoTypeCreateWithoutSeoDetailInput[] | SeoTypeUncheckedCreateWithoutSeoDetailInput[]
    connectOrCreate?: SeoTypeCreateOrConnectWithoutSeoDetailInput | SeoTypeCreateOrConnectWithoutSeoDetailInput[]
    upsert?: SeoTypeUpsertWithWhereUniqueWithoutSeoDetailInput | SeoTypeUpsertWithWhereUniqueWithoutSeoDetailInput[]
    createMany?: SeoTypeCreateManySeoDetailInputEnvelope
    set?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
    disconnect?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
    delete?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
    connect?: SeoTypeWhereUniqueInput | SeoTypeWhereUniqueInput[]
    update?: SeoTypeUpdateWithWhereUniqueWithoutSeoDetailInput | SeoTypeUpdateWithWhereUniqueWithoutSeoDetailInput[]
    updateMany?: SeoTypeUpdateManyWithWhereWithoutSeoDetailInput | SeoTypeUpdateManyWithWhereWithoutSeoDetailInput[]
    deleteMany?: SeoTypeScalarWhereInput | SeoTypeScalarWhereInput[]
  }

  export type SeoDetailCreateNestedOneWithoutSeoTypesInput = {
    create?: XOR<SeoDetailCreateWithoutSeoTypesInput, SeoDetailUncheckedCreateWithoutSeoTypesInput>
    connectOrCreate?: SeoDetailCreateOrConnectWithoutSeoTypesInput
    connect?: SeoDetailWhereUniqueInput
  }

  export type SeoDetailUpdateOneRequiredWithoutSeoTypesNestedInput = {
    create?: XOR<SeoDetailCreateWithoutSeoTypesInput, SeoDetailUncheckedCreateWithoutSeoTypesInput>
    connectOrCreate?: SeoDetailCreateOrConnectWithoutSeoTypesInput
    upsert?: SeoDetailUpsertWithoutSeoTypesInput
    connect?: SeoDetailWhereUniqueInput
    update?: XOR<XOR<SeoDetailUpdateToOneWithWhereWithoutSeoTypesInput, SeoDetailUpdateWithoutSeoTypesInput>, SeoDetailUncheckedUpdateWithoutSeoTypesInput>
  }

  export type ProjectCreateNestedOneWithoutDigitalMarketingDetailsInput = {
    create?: XOR<ProjectCreateWithoutDigitalMarketingDetailsInput, ProjectUncheckedCreateWithoutDigitalMarketingDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDigitalMarketingDetailsInput
    connect?: ProjectWhereUniqueInput
  }

  export type DigitalMarketingServiceCreateNestedManyWithoutDigitalMarketingDetailInput = {
    create?: XOR<DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput, DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput> | DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput[] | DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput[]
    connectOrCreate?: DigitalMarketingServiceCreateOrConnectWithoutDigitalMarketingDetailInput | DigitalMarketingServiceCreateOrConnectWithoutDigitalMarketingDetailInput[]
    createMany?: DigitalMarketingServiceCreateManyDigitalMarketingDetailInputEnvelope
    connect?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
  }

  export type SocialPlatformCreateNestedManyWithoutDigitalMarketingDetailInput = {
    create?: XOR<SocialPlatformCreateWithoutDigitalMarketingDetailInput, SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput> | SocialPlatformCreateWithoutDigitalMarketingDetailInput[] | SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput[]
    connectOrCreate?: SocialPlatformCreateOrConnectWithoutDigitalMarketingDetailInput | SocialPlatformCreateOrConnectWithoutDigitalMarketingDetailInput[]
    createMany?: SocialPlatformCreateManyDigitalMarketingDetailInputEnvelope
    connect?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
  }

  export type DigitalMarketingServiceUncheckedCreateNestedManyWithoutDigitalMarketingDetailInput = {
    create?: XOR<DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput, DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput> | DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput[] | DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput[]
    connectOrCreate?: DigitalMarketingServiceCreateOrConnectWithoutDigitalMarketingDetailInput | DigitalMarketingServiceCreateOrConnectWithoutDigitalMarketingDetailInput[]
    createMany?: DigitalMarketingServiceCreateManyDigitalMarketingDetailInputEnvelope
    connect?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
  }

  export type SocialPlatformUncheckedCreateNestedManyWithoutDigitalMarketingDetailInput = {
    create?: XOR<SocialPlatformCreateWithoutDigitalMarketingDetailInput, SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput> | SocialPlatformCreateWithoutDigitalMarketingDetailInput[] | SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput[]
    connectOrCreate?: SocialPlatformCreateOrConnectWithoutDigitalMarketingDetailInput | SocialPlatformCreateOrConnectWithoutDigitalMarketingDetailInput[]
    createMany?: SocialPlatformCreateManyDigitalMarketingDetailInputEnvelope
    connect?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutDigitalMarketingDetailsNestedInput = {
    create?: XOR<ProjectCreateWithoutDigitalMarketingDetailsInput, ProjectUncheckedCreateWithoutDigitalMarketingDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDigitalMarketingDetailsInput
    upsert?: ProjectUpsertWithoutDigitalMarketingDetailsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDigitalMarketingDetailsInput, ProjectUpdateWithoutDigitalMarketingDetailsInput>, ProjectUncheckedUpdateWithoutDigitalMarketingDetailsInput>
  }

  export type DigitalMarketingServiceUpdateManyWithoutDigitalMarketingDetailNestedInput = {
    create?: XOR<DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput, DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput> | DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput[] | DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput[]
    connectOrCreate?: DigitalMarketingServiceCreateOrConnectWithoutDigitalMarketingDetailInput | DigitalMarketingServiceCreateOrConnectWithoutDigitalMarketingDetailInput[]
    upsert?: DigitalMarketingServiceUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput | DigitalMarketingServiceUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput[]
    createMany?: DigitalMarketingServiceCreateManyDigitalMarketingDetailInputEnvelope
    set?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
    disconnect?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
    delete?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
    connect?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
    update?: DigitalMarketingServiceUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput | DigitalMarketingServiceUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput[]
    updateMany?: DigitalMarketingServiceUpdateManyWithWhereWithoutDigitalMarketingDetailInput | DigitalMarketingServiceUpdateManyWithWhereWithoutDigitalMarketingDetailInput[]
    deleteMany?: DigitalMarketingServiceScalarWhereInput | DigitalMarketingServiceScalarWhereInput[]
  }

  export type SocialPlatformUpdateManyWithoutDigitalMarketingDetailNestedInput = {
    create?: XOR<SocialPlatformCreateWithoutDigitalMarketingDetailInput, SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput> | SocialPlatformCreateWithoutDigitalMarketingDetailInput[] | SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput[]
    connectOrCreate?: SocialPlatformCreateOrConnectWithoutDigitalMarketingDetailInput | SocialPlatformCreateOrConnectWithoutDigitalMarketingDetailInput[]
    upsert?: SocialPlatformUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput | SocialPlatformUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput[]
    createMany?: SocialPlatformCreateManyDigitalMarketingDetailInputEnvelope
    set?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
    disconnect?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
    delete?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
    connect?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
    update?: SocialPlatformUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput | SocialPlatformUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput[]
    updateMany?: SocialPlatformUpdateManyWithWhereWithoutDigitalMarketingDetailInput | SocialPlatformUpdateManyWithWhereWithoutDigitalMarketingDetailInput[]
    deleteMany?: SocialPlatformScalarWhereInput | SocialPlatformScalarWhereInput[]
  }

  export type DigitalMarketingServiceUncheckedUpdateManyWithoutDigitalMarketingDetailNestedInput = {
    create?: XOR<DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput, DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput> | DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput[] | DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput[]
    connectOrCreate?: DigitalMarketingServiceCreateOrConnectWithoutDigitalMarketingDetailInput | DigitalMarketingServiceCreateOrConnectWithoutDigitalMarketingDetailInput[]
    upsert?: DigitalMarketingServiceUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput | DigitalMarketingServiceUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput[]
    createMany?: DigitalMarketingServiceCreateManyDigitalMarketingDetailInputEnvelope
    set?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
    disconnect?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
    delete?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
    connect?: DigitalMarketingServiceWhereUniqueInput | DigitalMarketingServiceWhereUniqueInput[]
    update?: DigitalMarketingServiceUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput | DigitalMarketingServiceUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput[]
    updateMany?: DigitalMarketingServiceUpdateManyWithWhereWithoutDigitalMarketingDetailInput | DigitalMarketingServiceUpdateManyWithWhereWithoutDigitalMarketingDetailInput[]
    deleteMany?: DigitalMarketingServiceScalarWhereInput | DigitalMarketingServiceScalarWhereInput[]
  }

  export type SocialPlatformUncheckedUpdateManyWithoutDigitalMarketingDetailNestedInput = {
    create?: XOR<SocialPlatformCreateWithoutDigitalMarketingDetailInput, SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput> | SocialPlatformCreateWithoutDigitalMarketingDetailInput[] | SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput[]
    connectOrCreate?: SocialPlatformCreateOrConnectWithoutDigitalMarketingDetailInput | SocialPlatformCreateOrConnectWithoutDigitalMarketingDetailInput[]
    upsert?: SocialPlatformUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput | SocialPlatformUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput[]
    createMany?: SocialPlatformCreateManyDigitalMarketingDetailInputEnvelope
    set?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
    disconnect?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
    delete?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
    connect?: SocialPlatformWhereUniqueInput | SocialPlatformWhereUniqueInput[]
    update?: SocialPlatformUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput | SocialPlatformUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput[]
    updateMany?: SocialPlatformUpdateManyWithWhereWithoutDigitalMarketingDetailInput | SocialPlatformUpdateManyWithWhereWithoutDigitalMarketingDetailInput[]
    deleteMany?: SocialPlatformScalarWhereInput | SocialPlatformScalarWhereInput[]
  }

  export type DigitalMarketingDetailCreateNestedOneWithoutMarketingServicesInput = {
    create?: XOR<DigitalMarketingDetailCreateWithoutMarketingServicesInput, DigitalMarketingDetailUncheckedCreateWithoutMarketingServicesInput>
    connectOrCreate?: DigitalMarketingDetailCreateOrConnectWithoutMarketingServicesInput
    connect?: DigitalMarketingDetailWhereUniqueInput
  }

  export type DigitalMarketingDetailUpdateOneRequiredWithoutMarketingServicesNestedInput = {
    create?: XOR<DigitalMarketingDetailCreateWithoutMarketingServicesInput, DigitalMarketingDetailUncheckedCreateWithoutMarketingServicesInput>
    connectOrCreate?: DigitalMarketingDetailCreateOrConnectWithoutMarketingServicesInput
    upsert?: DigitalMarketingDetailUpsertWithoutMarketingServicesInput
    connect?: DigitalMarketingDetailWhereUniqueInput
    update?: XOR<XOR<DigitalMarketingDetailUpdateToOneWithWhereWithoutMarketingServicesInput, DigitalMarketingDetailUpdateWithoutMarketingServicesInput>, DigitalMarketingDetailUncheckedUpdateWithoutMarketingServicesInput>
  }

  export type DigitalMarketingDetailCreateNestedOneWithoutSocialPlatformsInput = {
    create?: XOR<DigitalMarketingDetailCreateWithoutSocialPlatformsInput, DigitalMarketingDetailUncheckedCreateWithoutSocialPlatformsInput>
    connectOrCreate?: DigitalMarketingDetailCreateOrConnectWithoutSocialPlatformsInput
    connect?: DigitalMarketingDetailWhereUniqueInput
  }

  export type DigitalMarketingDetailUpdateOneRequiredWithoutSocialPlatformsNestedInput = {
    create?: XOR<DigitalMarketingDetailCreateWithoutSocialPlatformsInput, DigitalMarketingDetailUncheckedCreateWithoutSocialPlatformsInput>
    connectOrCreate?: DigitalMarketingDetailCreateOrConnectWithoutSocialPlatformsInput
    upsert?: DigitalMarketingDetailUpsertWithoutSocialPlatformsInput
    connect?: DigitalMarketingDetailWhereUniqueInput
    update?: XOR<XOR<DigitalMarketingDetailUpdateToOneWithWhereWithoutSocialPlatformsInput, DigitalMarketingDetailUpdateWithoutSocialPlatformsInput>, DigitalMarketingDetailUncheckedUpdateWithoutSocialPlatformsInput>
  }

  export type ProjectCreateNestedOneWithoutContentGenerationDetailsInput = {
    create?: XOR<ProjectCreateWithoutContentGenerationDetailsInput, ProjectUncheckedCreateWithoutContentGenerationDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutContentGenerationDetailsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ContentTypeCreateNestedManyWithoutContentGenerationDetailInput = {
    create?: XOR<ContentTypeCreateWithoutContentGenerationDetailInput, ContentTypeUncheckedCreateWithoutContentGenerationDetailInput> | ContentTypeCreateWithoutContentGenerationDetailInput[] | ContentTypeUncheckedCreateWithoutContentGenerationDetailInput[]
    connectOrCreate?: ContentTypeCreateOrConnectWithoutContentGenerationDetailInput | ContentTypeCreateOrConnectWithoutContentGenerationDetailInput[]
    createMany?: ContentTypeCreateManyContentGenerationDetailInputEnvelope
    connect?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
  }

  export type ContentLanguageCreateNestedManyWithoutContentGenerationDetailInput = {
    create?: XOR<ContentLanguageCreateWithoutContentGenerationDetailInput, ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput> | ContentLanguageCreateWithoutContentGenerationDetailInput[] | ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput[]
    connectOrCreate?: ContentLanguageCreateOrConnectWithoutContentGenerationDetailInput | ContentLanguageCreateOrConnectWithoutContentGenerationDetailInput[]
    createMany?: ContentLanguageCreateManyContentGenerationDetailInputEnvelope
    connect?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
  }

  export type ContentTypeUncheckedCreateNestedManyWithoutContentGenerationDetailInput = {
    create?: XOR<ContentTypeCreateWithoutContentGenerationDetailInput, ContentTypeUncheckedCreateWithoutContentGenerationDetailInput> | ContentTypeCreateWithoutContentGenerationDetailInput[] | ContentTypeUncheckedCreateWithoutContentGenerationDetailInput[]
    connectOrCreate?: ContentTypeCreateOrConnectWithoutContentGenerationDetailInput | ContentTypeCreateOrConnectWithoutContentGenerationDetailInput[]
    createMany?: ContentTypeCreateManyContentGenerationDetailInputEnvelope
    connect?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
  }

  export type ContentLanguageUncheckedCreateNestedManyWithoutContentGenerationDetailInput = {
    create?: XOR<ContentLanguageCreateWithoutContentGenerationDetailInput, ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput> | ContentLanguageCreateWithoutContentGenerationDetailInput[] | ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput[]
    connectOrCreate?: ContentLanguageCreateOrConnectWithoutContentGenerationDetailInput | ContentLanguageCreateOrConnectWithoutContentGenerationDetailInput[]
    createMany?: ContentLanguageCreateManyContentGenerationDetailInputEnvelope
    connect?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutContentGenerationDetailsNestedInput = {
    create?: XOR<ProjectCreateWithoutContentGenerationDetailsInput, ProjectUncheckedCreateWithoutContentGenerationDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutContentGenerationDetailsInput
    upsert?: ProjectUpsertWithoutContentGenerationDetailsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutContentGenerationDetailsInput, ProjectUpdateWithoutContentGenerationDetailsInput>, ProjectUncheckedUpdateWithoutContentGenerationDetailsInput>
  }

  export type ContentTypeUpdateManyWithoutContentGenerationDetailNestedInput = {
    create?: XOR<ContentTypeCreateWithoutContentGenerationDetailInput, ContentTypeUncheckedCreateWithoutContentGenerationDetailInput> | ContentTypeCreateWithoutContentGenerationDetailInput[] | ContentTypeUncheckedCreateWithoutContentGenerationDetailInput[]
    connectOrCreate?: ContentTypeCreateOrConnectWithoutContentGenerationDetailInput | ContentTypeCreateOrConnectWithoutContentGenerationDetailInput[]
    upsert?: ContentTypeUpsertWithWhereUniqueWithoutContentGenerationDetailInput | ContentTypeUpsertWithWhereUniqueWithoutContentGenerationDetailInput[]
    createMany?: ContentTypeCreateManyContentGenerationDetailInputEnvelope
    set?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
    disconnect?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
    delete?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
    connect?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
    update?: ContentTypeUpdateWithWhereUniqueWithoutContentGenerationDetailInput | ContentTypeUpdateWithWhereUniqueWithoutContentGenerationDetailInput[]
    updateMany?: ContentTypeUpdateManyWithWhereWithoutContentGenerationDetailInput | ContentTypeUpdateManyWithWhereWithoutContentGenerationDetailInput[]
    deleteMany?: ContentTypeScalarWhereInput | ContentTypeScalarWhereInput[]
  }

  export type ContentLanguageUpdateManyWithoutContentGenerationDetailNestedInput = {
    create?: XOR<ContentLanguageCreateWithoutContentGenerationDetailInput, ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput> | ContentLanguageCreateWithoutContentGenerationDetailInput[] | ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput[]
    connectOrCreate?: ContentLanguageCreateOrConnectWithoutContentGenerationDetailInput | ContentLanguageCreateOrConnectWithoutContentGenerationDetailInput[]
    upsert?: ContentLanguageUpsertWithWhereUniqueWithoutContentGenerationDetailInput | ContentLanguageUpsertWithWhereUniqueWithoutContentGenerationDetailInput[]
    createMany?: ContentLanguageCreateManyContentGenerationDetailInputEnvelope
    set?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
    disconnect?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
    delete?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
    connect?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
    update?: ContentLanguageUpdateWithWhereUniqueWithoutContentGenerationDetailInput | ContentLanguageUpdateWithWhereUniqueWithoutContentGenerationDetailInput[]
    updateMany?: ContentLanguageUpdateManyWithWhereWithoutContentGenerationDetailInput | ContentLanguageUpdateManyWithWhereWithoutContentGenerationDetailInput[]
    deleteMany?: ContentLanguageScalarWhereInput | ContentLanguageScalarWhereInput[]
  }

  export type ContentTypeUncheckedUpdateManyWithoutContentGenerationDetailNestedInput = {
    create?: XOR<ContentTypeCreateWithoutContentGenerationDetailInput, ContentTypeUncheckedCreateWithoutContentGenerationDetailInput> | ContentTypeCreateWithoutContentGenerationDetailInput[] | ContentTypeUncheckedCreateWithoutContentGenerationDetailInput[]
    connectOrCreate?: ContentTypeCreateOrConnectWithoutContentGenerationDetailInput | ContentTypeCreateOrConnectWithoutContentGenerationDetailInput[]
    upsert?: ContentTypeUpsertWithWhereUniqueWithoutContentGenerationDetailInput | ContentTypeUpsertWithWhereUniqueWithoutContentGenerationDetailInput[]
    createMany?: ContentTypeCreateManyContentGenerationDetailInputEnvelope
    set?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
    disconnect?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
    delete?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
    connect?: ContentTypeWhereUniqueInput | ContentTypeWhereUniqueInput[]
    update?: ContentTypeUpdateWithWhereUniqueWithoutContentGenerationDetailInput | ContentTypeUpdateWithWhereUniqueWithoutContentGenerationDetailInput[]
    updateMany?: ContentTypeUpdateManyWithWhereWithoutContentGenerationDetailInput | ContentTypeUpdateManyWithWhereWithoutContentGenerationDetailInput[]
    deleteMany?: ContentTypeScalarWhereInput | ContentTypeScalarWhereInput[]
  }

  export type ContentLanguageUncheckedUpdateManyWithoutContentGenerationDetailNestedInput = {
    create?: XOR<ContentLanguageCreateWithoutContentGenerationDetailInput, ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput> | ContentLanguageCreateWithoutContentGenerationDetailInput[] | ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput[]
    connectOrCreate?: ContentLanguageCreateOrConnectWithoutContentGenerationDetailInput | ContentLanguageCreateOrConnectWithoutContentGenerationDetailInput[]
    upsert?: ContentLanguageUpsertWithWhereUniqueWithoutContentGenerationDetailInput | ContentLanguageUpsertWithWhereUniqueWithoutContentGenerationDetailInput[]
    createMany?: ContentLanguageCreateManyContentGenerationDetailInputEnvelope
    set?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
    disconnect?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
    delete?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
    connect?: ContentLanguageWhereUniqueInput | ContentLanguageWhereUniqueInput[]
    update?: ContentLanguageUpdateWithWhereUniqueWithoutContentGenerationDetailInput | ContentLanguageUpdateWithWhereUniqueWithoutContentGenerationDetailInput[]
    updateMany?: ContentLanguageUpdateManyWithWhereWithoutContentGenerationDetailInput | ContentLanguageUpdateManyWithWhereWithoutContentGenerationDetailInput[]
    deleteMany?: ContentLanguageScalarWhereInput | ContentLanguageScalarWhereInput[]
  }

  export type ContentGenerationDetailCreateNestedOneWithoutContentTypesInput = {
    create?: XOR<ContentGenerationDetailCreateWithoutContentTypesInput, ContentGenerationDetailUncheckedCreateWithoutContentTypesInput>
    connectOrCreate?: ContentGenerationDetailCreateOrConnectWithoutContentTypesInput
    connect?: ContentGenerationDetailWhereUniqueInput
  }

  export type ContentGenerationDetailUpdateOneRequiredWithoutContentTypesNestedInput = {
    create?: XOR<ContentGenerationDetailCreateWithoutContentTypesInput, ContentGenerationDetailUncheckedCreateWithoutContentTypesInput>
    connectOrCreate?: ContentGenerationDetailCreateOrConnectWithoutContentTypesInput
    upsert?: ContentGenerationDetailUpsertWithoutContentTypesInput
    connect?: ContentGenerationDetailWhereUniqueInput
    update?: XOR<XOR<ContentGenerationDetailUpdateToOneWithWhereWithoutContentTypesInput, ContentGenerationDetailUpdateWithoutContentTypesInput>, ContentGenerationDetailUncheckedUpdateWithoutContentTypesInput>
  }

  export type ContentGenerationDetailCreateNestedOneWithoutContentLanguagesInput = {
    create?: XOR<ContentGenerationDetailCreateWithoutContentLanguagesInput, ContentGenerationDetailUncheckedCreateWithoutContentLanguagesInput>
    connectOrCreate?: ContentGenerationDetailCreateOrConnectWithoutContentLanguagesInput
    connect?: ContentGenerationDetailWhereUniqueInput
  }

  export type ContentGenerationDetailUpdateOneRequiredWithoutContentLanguagesNestedInput = {
    create?: XOR<ContentGenerationDetailCreateWithoutContentLanguagesInput, ContentGenerationDetailUncheckedCreateWithoutContentLanguagesInput>
    connectOrCreate?: ContentGenerationDetailCreateOrConnectWithoutContentLanguagesInput
    upsert?: ContentGenerationDetailUpsertWithoutContentLanguagesInput
    connect?: ContentGenerationDetailWhereUniqueInput
    update?: XOR<XOR<ContentGenerationDetailUpdateToOneWithWhereWithoutContentLanguagesInput, ContentGenerationDetailUpdateWithoutContentLanguagesInput>, ContentGenerationDetailUncheckedUpdateWithoutContentLanguagesInput>
  }

  export type ProjectCreateNestedOneWithoutAppDevelopmentDetailsInput = {
    create?: XOR<ProjectCreateWithoutAppDevelopmentDetailsInput, ProjectUncheckedCreateWithoutAppDevelopmentDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAppDevelopmentDetailsInput
    connect?: ProjectWhereUniqueInput
  }

  export type AppFeatureCreateNestedManyWithoutAppDevelopmentDetailInput = {
    create?: XOR<AppFeatureCreateWithoutAppDevelopmentDetailInput, AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput> | AppFeatureCreateWithoutAppDevelopmentDetailInput[] | AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput[]
    connectOrCreate?: AppFeatureCreateOrConnectWithoutAppDevelopmentDetailInput | AppFeatureCreateOrConnectWithoutAppDevelopmentDetailInput[]
    createMany?: AppFeatureCreateManyAppDevelopmentDetailInputEnvelope
    connect?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
  }

  export type AppFeatureUncheckedCreateNestedManyWithoutAppDevelopmentDetailInput = {
    create?: XOR<AppFeatureCreateWithoutAppDevelopmentDetailInput, AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput> | AppFeatureCreateWithoutAppDevelopmentDetailInput[] | AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput[]
    connectOrCreate?: AppFeatureCreateOrConnectWithoutAppDevelopmentDetailInput | AppFeatureCreateOrConnectWithoutAppDevelopmentDetailInput[]
    createMany?: AppFeatureCreateManyAppDevelopmentDetailInputEnvelope
    connect?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutAppDevelopmentDetailsNestedInput = {
    create?: XOR<ProjectCreateWithoutAppDevelopmentDetailsInput, ProjectUncheckedCreateWithoutAppDevelopmentDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAppDevelopmentDetailsInput
    upsert?: ProjectUpsertWithoutAppDevelopmentDetailsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAppDevelopmentDetailsInput, ProjectUpdateWithoutAppDevelopmentDetailsInput>, ProjectUncheckedUpdateWithoutAppDevelopmentDetailsInput>
  }

  export type AppFeatureUpdateManyWithoutAppDevelopmentDetailNestedInput = {
    create?: XOR<AppFeatureCreateWithoutAppDevelopmentDetailInput, AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput> | AppFeatureCreateWithoutAppDevelopmentDetailInput[] | AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput[]
    connectOrCreate?: AppFeatureCreateOrConnectWithoutAppDevelopmentDetailInput | AppFeatureCreateOrConnectWithoutAppDevelopmentDetailInput[]
    upsert?: AppFeatureUpsertWithWhereUniqueWithoutAppDevelopmentDetailInput | AppFeatureUpsertWithWhereUniqueWithoutAppDevelopmentDetailInput[]
    createMany?: AppFeatureCreateManyAppDevelopmentDetailInputEnvelope
    set?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
    disconnect?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
    delete?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
    connect?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
    update?: AppFeatureUpdateWithWhereUniqueWithoutAppDevelopmentDetailInput | AppFeatureUpdateWithWhereUniqueWithoutAppDevelopmentDetailInput[]
    updateMany?: AppFeatureUpdateManyWithWhereWithoutAppDevelopmentDetailInput | AppFeatureUpdateManyWithWhereWithoutAppDevelopmentDetailInput[]
    deleteMany?: AppFeatureScalarWhereInput | AppFeatureScalarWhereInput[]
  }

  export type AppFeatureUncheckedUpdateManyWithoutAppDevelopmentDetailNestedInput = {
    create?: XOR<AppFeatureCreateWithoutAppDevelopmentDetailInput, AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput> | AppFeatureCreateWithoutAppDevelopmentDetailInput[] | AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput[]
    connectOrCreate?: AppFeatureCreateOrConnectWithoutAppDevelopmentDetailInput | AppFeatureCreateOrConnectWithoutAppDevelopmentDetailInput[]
    upsert?: AppFeatureUpsertWithWhereUniqueWithoutAppDevelopmentDetailInput | AppFeatureUpsertWithWhereUniqueWithoutAppDevelopmentDetailInput[]
    createMany?: AppFeatureCreateManyAppDevelopmentDetailInputEnvelope
    set?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
    disconnect?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
    delete?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
    connect?: AppFeatureWhereUniqueInput | AppFeatureWhereUniqueInput[]
    update?: AppFeatureUpdateWithWhereUniqueWithoutAppDevelopmentDetailInput | AppFeatureUpdateWithWhereUniqueWithoutAppDevelopmentDetailInput[]
    updateMany?: AppFeatureUpdateManyWithWhereWithoutAppDevelopmentDetailInput | AppFeatureUpdateManyWithWhereWithoutAppDevelopmentDetailInput[]
    deleteMany?: AppFeatureScalarWhereInput | AppFeatureScalarWhereInput[]
  }

  export type AppDevelopmentDetailCreateNestedOneWithoutAppFeaturesInput = {
    create?: XOR<AppDevelopmentDetailCreateWithoutAppFeaturesInput, AppDevelopmentDetailUncheckedCreateWithoutAppFeaturesInput>
    connectOrCreate?: AppDevelopmentDetailCreateOrConnectWithoutAppFeaturesInput
    connect?: AppDevelopmentDetailWhereUniqueInput
  }

  export type AppDevelopmentDetailUpdateOneRequiredWithoutAppFeaturesNestedInput = {
    create?: XOR<AppDevelopmentDetailCreateWithoutAppFeaturesInput, AppDevelopmentDetailUncheckedCreateWithoutAppFeaturesInput>
    connectOrCreate?: AppDevelopmentDetailCreateOrConnectWithoutAppFeaturesInput
    upsert?: AppDevelopmentDetailUpsertWithoutAppFeaturesInput
    connect?: AppDevelopmentDetailWhereUniqueInput
    update?: XOR<XOR<AppDevelopmentDetailUpdateToOneWithWhereWithoutAppFeaturesInput, AppDevelopmentDetailUpdateWithoutAppFeaturesInput>, AppDevelopmentDetailUncheckedUpdateWithoutAppFeaturesInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProjectCreateWithoutUserInput = {
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webDevelopmentDetails?: WebDevelopmentDetailCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUserInput = {
    id?: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailUncheckedCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectCreateManyUserInputEnvelope = {
    data: ProjectCreateManyUserInput | ProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactFormCreateWithoutUserInput = {
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFormUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFormCreateOrConnectWithoutUserInput = {
    where: ContactFormWhereUniqueInput
    create: XOR<ContactFormCreateWithoutUserInput, ContactFormUncheckedCreateWithoutUserInput>
  }

  export type ContactFormCreateManyUserInputEnvelope = {
    data: ContactFormCreateManyUserInput | ContactFormCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectCreateWithoutUserInput, ProjectUncheckedCreateWithoutUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutUserInput, ProjectUncheckedUpdateWithoutUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: IntFilter<"Project"> | number
    username?: StringFilter<"Project"> | string
    email?: StringFilter<"Project"> | string
    password?: StringFilter<"Project"> | string
    projectName?: StringFilter<"Project"> | string
    projectTitle?: StringFilter<"Project"> | string
    category?: StringFilter<"Project"> | string
    price?: FloatFilter<"Project"> | number
    deadline?: StringNullableFilter<"Project"> | string | null
    details?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    userId?: IntNullableFilter<"Project"> | number | null
  }

  export type ContactFormUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactFormWhereUniqueInput
    update: XOR<ContactFormUpdateWithoutUserInput, ContactFormUncheckedUpdateWithoutUserInput>
    create: XOR<ContactFormCreateWithoutUserInput, ContactFormUncheckedCreateWithoutUserInput>
  }

  export type ContactFormUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactFormWhereUniqueInput
    data: XOR<ContactFormUpdateWithoutUserInput, ContactFormUncheckedUpdateWithoutUserInput>
  }

  export type ContactFormUpdateManyWithWhereWithoutUserInput = {
    where: ContactFormScalarWhereInput
    data: XOR<ContactFormUpdateManyMutationInput, ContactFormUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactFormScalarWhereInput = {
    AND?: ContactFormScalarWhereInput | ContactFormScalarWhereInput[]
    OR?: ContactFormScalarWhereInput[]
    NOT?: ContactFormScalarWhereInput | ContactFormScalarWhereInput[]
    id?: IntFilter<"ContactForm"> | number
    name?: StringFilter<"ContactForm"> | string
    email?: StringFilter<"ContactForm"> | string
    subject?: StringFilter<"ContactForm"> | string
    message?: StringFilter<"ContactForm"> | string
    createdAt?: DateTimeFilter<"ContactForm"> | Date | string
    updatedAt?: DateTimeFilter<"ContactForm"> | Date | string
    userId?: IntNullableFilter<"ContactForm"> | number | null
  }

  export type UserCreateWithoutContactFormsInput = {
    email: string
    password: string
    full_name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactFormsInput = {
    id?: number
    email: string
    password: string
    full_name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactFormsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactFormsInput, UserUncheckedCreateWithoutContactFormsInput>
  }

  export type UserUpsertWithoutContactFormsInput = {
    update: XOR<UserUpdateWithoutContactFormsInput, UserUncheckedUpdateWithoutContactFormsInput>
    create: XOR<UserCreateWithoutContactFormsInput, UserUncheckedCreateWithoutContactFormsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactFormsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactFormsInput, UserUncheckedUpdateWithoutContactFormsInput>
  }

  export type UserUpdateWithoutContactFormsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProjectsInput = {
    email: string
    password: string
    full_name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactForms?: ContactFormCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: number
    email: string
    password: string
    full_name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactForms?: ContactFormUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type WebDevelopmentDetailCreateWithoutProjectInput = {
    tech: string
    webPages?: number | null
    webFeatures?: WebDevelopmentFeatureCreateNestedManyWithoutWebDevDetailInput
  }

  export type WebDevelopmentDetailUncheckedCreateWithoutProjectInput = {
    id?: number
    tech: string
    webPages?: number | null
    webFeatures?: WebDevelopmentFeatureUncheckedCreateNestedManyWithoutWebDevDetailInput
  }

  export type WebDevelopmentDetailCreateOrConnectWithoutProjectInput = {
    where: WebDevelopmentDetailWhereUniqueInput
    create: XOR<WebDevelopmentDetailCreateWithoutProjectInput, WebDevelopmentDetailUncheckedCreateWithoutProjectInput>
  }

  export type SeoDetailCreateWithoutProjectInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    seoTypes?: SeoTypeCreateNestedManyWithoutSeoDetailInput
  }

  export type SeoDetailUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seoTypes?: SeoTypeUncheckedCreateNestedManyWithoutSeoDetailInput
  }

  export type SeoDetailCreateOrConnectWithoutProjectInput = {
    where: SeoDetailWhereUniqueInput
    create: XOR<SeoDetailCreateWithoutProjectInput, SeoDetailUncheckedCreateWithoutProjectInput>
  }

  export type DigitalMarketingDetailCreateWithoutProjectInput = {
    targetAudience?: string | null
    marketingBudget?: number | null
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    marketingServices?: DigitalMarketingServiceCreateNestedManyWithoutDigitalMarketingDetailInput
    socialPlatforms?: SocialPlatformCreateNestedManyWithoutDigitalMarketingDetailInput
  }

  export type DigitalMarketingDetailUncheckedCreateWithoutProjectInput = {
    id?: number
    targetAudience?: string | null
    marketingBudget?: number | null
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    marketingServices?: DigitalMarketingServiceUncheckedCreateNestedManyWithoutDigitalMarketingDetailInput
    socialPlatforms?: SocialPlatformUncheckedCreateNestedManyWithoutDigitalMarketingDetailInput
  }

  export type DigitalMarketingDetailCreateOrConnectWithoutProjectInput = {
    where: DigitalMarketingDetailWhereUniqueInput
    create: XOR<DigitalMarketingDetailCreateWithoutProjectInput, DigitalMarketingDetailUncheckedCreateWithoutProjectInput>
  }

  export type ContentGenerationDetailCreateWithoutProjectInput = {
    volume?: string | null
    contentTone?: string | null
    targetKeywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentTypes?: ContentTypeCreateNestedManyWithoutContentGenerationDetailInput
    contentLanguages?: ContentLanguageCreateNestedManyWithoutContentGenerationDetailInput
  }

  export type ContentGenerationDetailUncheckedCreateWithoutProjectInput = {
    id?: number
    volume?: string | null
    contentTone?: string | null
    targetKeywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentTypes?: ContentTypeUncheckedCreateNestedManyWithoutContentGenerationDetailInput
    contentLanguages?: ContentLanguageUncheckedCreateNestedManyWithoutContentGenerationDetailInput
  }

  export type ContentGenerationDetailCreateOrConnectWithoutProjectInput = {
    where: ContentGenerationDetailWhereUniqueInput
    create: XOR<ContentGenerationDetailCreateWithoutProjectInput, ContentGenerationDetailUncheckedCreateWithoutProjectInput>
  }

  export type AppDevelopmentDetailCreateWithoutProjectInput = {
    appType?: string | null
    complexity?: string | null
    targetPlatforms?: string | null
    expectedUsers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appFeatures?: AppFeatureCreateNestedManyWithoutAppDevelopmentDetailInput
  }

  export type AppDevelopmentDetailUncheckedCreateWithoutProjectInput = {
    id?: number
    appType?: string | null
    complexity?: string | null
    targetPlatforms?: string | null
    expectedUsers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appFeatures?: AppFeatureUncheckedCreateNestedManyWithoutAppDevelopmentDetailInput
  }

  export type AppDevelopmentDetailCreateOrConnectWithoutProjectInput = {
    where: AppDevelopmentDetailWhereUniqueInput
    create: XOR<AppDevelopmentDetailCreateWithoutProjectInput, AppDevelopmentDetailUncheckedCreateWithoutProjectInput>
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactForms?: ContactFormUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactForms?: ContactFormUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WebDevelopmentDetailUpsertWithoutProjectInput = {
    update: XOR<WebDevelopmentDetailUpdateWithoutProjectInput, WebDevelopmentDetailUncheckedUpdateWithoutProjectInput>
    create: XOR<WebDevelopmentDetailCreateWithoutProjectInput, WebDevelopmentDetailUncheckedCreateWithoutProjectInput>
    where?: WebDevelopmentDetailWhereInput
  }

  export type WebDevelopmentDetailUpdateToOneWithWhereWithoutProjectInput = {
    where?: WebDevelopmentDetailWhereInput
    data: XOR<WebDevelopmentDetailUpdateWithoutProjectInput, WebDevelopmentDetailUncheckedUpdateWithoutProjectInput>
  }

  export type WebDevelopmentDetailUpdateWithoutProjectInput = {
    tech?: StringFieldUpdateOperationsInput | string
    webPages?: NullableIntFieldUpdateOperationsInput | number | null
    webFeatures?: WebDevelopmentFeatureUpdateManyWithoutWebDevDetailNestedInput
  }

  export type WebDevelopmentDetailUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    tech?: StringFieldUpdateOperationsInput | string
    webPages?: NullableIntFieldUpdateOperationsInput | number | null
    webFeatures?: WebDevelopmentFeatureUncheckedUpdateManyWithoutWebDevDetailNestedInput
  }

  export type SeoDetailUpsertWithoutProjectInput = {
    update: XOR<SeoDetailUpdateWithoutProjectInput, SeoDetailUncheckedUpdateWithoutProjectInput>
    create: XOR<SeoDetailCreateWithoutProjectInput, SeoDetailUncheckedCreateWithoutProjectInput>
    where?: SeoDetailWhereInput
  }

  export type SeoDetailUpdateToOneWithWhereWithoutProjectInput = {
    where?: SeoDetailWhereInput
    data: XOR<SeoDetailUpdateWithoutProjectInput, SeoDetailUncheckedUpdateWithoutProjectInput>
  }

  export type SeoDetailUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoTypes?: SeoTypeUpdateManyWithoutSeoDetailNestedInput
  }

  export type SeoDetailUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seoTypes?: SeoTypeUncheckedUpdateManyWithoutSeoDetailNestedInput
  }

  export type DigitalMarketingDetailUpsertWithoutProjectInput = {
    update: XOR<DigitalMarketingDetailUpdateWithoutProjectInput, DigitalMarketingDetailUncheckedUpdateWithoutProjectInput>
    create: XOR<DigitalMarketingDetailCreateWithoutProjectInput, DigitalMarketingDetailUncheckedCreateWithoutProjectInput>
    where?: DigitalMarketingDetailWhereInput
  }

  export type DigitalMarketingDetailUpdateToOneWithWhereWithoutProjectInput = {
    where?: DigitalMarketingDetailWhereInput
    data: XOR<DigitalMarketingDetailUpdateWithoutProjectInput, DigitalMarketingDetailUncheckedUpdateWithoutProjectInput>
  }

  export type DigitalMarketingDetailUpdateWithoutProjectInput = {
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketingServices?: DigitalMarketingServiceUpdateManyWithoutDigitalMarketingDetailNestedInput
    socialPlatforms?: SocialPlatformUpdateManyWithoutDigitalMarketingDetailNestedInput
  }

  export type DigitalMarketingDetailUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketingServices?: DigitalMarketingServiceUncheckedUpdateManyWithoutDigitalMarketingDetailNestedInput
    socialPlatforms?: SocialPlatformUncheckedUpdateManyWithoutDigitalMarketingDetailNestedInput
  }

  export type ContentGenerationDetailUpsertWithoutProjectInput = {
    update: XOR<ContentGenerationDetailUpdateWithoutProjectInput, ContentGenerationDetailUncheckedUpdateWithoutProjectInput>
    create: XOR<ContentGenerationDetailCreateWithoutProjectInput, ContentGenerationDetailUncheckedCreateWithoutProjectInput>
    where?: ContentGenerationDetailWhereInput
  }

  export type ContentGenerationDetailUpdateToOneWithWhereWithoutProjectInput = {
    where?: ContentGenerationDetailWhereInput
    data: XOR<ContentGenerationDetailUpdateWithoutProjectInput, ContentGenerationDetailUncheckedUpdateWithoutProjectInput>
  }

  export type ContentGenerationDetailUpdateWithoutProjectInput = {
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentTypes?: ContentTypeUpdateManyWithoutContentGenerationDetailNestedInput
    contentLanguages?: ContentLanguageUpdateManyWithoutContentGenerationDetailNestedInput
  }

  export type ContentGenerationDetailUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentTypes?: ContentTypeUncheckedUpdateManyWithoutContentGenerationDetailNestedInput
    contentLanguages?: ContentLanguageUncheckedUpdateManyWithoutContentGenerationDetailNestedInput
  }

  export type AppDevelopmentDetailUpsertWithoutProjectInput = {
    update: XOR<AppDevelopmentDetailUpdateWithoutProjectInput, AppDevelopmentDetailUncheckedUpdateWithoutProjectInput>
    create: XOR<AppDevelopmentDetailCreateWithoutProjectInput, AppDevelopmentDetailUncheckedCreateWithoutProjectInput>
    where?: AppDevelopmentDetailWhereInput
  }

  export type AppDevelopmentDetailUpdateToOneWithWhereWithoutProjectInput = {
    where?: AppDevelopmentDetailWhereInput
    data: XOR<AppDevelopmentDetailUpdateWithoutProjectInput, AppDevelopmentDetailUncheckedUpdateWithoutProjectInput>
  }

  export type AppDevelopmentDetailUpdateWithoutProjectInput = {
    appType?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: NullableStringFieldUpdateOperationsInput | string | null
    targetPlatforms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appFeatures?: AppFeatureUpdateManyWithoutAppDevelopmentDetailNestedInput
  }

  export type AppDevelopmentDetailUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    appType?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: NullableStringFieldUpdateOperationsInput | string | null
    targetPlatforms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appFeatures?: AppFeatureUncheckedUpdateManyWithoutAppDevelopmentDetailNestedInput
  }

  export type ProjectCreateWithoutWebDevelopmentDetailsInput = {
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProjectsInput
    seoDetails?: SeoDetailCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWebDevelopmentDetailsInput = {
    id?: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
    seoDetails?: SeoDetailUncheckedCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWebDevelopmentDetailsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWebDevelopmentDetailsInput, ProjectUncheckedCreateWithoutWebDevelopmentDetailsInput>
  }

  export type WebDevelopmentFeatureCreateWithoutWebDevDetailInput = {
    feature: string
    price: number
  }

  export type WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput = {
    id?: number
    feature: string
    price: number
  }

  export type WebDevelopmentFeatureCreateOrConnectWithoutWebDevDetailInput = {
    where: WebDevelopmentFeatureWhereUniqueInput
    create: XOR<WebDevelopmentFeatureCreateWithoutWebDevDetailInput, WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput>
  }

  export type WebDevelopmentFeatureCreateManyWebDevDetailInputEnvelope = {
    data: WebDevelopmentFeatureCreateManyWebDevDetailInput | WebDevelopmentFeatureCreateManyWebDevDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutWebDevelopmentDetailsInput = {
    update: XOR<ProjectUpdateWithoutWebDevelopmentDetailsInput, ProjectUncheckedUpdateWithoutWebDevelopmentDetailsInput>
    create: XOR<ProjectCreateWithoutWebDevelopmentDetailsInput, ProjectUncheckedCreateWithoutWebDevelopmentDetailsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWebDevelopmentDetailsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWebDevelopmentDetailsInput, ProjectUncheckedUpdateWithoutWebDevelopmentDetailsInput>
  }

  export type ProjectUpdateWithoutWebDevelopmentDetailsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProjectsNestedInput
    seoDetails?: SeoDetailUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWebDevelopmentDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    seoDetails?: SeoDetailUncheckedUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type WebDevelopmentFeatureUpsertWithWhereUniqueWithoutWebDevDetailInput = {
    where: WebDevelopmentFeatureWhereUniqueInput
    update: XOR<WebDevelopmentFeatureUpdateWithoutWebDevDetailInput, WebDevelopmentFeatureUncheckedUpdateWithoutWebDevDetailInput>
    create: XOR<WebDevelopmentFeatureCreateWithoutWebDevDetailInput, WebDevelopmentFeatureUncheckedCreateWithoutWebDevDetailInput>
  }

  export type WebDevelopmentFeatureUpdateWithWhereUniqueWithoutWebDevDetailInput = {
    where: WebDevelopmentFeatureWhereUniqueInput
    data: XOR<WebDevelopmentFeatureUpdateWithoutWebDevDetailInput, WebDevelopmentFeatureUncheckedUpdateWithoutWebDevDetailInput>
  }

  export type WebDevelopmentFeatureUpdateManyWithWhereWithoutWebDevDetailInput = {
    where: WebDevelopmentFeatureScalarWhereInput
    data: XOR<WebDevelopmentFeatureUpdateManyMutationInput, WebDevelopmentFeatureUncheckedUpdateManyWithoutWebDevDetailInput>
  }

  export type WebDevelopmentFeatureScalarWhereInput = {
    AND?: WebDevelopmentFeatureScalarWhereInput | WebDevelopmentFeatureScalarWhereInput[]
    OR?: WebDevelopmentFeatureScalarWhereInput[]
    NOT?: WebDevelopmentFeatureScalarWhereInput | WebDevelopmentFeatureScalarWhereInput[]
    id?: IntFilter<"WebDevelopmentFeature"> | number
    feature?: StringFilter<"WebDevelopmentFeature"> | string
    price?: FloatFilter<"WebDevelopmentFeature"> | number
    webDevDetailId?: IntFilter<"WebDevelopmentFeature"> | number
  }

  export type WebDevelopmentDetailCreateWithoutWebFeaturesInput = {
    tech: string
    webPages?: number | null
    project: ProjectCreateNestedOneWithoutWebDevelopmentDetailsInput
  }

  export type WebDevelopmentDetailUncheckedCreateWithoutWebFeaturesInput = {
    id?: number
    tech: string
    webPages?: number | null
    projectId: number
  }

  export type WebDevelopmentDetailCreateOrConnectWithoutWebFeaturesInput = {
    where: WebDevelopmentDetailWhereUniqueInput
    create: XOR<WebDevelopmentDetailCreateWithoutWebFeaturesInput, WebDevelopmentDetailUncheckedCreateWithoutWebFeaturesInput>
  }

  export type WebDevelopmentDetailUpsertWithoutWebFeaturesInput = {
    update: XOR<WebDevelopmentDetailUpdateWithoutWebFeaturesInput, WebDevelopmentDetailUncheckedUpdateWithoutWebFeaturesInput>
    create: XOR<WebDevelopmentDetailCreateWithoutWebFeaturesInput, WebDevelopmentDetailUncheckedCreateWithoutWebFeaturesInput>
    where?: WebDevelopmentDetailWhereInput
  }

  export type WebDevelopmentDetailUpdateToOneWithWhereWithoutWebFeaturesInput = {
    where?: WebDevelopmentDetailWhereInput
    data: XOR<WebDevelopmentDetailUpdateWithoutWebFeaturesInput, WebDevelopmentDetailUncheckedUpdateWithoutWebFeaturesInput>
  }

  export type WebDevelopmentDetailUpdateWithoutWebFeaturesInput = {
    tech?: StringFieldUpdateOperationsInput | string
    webPages?: NullableIntFieldUpdateOperationsInput | number | null
    project?: ProjectUpdateOneRequiredWithoutWebDevelopmentDetailsNestedInput
  }

  export type WebDevelopmentDetailUncheckedUpdateWithoutWebFeaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tech?: StringFieldUpdateOperationsInput | string
    webPages?: NullableIntFieldUpdateOperationsInput | number | null
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateWithoutSeoDetailsInput = {
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProjectsInput
    webDevelopmentDetails?: WebDevelopmentDetailCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSeoDetailsInput = {
    id?: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSeoDetailsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSeoDetailsInput, ProjectUncheckedCreateWithoutSeoDetailsInput>
  }

  export type SeoTypeCreateWithoutSeoDetailInput = {
    seoType: string
    price: number
  }

  export type SeoTypeUncheckedCreateWithoutSeoDetailInput = {
    id?: number
    seoType: string
    price: number
  }

  export type SeoTypeCreateOrConnectWithoutSeoDetailInput = {
    where: SeoTypeWhereUniqueInput
    create: XOR<SeoTypeCreateWithoutSeoDetailInput, SeoTypeUncheckedCreateWithoutSeoDetailInput>
  }

  export type SeoTypeCreateManySeoDetailInputEnvelope = {
    data: SeoTypeCreateManySeoDetailInput | SeoTypeCreateManySeoDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSeoDetailsInput = {
    update: XOR<ProjectUpdateWithoutSeoDetailsInput, ProjectUncheckedUpdateWithoutSeoDetailsInput>
    create: XOR<ProjectCreateWithoutSeoDetailsInput, ProjectUncheckedCreateWithoutSeoDetailsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSeoDetailsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSeoDetailsInput, ProjectUncheckedUpdateWithoutSeoDetailsInput>
  }

  export type ProjectUpdateWithoutSeoDetailsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProjectsNestedInput
    webDevelopmentDetails?: WebDevelopmentDetailUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSeoDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type SeoTypeUpsertWithWhereUniqueWithoutSeoDetailInput = {
    where: SeoTypeWhereUniqueInput
    update: XOR<SeoTypeUpdateWithoutSeoDetailInput, SeoTypeUncheckedUpdateWithoutSeoDetailInput>
    create: XOR<SeoTypeCreateWithoutSeoDetailInput, SeoTypeUncheckedCreateWithoutSeoDetailInput>
  }

  export type SeoTypeUpdateWithWhereUniqueWithoutSeoDetailInput = {
    where: SeoTypeWhereUniqueInput
    data: XOR<SeoTypeUpdateWithoutSeoDetailInput, SeoTypeUncheckedUpdateWithoutSeoDetailInput>
  }

  export type SeoTypeUpdateManyWithWhereWithoutSeoDetailInput = {
    where: SeoTypeScalarWhereInput
    data: XOR<SeoTypeUpdateManyMutationInput, SeoTypeUncheckedUpdateManyWithoutSeoDetailInput>
  }

  export type SeoTypeScalarWhereInput = {
    AND?: SeoTypeScalarWhereInput | SeoTypeScalarWhereInput[]
    OR?: SeoTypeScalarWhereInput[]
    NOT?: SeoTypeScalarWhereInput | SeoTypeScalarWhereInput[]
    id?: IntFilter<"SeoType"> | number
    seoType?: StringFilter<"SeoType"> | string
    price?: FloatFilter<"SeoType"> | number
    seoDetailId?: IntFilter<"SeoType"> | number
  }

  export type SeoDetailCreateWithoutSeoTypesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSeoDetailsInput
  }

  export type SeoDetailUncheckedCreateWithoutSeoTypesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type SeoDetailCreateOrConnectWithoutSeoTypesInput = {
    where: SeoDetailWhereUniqueInput
    create: XOR<SeoDetailCreateWithoutSeoTypesInput, SeoDetailUncheckedCreateWithoutSeoTypesInput>
  }

  export type SeoDetailUpsertWithoutSeoTypesInput = {
    update: XOR<SeoDetailUpdateWithoutSeoTypesInput, SeoDetailUncheckedUpdateWithoutSeoTypesInput>
    create: XOR<SeoDetailCreateWithoutSeoTypesInput, SeoDetailUncheckedCreateWithoutSeoTypesInput>
    where?: SeoDetailWhereInput
  }

  export type SeoDetailUpdateToOneWithWhereWithoutSeoTypesInput = {
    where?: SeoDetailWhereInput
    data: XOR<SeoDetailUpdateWithoutSeoTypesInput, SeoDetailUncheckedUpdateWithoutSeoTypesInput>
  }

  export type SeoDetailUpdateWithoutSeoTypesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSeoDetailsNestedInput
  }

  export type SeoDetailUncheckedUpdateWithoutSeoTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateWithoutDigitalMarketingDetailsInput = {
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProjectsInput
    webDevelopmentDetails?: WebDevelopmentDetailCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDigitalMarketingDetailsInput = {
    id?: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailUncheckedCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDigitalMarketingDetailsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDigitalMarketingDetailsInput, ProjectUncheckedCreateWithoutDigitalMarketingDetailsInput>
  }

  export type DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput = {
    service: string
    price: number
  }

  export type DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput = {
    id?: number
    service: string
    price: number
  }

  export type DigitalMarketingServiceCreateOrConnectWithoutDigitalMarketingDetailInput = {
    where: DigitalMarketingServiceWhereUniqueInput
    create: XOR<DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput, DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput>
  }

  export type DigitalMarketingServiceCreateManyDigitalMarketingDetailInputEnvelope = {
    data: DigitalMarketingServiceCreateManyDigitalMarketingDetailInput | DigitalMarketingServiceCreateManyDigitalMarketingDetailInput[]
    skipDuplicates?: boolean
  }

  export type SocialPlatformCreateWithoutDigitalMarketingDetailInput = {
    platform: string
    price: number
  }

  export type SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput = {
    id?: number
    platform: string
    price: number
  }

  export type SocialPlatformCreateOrConnectWithoutDigitalMarketingDetailInput = {
    where: SocialPlatformWhereUniqueInput
    create: XOR<SocialPlatformCreateWithoutDigitalMarketingDetailInput, SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput>
  }

  export type SocialPlatformCreateManyDigitalMarketingDetailInputEnvelope = {
    data: SocialPlatformCreateManyDigitalMarketingDetailInput | SocialPlatformCreateManyDigitalMarketingDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutDigitalMarketingDetailsInput = {
    update: XOR<ProjectUpdateWithoutDigitalMarketingDetailsInput, ProjectUncheckedUpdateWithoutDigitalMarketingDetailsInput>
    create: XOR<ProjectCreateWithoutDigitalMarketingDetailsInput, ProjectUncheckedCreateWithoutDigitalMarketingDetailsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDigitalMarketingDetailsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDigitalMarketingDetailsInput, ProjectUncheckedUpdateWithoutDigitalMarketingDetailsInput>
  }

  export type ProjectUpdateWithoutDigitalMarketingDetailsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProjectsNestedInput
    webDevelopmentDetails?: WebDevelopmentDetailUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDigitalMarketingDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUncheckedUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type DigitalMarketingServiceUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput = {
    where: DigitalMarketingServiceWhereUniqueInput
    update: XOR<DigitalMarketingServiceUpdateWithoutDigitalMarketingDetailInput, DigitalMarketingServiceUncheckedUpdateWithoutDigitalMarketingDetailInput>
    create: XOR<DigitalMarketingServiceCreateWithoutDigitalMarketingDetailInput, DigitalMarketingServiceUncheckedCreateWithoutDigitalMarketingDetailInput>
  }

  export type DigitalMarketingServiceUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput = {
    where: DigitalMarketingServiceWhereUniqueInput
    data: XOR<DigitalMarketingServiceUpdateWithoutDigitalMarketingDetailInput, DigitalMarketingServiceUncheckedUpdateWithoutDigitalMarketingDetailInput>
  }

  export type DigitalMarketingServiceUpdateManyWithWhereWithoutDigitalMarketingDetailInput = {
    where: DigitalMarketingServiceScalarWhereInput
    data: XOR<DigitalMarketingServiceUpdateManyMutationInput, DigitalMarketingServiceUncheckedUpdateManyWithoutDigitalMarketingDetailInput>
  }

  export type DigitalMarketingServiceScalarWhereInput = {
    AND?: DigitalMarketingServiceScalarWhereInput | DigitalMarketingServiceScalarWhereInput[]
    OR?: DigitalMarketingServiceScalarWhereInput[]
    NOT?: DigitalMarketingServiceScalarWhereInput | DigitalMarketingServiceScalarWhereInput[]
    id?: IntFilter<"DigitalMarketingService"> | number
    service?: StringFilter<"DigitalMarketingService"> | string
    price?: FloatFilter<"DigitalMarketingService"> | number
    digitalMarketingDetailId?: IntFilter<"DigitalMarketingService"> | number
  }

  export type SocialPlatformUpsertWithWhereUniqueWithoutDigitalMarketingDetailInput = {
    where: SocialPlatformWhereUniqueInput
    update: XOR<SocialPlatformUpdateWithoutDigitalMarketingDetailInput, SocialPlatformUncheckedUpdateWithoutDigitalMarketingDetailInput>
    create: XOR<SocialPlatformCreateWithoutDigitalMarketingDetailInput, SocialPlatformUncheckedCreateWithoutDigitalMarketingDetailInput>
  }

  export type SocialPlatformUpdateWithWhereUniqueWithoutDigitalMarketingDetailInput = {
    where: SocialPlatformWhereUniqueInput
    data: XOR<SocialPlatformUpdateWithoutDigitalMarketingDetailInput, SocialPlatformUncheckedUpdateWithoutDigitalMarketingDetailInput>
  }

  export type SocialPlatformUpdateManyWithWhereWithoutDigitalMarketingDetailInput = {
    where: SocialPlatformScalarWhereInput
    data: XOR<SocialPlatformUpdateManyMutationInput, SocialPlatformUncheckedUpdateManyWithoutDigitalMarketingDetailInput>
  }

  export type SocialPlatformScalarWhereInput = {
    AND?: SocialPlatformScalarWhereInput | SocialPlatformScalarWhereInput[]
    OR?: SocialPlatformScalarWhereInput[]
    NOT?: SocialPlatformScalarWhereInput | SocialPlatformScalarWhereInput[]
    id?: IntFilter<"SocialPlatform"> | number
    platform?: StringFilter<"SocialPlatform"> | string
    price?: FloatFilter<"SocialPlatform"> | number
    digitalMarketingDetailId?: IntFilter<"SocialPlatform"> | number
  }

  export type DigitalMarketingDetailCreateWithoutMarketingServicesInput = {
    targetAudience?: string | null
    marketingBudget?: number | null
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDigitalMarketingDetailsInput
    socialPlatforms?: SocialPlatformCreateNestedManyWithoutDigitalMarketingDetailInput
  }

  export type DigitalMarketingDetailUncheckedCreateWithoutMarketingServicesInput = {
    id?: number
    targetAudience?: string | null
    marketingBudget?: number | null
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    socialPlatforms?: SocialPlatformUncheckedCreateNestedManyWithoutDigitalMarketingDetailInput
  }

  export type DigitalMarketingDetailCreateOrConnectWithoutMarketingServicesInput = {
    where: DigitalMarketingDetailWhereUniqueInput
    create: XOR<DigitalMarketingDetailCreateWithoutMarketingServicesInput, DigitalMarketingDetailUncheckedCreateWithoutMarketingServicesInput>
  }

  export type DigitalMarketingDetailUpsertWithoutMarketingServicesInput = {
    update: XOR<DigitalMarketingDetailUpdateWithoutMarketingServicesInput, DigitalMarketingDetailUncheckedUpdateWithoutMarketingServicesInput>
    create: XOR<DigitalMarketingDetailCreateWithoutMarketingServicesInput, DigitalMarketingDetailUncheckedCreateWithoutMarketingServicesInput>
    where?: DigitalMarketingDetailWhereInput
  }

  export type DigitalMarketingDetailUpdateToOneWithWhereWithoutMarketingServicesInput = {
    where?: DigitalMarketingDetailWhereInput
    data: XOR<DigitalMarketingDetailUpdateWithoutMarketingServicesInput, DigitalMarketingDetailUncheckedUpdateWithoutMarketingServicesInput>
  }

  export type DigitalMarketingDetailUpdateWithoutMarketingServicesInput = {
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDigitalMarketingDetailsNestedInput
    socialPlatforms?: SocialPlatformUpdateManyWithoutDigitalMarketingDetailNestedInput
  }

  export type DigitalMarketingDetailUncheckedUpdateWithoutMarketingServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    socialPlatforms?: SocialPlatformUncheckedUpdateManyWithoutDigitalMarketingDetailNestedInput
  }

  export type DigitalMarketingDetailCreateWithoutSocialPlatformsInput = {
    targetAudience?: string | null
    marketingBudget?: number | null
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDigitalMarketingDetailsInput
    marketingServices?: DigitalMarketingServiceCreateNestedManyWithoutDigitalMarketingDetailInput
  }

  export type DigitalMarketingDetailUncheckedCreateWithoutSocialPlatformsInput = {
    id?: number
    targetAudience?: string | null
    marketingBudget?: number | null
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    marketingServices?: DigitalMarketingServiceUncheckedCreateNestedManyWithoutDigitalMarketingDetailInput
  }

  export type DigitalMarketingDetailCreateOrConnectWithoutSocialPlatformsInput = {
    where: DigitalMarketingDetailWhereUniqueInput
    create: XOR<DigitalMarketingDetailCreateWithoutSocialPlatformsInput, DigitalMarketingDetailUncheckedCreateWithoutSocialPlatformsInput>
  }

  export type DigitalMarketingDetailUpsertWithoutSocialPlatformsInput = {
    update: XOR<DigitalMarketingDetailUpdateWithoutSocialPlatformsInput, DigitalMarketingDetailUncheckedUpdateWithoutSocialPlatformsInput>
    create: XOR<DigitalMarketingDetailCreateWithoutSocialPlatformsInput, DigitalMarketingDetailUncheckedCreateWithoutSocialPlatformsInput>
    where?: DigitalMarketingDetailWhereInput
  }

  export type DigitalMarketingDetailUpdateToOneWithWhereWithoutSocialPlatformsInput = {
    where?: DigitalMarketingDetailWhereInput
    data: XOR<DigitalMarketingDetailUpdateWithoutSocialPlatformsInput, DigitalMarketingDetailUncheckedUpdateWithoutSocialPlatformsInput>
  }

  export type DigitalMarketingDetailUpdateWithoutSocialPlatformsInput = {
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDigitalMarketingDetailsNestedInput
    marketingServices?: DigitalMarketingServiceUpdateManyWithoutDigitalMarketingDetailNestedInput
  }

  export type DigitalMarketingDetailUncheckedUpdateWithoutSocialPlatformsInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    marketingBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    marketingServices?: DigitalMarketingServiceUncheckedUpdateManyWithoutDigitalMarketingDetailNestedInput
  }

  export type ProjectCreateWithoutContentGenerationDetailsInput = {
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProjectsInput
    webDevelopmentDetails?: WebDevelopmentDetailCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutContentGenerationDetailsInput = {
    id?: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailUncheckedCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedCreateNestedOneWithoutProjectInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutContentGenerationDetailsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutContentGenerationDetailsInput, ProjectUncheckedCreateWithoutContentGenerationDetailsInput>
  }

  export type ContentTypeCreateWithoutContentGenerationDetailInput = {
    contentType: string
    price: number
  }

  export type ContentTypeUncheckedCreateWithoutContentGenerationDetailInput = {
    id?: number
    contentType: string
    price: number
  }

  export type ContentTypeCreateOrConnectWithoutContentGenerationDetailInput = {
    where: ContentTypeWhereUniqueInput
    create: XOR<ContentTypeCreateWithoutContentGenerationDetailInput, ContentTypeUncheckedCreateWithoutContentGenerationDetailInput>
  }

  export type ContentTypeCreateManyContentGenerationDetailInputEnvelope = {
    data: ContentTypeCreateManyContentGenerationDetailInput | ContentTypeCreateManyContentGenerationDetailInput[]
    skipDuplicates?: boolean
  }

  export type ContentLanguageCreateWithoutContentGenerationDetailInput = {
    language: string
    price: number
  }

  export type ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput = {
    id?: number
    language: string
    price: number
  }

  export type ContentLanguageCreateOrConnectWithoutContentGenerationDetailInput = {
    where: ContentLanguageWhereUniqueInput
    create: XOR<ContentLanguageCreateWithoutContentGenerationDetailInput, ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput>
  }

  export type ContentLanguageCreateManyContentGenerationDetailInputEnvelope = {
    data: ContentLanguageCreateManyContentGenerationDetailInput | ContentLanguageCreateManyContentGenerationDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutContentGenerationDetailsInput = {
    update: XOR<ProjectUpdateWithoutContentGenerationDetailsInput, ProjectUncheckedUpdateWithoutContentGenerationDetailsInput>
    create: XOR<ProjectCreateWithoutContentGenerationDetailsInput, ProjectUncheckedCreateWithoutContentGenerationDetailsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutContentGenerationDetailsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutContentGenerationDetailsInput, ProjectUncheckedUpdateWithoutContentGenerationDetailsInput>
  }

  export type ProjectUpdateWithoutContentGenerationDetailsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProjectsNestedInput
    webDevelopmentDetails?: WebDevelopmentDetailUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutContentGenerationDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUncheckedUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ContentTypeUpsertWithWhereUniqueWithoutContentGenerationDetailInput = {
    where: ContentTypeWhereUniqueInput
    update: XOR<ContentTypeUpdateWithoutContentGenerationDetailInput, ContentTypeUncheckedUpdateWithoutContentGenerationDetailInput>
    create: XOR<ContentTypeCreateWithoutContentGenerationDetailInput, ContentTypeUncheckedCreateWithoutContentGenerationDetailInput>
  }

  export type ContentTypeUpdateWithWhereUniqueWithoutContentGenerationDetailInput = {
    where: ContentTypeWhereUniqueInput
    data: XOR<ContentTypeUpdateWithoutContentGenerationDetailInput, ContentTypeUncheckedUpdateWithoutContentGenerationDetailInput>
  }

  export type ContentTypeUpdateManyWithWhereWithoutContentGenerationDetailInput = {
    where: ContentTypeScalarWhereInput
    data: XOR<ContentTypeUpdateManyMutationInput, ContentTypeUncheckedUpdateManyWithoutContentGenerationDetailInput>
  }

  export type ContentTypeScalarWhereInput = {
    AND?: ContentTypeScalarWhereInput | ContentTypeScalarWhereInput[]
    OR?: ContentTypeScalarWhereInput[]
    NOT?: ContentTypeScalarWhereInput | ContentTypeScalarWhereInput[]
    id?: IntFilter<"ContentType"> | number
    contentType?: StringFilter<"ContentType"> | string
    price?: FloatFilter<"ContentType"> | number
    contentGenerationDetailId?: IntFilter<"ContentType"> | number
  }

  export type ContentLanguageUpsertWithWhereUniqueWithoutContentGenerationDetailInput = {
    where: ContentLanguageWhereUniqueInput
    update: XOR<ContentLanguageUpdateWithoutContentGenerationDetailInput, ContentLanguageUncheckedUpdateWithoutContentGenerationDetailInput>
    create: XOR<ContentLanguageCreateWithoutContentGenerationDetailInput, ContentLanguageUncheckedCreateWithoutContentGenerationDetailInput>
  }

  export type ContentLanguageUpdateWithWhereUniqueWithoutContentGenerationDetailInput = {
    where: ContentLanguageWhereUniqueInput
    data: XOR<ContentLanguageUpdateWithoutContentGenerationDetailInput, ContentLanguageUncheckedUpdateWithoutContentGenerationDetailInput>
  }

  export type ContentLanguageUpdateManyWithWhereWithoutContentGenerationDetailInput = {
    where: ContentLanguageScalarWhereInput
    data: XOR<ContentLanguageUpdateManyMutationInput, ContentLanguageUncheckedUpdateManyWithoutContentGenerationDetailInput>
  }

  export type ContentLanguageScalarWhereInput = {
    AND?: ContentLanguageScalarWhereInput | ContentLanguageScalarWhereInput[]
    OR?: ContentLanguageScalarWhereInput[]
    NOT?: ContentLanguageScalarWhereInput | ContentLanguageScalarWhereInput[]
    id?: IntFilter<"ContentLanguage"> | number
    language?: StringFilter<"ContentLanguage"> | string
    price?: FloatFilter<"ContentLanguage"> | number
    contentGenerationDetailId?: IntFilter<"ContentLanguage"> | number
  }

  export type ContentGenerationDetailCreateWithoutContentTypesInput = {
    volume?: string | null
    contentTone?: string | null
    targetKeywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutContentGenerationDetailsInput
    contentLanguages?: ContentLanguageCreateNestedManyWithoutContentGenerationDetailInput
  }

  export type ContentGenerationDetailUncheckedCreateWithoutContentTypesInput = {
    id?: number
    volume?: string | null
    contentTone?: string | null
    targetKeywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    contentLanguages?: ContentLanguageUncheckedCreateNestedManyWithoutContentGenerationDetailInput
  }

  export type ContentGenerationDetailCreateOrConnectWithoutContentTypesInput = {
    where: ContentGenerationDetailWhereUniqueInput
    create: XOR<ContentGenerationDetailCreateWithoutContentTypesInput, ContentGenerationDetailUncheckedCreateWithoutContentTypesInput>
  }

  export type ContentGenerationDetailUpsertWithoutContentTypesInput = {
    update: XOR<ContentGenerationDetailUpdateWithoutContentTypesInput, ContentGenerationDetailUncheckedUpdateWithoutContentTypesInput>
    create: XOR<ContentGenerationDetailCreateWithoutContentTypesInput, ContentGenerationDetailUncheckedCreateWithoutContentTypesInput>
    where?: ContentGenerationDetailWhereInput
  }

  export type ContentGenerationDetailUpdateToOneWithWhereWithoutContentTypesInput = {
    where?: ContentGenerationDetailWhereInput
    data: XOR<ContentGenerationDetailUpdateWithoutContentTypesInput, ContentGenerationDetailUncheckedUpdateWithoutContentTypesInput>
  }

  export type ContentGenerationDetailUpdateWithoutContentTypesInput = {
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutContentGenerationDetailsNestedInput
    contentLanguages?: ContentLanguageUpdateManyWithoutContentGenerationDetailNestedInput
  }

  export type ContentGenerationDetailUncheckedUpdateWithoutContentTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    contentLanguages?: ContentLanguageUncheckedUpdateManyWithoutContentGenerationDetailNestedInput
  }

  export type ContentGenerationDetailCreateWithoutContentLanguagesInput = {
    volume?: string | null
    contentTone?: string | null
    targetKeywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutContentGenerationDetailsInput
    contentTypes?: ContentTypeCreateNestedManyWithoutContentGenerationDetailInput
  }

  export type ContentGenerationDetailUncheckedCreateWithoutContentLanguagesInput = {
    id?: number
    volume?: string | null
    contentTone?: string | null
    targetKeywords?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
    contentTypes?: ContentTypeUncheckedCreateNestedManyWithoutContentGenerationDetailInput
  }

  export type ContentGenerationDetailCreateOrConnectWithoutContentLanguagesInput = {
    where: ContentGenerationDetailWhereUniqueInput
    create: XOR<ContentGenerationDetailCreateWithoutContentLanguagesInput, ContentGenerationDetailUncheckedCreateWithoutContentLanguagesInput>
  }

  export type ContentGenerationDetailUpsertWithoutContentLanguagesInput = {
    update: XOR<ContentGenerationDetailUpdateWithoutContentLanguagesInput, ContentGenerationDetailUncheckedUpdateWithoutContentLanguagesInput>
    create: XOR<ContentGenerationDetailCreateWithoutContentLanguagesInput, ContentGenerationDetailUncheckedCreateWithoutContentLanguagesInput>
    where?: ContentGenerationDetailWhereInput
  }

  export type ContentGenerationDetailUpdateToOneWithWhereWithoutContentLanguagesInput = {
    where?: ContentGenerationDetailWhereInput
    data: XOR<ContentGenerationDetailUpdateWithoutContentLanguagesInput, ContentGenerationDetailUncheckedUpdateWithoutContentLanguagesInput>
  }

  export type ContentGenerationDetailUpdateWithoutContentLanguagesInput = {
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutContentGenerationDetailsNestedInput
    contentTypes?: ContentTypeUpdateManyWithoutContentGenerationDetailNestedInput
  }

  export type ContentGenerationDetailUncheckedUpdateWithoutContentLanguagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    contentTone?: NullableStringFieldUpdateOperationsInput | string | null
    targetKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    contentTypes?: ContentTypeUncheckedUpdateManyWithoutContentGenerationDetailNestedInput
  }

  export type ProjectCreateWithoutAppDevelopmentDetailsInput = {
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutProjectsInput
    webDevelopmentDetails?: WebDevelopmentDetailCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAppDevelopmentDetailsInput = {
    id?: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedCreateNestedOneWithoutProjectInput
    seoDetails?: SeoDetailUncheckedCreateNestedOneWithoutProjectInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedCreateNestedOneWithoutProjectInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAppDevelopmentDetailsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAppDevelopmentDetailsInput, ProjectUncheckedCreateWithoutAppDevelopmentDetailsInput>
  }

  export type AppFeatureCreateWithoutAppDevelopmentDetailInput = {
    feature: string
    price: number
  }

  export type AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput = {
    id?: number
    feature: string
    price: number
  }

  export type AppFeatureCreateOrConnectWithoutAppDevelopmentDetailInput = {
    where: AppFeatureWhereUniqueInput
    create: XOR<AppFeatureCreateWithoutAppDevelopmentDetailInput, AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput>
  }

  export type AppFeatureCreateManyAppDevelopmentDetailInputEnvelope = {
    data: AppFeatureCreateManyAppDevelopmentDetailInput | AppFeatureCreateManyAppDevelopmentDetailInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutAppDevelopmentDetailsInput = {
    update: XOR<ProjectUpdateWithoutAppDevelopmentDetailsInput, ProjectUncheckedUpdateWithoutAppDevelopmentDetailsInput>
    create: XOR<ProjectCreateWithoutAppDevelopmentDetailsInput, ProjectUncheckedCreateWithoutAppDevelopmentDetailsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAppDevelopmentDetailsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAppDevelopmentDetailsInput, ProjectUncheckedUpdateWithoutAppDevelopmentDetailsInput>
  }

  export type ProjectUpdateWithoutAppDevelopmentDetailsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProjectsNestedInput
    webDevelopmentDetails?: WebDevelopmentDetailUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAppDevelopmentDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUncheckedUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type AppFeatureUpsertWithWhereUniqueWithoutAppDevelopmentDetailInput = {
    where: AppFeatureWhereUniqueInput
    update: XOR<AppFeatureUpdateWithoutAppDevelopmentDetailInput, AppFeatureUncheckedUpdateWithoutAppDevelopmentDetailInput>
    create: XOR<AppFeatureCreateWithoutAppDevelopmentDetailInput, AppFeatureUncheckedCreateWithoutAppDevelopmentDetailInput>
  }

  export type AppFeatureUpdateWithWhereUniqueWithoutAppDevelopmentDetailInput = {
    where: AppFeatureWhereUniqueInput
    data: XOR<AppFeatureUpdateWithoutAppDevelopmentDetailInput, AppFeatureUncheckedUpdateWithoutAppDevelopmentDetailInput>
  }

  export type AppFeatureUpdateManyWithWhereWithoutAppDevelopmentDetailInput = {
    where: AppFeatureScalarWhereInput
    data: XOR<AppFeatureUpdateManyMutationInput, AppFeatureUncheckedUpdateManyWithoutAppDevelopmentDetailInput>
  }

  export type AppFeatureScalarWhereInput = {
    AND?: AppFeatureScalarWhereInput | AppFeatureScalarWhereInput[]
    OR?: AppFeatureScalarWhereInput[]
    NOT?: AppFeatureScalarWhereInput | AppFeatureScalarWhereInput[]
    id?: IntFilter<"AppFeature"> | number
    feature?: StringFilter<"AppFeature"> | string
    price?: FloatFilter<"AppFeature"> | number
    appDevelopmentDetailId?: IntFilter<"AppFeature"> | number
  }

  export type AppDevelopmentDetailCreateWithoutAppFeaturesInput = {
    appType?: string | null
    complexity?: string | null
    targetPlatforms?: string | null
    expectedUsers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAppDevelopmentDetailsInput
  }

  export type AppDevelopmentDetailUncheckedCreateWithoutAppFeaturesInput = {
    id?: number
    appType?: string | null
    complexity?: string | null
    targetPlatforms?: string | null
    expectedUsers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type AppDevelopmentDetailCreateOrConnectWithoutAppFeaturesInput = {
    where: AppDevelopmentDetailWhereUniqueInput
    create: XOR<AppDevelopmentDetailCreateWithoutAppFeaturesInput, AppDevelopmentDetailUncheckedCreateWithoutAppFeaturesInput>
  }

  export type AppDevelopmentDetailUpsertWithoutAppFeaturesInput = {
    update: XOR<AppDevelopmentDetailUpdateWithoutAppFeaturesInput, AppDevelopmentDetailUncheckedUpdateWithoutAppFeaturesInput>
    create: XOR<AppDevelopmentDetailCreateWithoutAppFeaturesInput, AppDevelopmentDetailUncheckedCreateWithoutAppFeaturesInput>
    where?: AppDevelopmentDetailWhereInput
  }

  export type AppDevelopmentDetailUpdateToOneWithWhereWithoutAppFeaturesInput = {
    where?: AppDevelopmentDetailWhereInput
    data: XOR<AppDevelopmentDetailUpdateWithoutAppFeaturesInput, AppDevelopmentDetailUncheckedUpdateWithoutAppFeaturesInput>
  }

  export type AppDevelopmentDetailUpdateWithoutAppFeaturesInput = {
    appType?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: NullableStringFieldUpdateOperationsInput | string | null
    targetPlatforms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAppDevelopmentDetailsNestedInput
  }

  export type AppDevelopmentDetailUncheckedUpdateWithoutAppFeaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    appType?: NullableStringFieldUpdateOperationsInput | string | null
    complexity?: NullableStringFieldUpdateOperationsInput | string | null
    targetPlatforms?: NullableStringFieldUpdateOperationsInput | string | null
    expectedUsers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectCreateManyUserInput = {
    id?: number
    username: string
    email: string
    password: string
    projectName: string
    projectTitle: string
    category: string
    price?: number
    deadline?: string | null
    details?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFormCreateManyUserInput = {
    id?: number
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateWithoutUserInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webDevelopmentDetails?: WebDevelopmentDetailUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webDevelopmentDetails?: WebDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
    seoDetails?: SeoDetailUncheckedUpdateOneWithoutProjectNestedInput
    digitalMarketingDetails?: DigitalMarketingDetailUncheckedUpdateOneWithoutProjectNestedInput
    contentGenerationDetails?: ContentGenerationDetailUncheckedUpdateOneWithoutProjectNestedInput
    appDevelopmentDetails?: AppDevelopmentDetailUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    projectName?: StringFieldUpdateOperationsInput | string
    projectTitle?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    deadline?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFormUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebDevelopmentFeatureCreateManyWebDevDetailInput = {
    id?: number
    feature: string
    price: number
  }

  export type WebDevelopmentFeatureUpdateWithoutWebDevDetailInput = {
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type WebDevelopmentFeatureUncheckedUpdateWithoutWebDevDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type WebDevelopmentFeatureUncheckedUpdateManyWithoutWebDevDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type SeoTypeCreateManySeoDetailInput = {
    id?: number
    seoType: string
    price: number
  }

  export type SeoTypeUpdateWithoutSeoDetailInput = {
    seoType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type SeoTypeUncheckedUpdateWithoutSeoDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    seoType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type SeoTypeUncheckedUpdateManyWithoutSeoDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    seoType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type DigitalMarketingServiceCreateManyDigitalMarketingDetailInput = {
    id?: number
    service: string
    price: number
  }

  export type SocialPlatformCreateManyDigitalMarketingDetailInput = {
    id?: number
    platform: string
    price: number
  }

  export type DigitalMarketingServiceUpdateWithoutDigitalMarketingDetailInput = {
    service?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type DigitalMarketingServiceUncheckedUpdateWithoutDigitalMarketingDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    service?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type DigitalMarketingServiceUncheckedUpdateManyWithoutDigitalMarketingDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    service?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type SocialPlatformUpdateWithoutDigitalMarketingDetailInput = {
    platform?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type SocialPlatformUncheckedUpdateWithoutDigitalMarketingDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type SocialPlatformUncheckedUpdateManyWithoutDigitalMarketingDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    platform?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ContentTypeCreateManyContentGenerationDetailInput = {
    id?: number
    contentType: string
    price: number
  }

  export type ContentLanguageCreateManyContentGenerationDetailInput = {
    id?: number
    language: string
    price: number
  }

  export type ContentTypeUpdateWithoutContentGenerationDetailInput = {
    contentType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ContentTypeUncheckedUpdateWithoutContentGenerationDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ContentTypeUncheckedUpdateManyWithoutContentGenerationDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ContentLanguageUpdateWithoutContentGenerationDetailInput = {
    language?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ContentLanguageUncheckedUpdateWithoutContentGenerationDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type ContentLanguageUncheckedUpdateManyWithoutContentGenerationDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type AppFeatureCreateManyAppDevelopmentDetailInput = {
    id?: number
    feature: string
    price: number
  }

  export type AppFeatureUpdateWithoutAppDevelopmentDetailInput = {
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type AppFeatureUncheckedUpdateWithoutAppDevelopmentDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type AppFeatureUncheckedUpdateManyWithoutAppDevelopmentDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}